{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n// @ts-nocheck\nvar deferred_1 = require(\"./deferred\");\nvar eventtarget_1 = require(\"./eventtarget\");\n/**\n * An {@link AudioPlayer} is an HTMLAudioElement-like object that uses AudioContext\n *   to circumvent browser limitations.\n * @private\n */\nvar AudioPlayer = /** @class */function (_super) {\n  __extends(AudioPlayer, _super);\n  /**\n   * @private\n   */\n  function AudioPlayer(audioContext, srcOrOptions, options) {\n    if (srcOrOptions === void 0) {\n      srcOrOptions = {};\n    }\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = _super.call(this) || this;\n    /**\n     * The AudioBufferSourceNode of the actively loaded sound. Null if a sound\n     *   has not been loaded yet. This is re-used for each time the sound is\n     *   played.\n     */\n    _this._audioNode = null;\n    /**\n     * Whether or not the audio element should loop. If disabled during playback,\n     *   playing continues until the sound ends and then stops looping.\n     */\n    _this._loop = false;\n    /**\n     * An Array of deferred-like objects for each pending `play` Promise. When\n     *   .pause() is called or .src is set, all pending play Promises are\n     *   immediately rejected.\n     */\n    _this._pendingPlayDeferreds = [];\n    /**\n     * The current sinkId of the device audio is being played through.\n     */\n    _this._sinkId = 'default';\n    /**\n     * The source URL of the sound to play. When set, the currently playing sound will stop.\n     */\n    _this._src = '';\n    if (typeof srcOrOptions !== 'string') {\n      options = srcOrOptions;\n    }\n    _this._audioContext = audioContext;\n    _this._audioElement = new (options.AudioFactory || Audio)();\n    _this._bufferPromise = _this._createPlayDeferred().promise;\n    _this._destination = _this._audioContext.destination;\n    _this._gainNode = _this._audioContext.createGain();\n    _this._gainNode.connect(_this._destination);\n    _this._XMLHttpRequest = options.XMLHttpRequestFactory || XMLHttpRequest;\n    _this.addEventListener('canplaythrough', function () {\n      _this._resolvePlayDeferreds();\n    });\n    if (typeof srcOrOptions === 'string') {\n      _this.src = srcOrOptions;\n    }\n    return _this;\n  }\n  Object.defineProperty(AudioPlayer.prototype, \"destination\", {\n    get: function () {\n      return this._destination;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AudioPlayer.prototype, \"loop\", {\n    get: function () {\n      return this._loop;\n    },\n    set: function (shouldLoop) {\n      var self = this;\n      function pauseAfterPlaythrough() {\n        self._audioNode.removeEventListener('ended', pauseAfterPlaythrough);\n        self.pause();\n      }\n      // If a sound is already looping, it should continue playing\n      //   the current playthrough and then stop.\n      if (!shouldLoop && this.loop && !this.paused) {\n        this._audioNode.addEventListener('ended', pauseAfterPlaythrough);\n      }\n      this._loop = shouldLoop;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AudioPlayer.prototype, \"muted\", {\n    /**\n     * Whether the audio element is muted.\n     */\n    get: function () {\n      return this._gainNode.gain.value === 0;\n    },\n    set: function (shouldBeMuted) {\n      this._gainNode.gain.value = shouldBeMuted ? 0 : 1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AudioPlayer.prototype, \"paused\", {\n    /**\n     * Whether the sound is paused. this._audioNode only exists when sound is playing;\n     *   otherwise AudioPlayer is considered paused.\n     */\n    get: function () {\n      return this._audioNode === null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AudioPlayer.prototype, \"src\", {\n    get: function () {\n      return this._src;\n    },\n    set: function (src) {\n      this._load(src);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AudioPlayer.prototype, \"srcObject\", {\n    /**\n     * The srcObject of the HTMLMediaElement\n     */\n    get: function () {\n      return this._audioElement.srcObject;\n    },\n    set: function (srcObject) {\n      this._audioElement.srcObject = srcObject;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AudioPlayer.prototype, \"sinkId\", {\n    get: function () {\n      return this._sinkId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Stop any ongoing playback and reload the source file.\n   */\n  AudioPlayer.prototype.load = function () {\n    this._load(this._src);\n  };\n  /**\n   * Pause the audio coming from this AudioPlayer. This will reject any pending\n   *   play Promises.\n   */\n  AudioPlayer.prototype.pause = function () {\n    if (this.paused) {\n      return;\n    }\n    this._audioElement.pause();\n    this._audioNode.stop();\n    this._audioNode.disconnect(this._gainNode);\n    this._audioNode = null;\n    this._rejectPlayDeferreds(new Error('The play() request was interrupted by a call to pause().'));\n  };\n  /**\n   * Play the sound. If the buffer hasn't loaded yet, wait for the buffer to load. If\n   *   the source URL is not set yet, this Promise will remain pending until a source\n   *   URL is set.\n   */\n  AudioPlayer.prototype.play = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var buffer;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!this.paused) return [3 /*break*/, 2];\n            return [4 /*yield*/, this._bufferPromise];\n          case 1:\n            _a.sent();\n            if (!this.paused) {\n              return [2 /*return*/];\n            }\n\n            throw new Error('The play() request was interrupted by a call to pause().');\n          case 2:\n            this._audioNode = this._audioContext.createBufferSource();\n            this._audioNode.loop = this.loop;\n            this._audioNode.addEventListener('ended', function () {\n              if (_this._audioNode && _this._audioNode.loop) {\n                return;\n              }\n              _this.dispatchEvent('ended');\n            });\n            return [4 /*yield*/, this._bufferPromise];\n          case 3:\n            buffer = _a.sent();\n            if (this.paused) {\n              throw new Error('The play() request was interrupted by a call to pause().');\n            }\n            this._audioNode.buffer = buffer;\n            this._audioNode.connect(this._gainNode);\n            this._audioNode.start();\n            if (this._audioElement.srcObject) {\n              return [2 /*return*/, this._audioElement.play()];\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Change which device the sound should play through.\n   * @param sinkId - The sink of the device to play sound through.\n   */\n  AudioPlayer.prototype.setSinkId = function (sinkId) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (typeof this._audioElement.setSinkId !== 'function') {\n              throw new Error('This browser does not support setSinkId.');\n            }\n            if (sinkId === this.sinkId) {\n              return [2 /*return*/];\n            }\n\n            if (sinkId === 'default') {\n              if (!this.paused) {\n                this._gainNode.disconnect(this._destination);\n              }\n              this._audioElement.srcObject = null;\n              this._destination = this._audioContext.destination;\n              this._gainNode.connect(this._destination);\n              this._sinkId = sinkId;\n              return [2 /*return*/];\n            }\n\n            return [4 /*yield*/, this._audioElement.setSinkId(sinkId)];\n          case 1:\n            _a.sent();\n            if (this._audioElement.srcObject) {\n              return [2 /*return*/];\n            }\n\n            this._gainNode.disconnect(this._audioContext.destination);\n            this._destination = this._audioContext.createMediaStreamDestination();\n            this._audioElement.srcObject = this._destination.stream;\n            this._sinkId = sinkId;\n            this._gainNode.connect(this._destination);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Create a Deferred for a Promise that will be resolved when .src is set or rejected\n   *   when .pause is called.\n   */\n  AudioPlayer.prototype._createPlayDeferred = function () {\n    var deferred = new deferred_1.default();\n    this._pendingPlayDeferreds.push(deferred);\n    return deferred;\n  };\n  /**\n   * Stop current playback and load a sound file.\n   * @param src - The source URL of the file to load\n   */\n  AudioPlayer.prototype._load = function (src) {\n    var _this = this;\n    if (this._src && this._src !== src) {\n      this.pause();\n    }\n    this._src = src;\n    this._bufferPromise = new Promise(function (resolve, reject) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var buffer;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!src) {\n                return [2 /*return*/, this._createPlayDeferred().promise];\n              }\n              return [4 /*yield*/, bufferSound(this._audioContext, this._XMLHttpRequest, src)];\n            case 1:\n              buffer = _a.sent();\n              this.dispatchEvent('canplaythrough');\n              resolve(buffer);\n              return [2 /*return*/];\n          }\n        });\n      });\n    });\n  };\n  /**\n   * Reject all deferreds for the Play promise.\n   * @param reason\n   */\n  AudioPlayer.prototype._rejectPlayDeferreds = function (reason) {\n    var deferreds = this._pendingPlayDeferreds;\n    deferreds.splice(0, deferreds.length).forEach(function (_a) {\n      var reject = _a.reject;\n      return reject(reason);\n    });\n  };\n  /**\n   * Resolve all deferreds for the Play promise.\n   * @param result\n   */\n  AudioPlayer.prototype._resolvePlayDeferreds = function (result) {\n    var deferreds = this._pendingPlayDeferreds;\n    deferreds.splice(0, deferreds.length).forEach(function (_a) {\n      var resolve = _a.resolve;\n      return resolve(result);\n    });\n  };\n  return AudioPlayer;\n}(eventtarget_1.default);\n/**\n * Use XMLHttpRequest to load the AudioBuffer of a remote audio asset.\n * @private\n * @param context - The AudioContext to use to decode the audio data\n * @param RequestFactory - The XMLHttpRequest factory to build\n * @param src - The URL of the audio asset to load.\n * @returns A Promise containing the decoded AudioBuffer.\n */\n// tslint:disable-next-line:variable-name\nfunction bufferSound(context, RequestFactory, src) {\n  return __awaiter(this, void 0, void 0, function () {\n    var request, event;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          request = new RequestFactory();\n          request.open('GET', src, true);\n          request.responseType = 'arraybuffer';\n          return [4 /*yield*/, new Promise(function (resolve) {\n            request.addEventListener('load', resolve);\n            request.send();\n          })];\n        case 1:\n          event = _a.sent();\n          // Safari uses a callback here instead of a Promise.\n          try {\n            return [2 /*return*/, context.decodeAudioData(event.target.response)];\n          } catch (e) {\n            return [2 /*return*/, new Promise(function (resolve) {\n              context.decodeAudioData(event.target.response, resolve);\n            })];\n          }\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nexports.default = AudioPlayer;","map":{"version":3,"names":["deferred_1","require","eventtarget_1","AudioPlayer","_super","__extends","audioContext","srcOrOptions","options","_this","call","_audioNode","_loop","_pendingPlayDeferreds","_sinkId","_src","_audioContext","_audioElement","AudioFactory","Audio","_bufferPromise","_createPlayDeferred","promise","_destination","destination","_gainNode","createGain","connect","_XMLHttpRequest","XMLHttpRequestFactory","XMLHttpRequest","addEventListener","_resolvePlayDeferreds","src","Object","defineProperty","prototype","get","set","shouldLoop","self","pauseAfterPlaythrough","removeEventListener","pause","loop","paused","gain","value","shouldBeMuted","_load","srcObject","load","stop","disconnect","_rejectPlayDeferreds","Error","play","_a","sent","createBufferSource","dispatchEvent","buffer","start","setSinkId","sinkId","createMediaStreamDestination","stream","deferred","default","push","Promise","resolve","reject","__awaiter","bufferSound","reason","deferreds","splice","length","forEach","result","context","RequestFactory","request","open","responseType","send","event","decodeAudioData","target","response","e","exports"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/@twilio/voice-sdk/lib/twilio/audioplayer/audioplayer.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n// @ts-nocheck\nimport Deferred from './deferred';\nimport EventTarget from './eventtarget';\n\nimport ChromeAudioContext, { ChromeHTMLAudioElement, MediaStreamAudioDestinationNode } from './chromeaudiocontext';\n\n/**\n * Options that may be passed to AudioPlayer for dependency injection.\n */\ninterface IAudioPlayerOptions {\n  /**\n   * The factory for Audio.\n   */\n  AudioFactory: any;\n\n  /**\n   * The factory for XMLHttpRequest.\n   */\n  XMLHttpRequestFactory: any;\n}\n\n/**\n * An {@link AudioPlayer} is an HTMLAudioElement-like object that uses AudioContext\n *   to circumvent browser limitations.\n * @private\n */\nclass AudioPlayer extends EventTarget {\n  /**\n   * The AudioContext. This is passed in at construction and used to create\n   *   MediaStreamBuffers and AudioNodes for playing sound through.\n   */\n  private _audioContext: ChromeAudioContext;\n\n  /**\n   * The Audio element that is used to play sound through when a non-default\n   *   sinkId is set.\n   */\n  private _audioElement: ChromeHTMLAudioElement;\n\n  /**\n   * The AudioBufferSourceNode of the actively loaded sound. Null if a sound\n   *   has not been loaded yet. This is re-used for each time the sound is\n   *   played.\n   */\n  private _audioNode: AudioBufferSourceNode|null = null;\n\n  /**\n   * A Promise for the AudioBuffer. Listening for the resolution of this Promise\n   *   delays an operation until after the sound is loaded and ready to be\n   *   played.\n   */\n  private _bufferPromise: Promise<AudioBuffer>;\n\n  /**\n   * The current destination for audio playback. This is set to context.destination\n   *   when default, or a specific MediaStreamAudioDestinationNode when setSinkId\n   *   is set.\n   */\n  private _destination: MediaStreamAudioDestinationNode;\n\n  /**\n   * The GainNode used to control whether the sound is muted.\n   */\n  private _gainNode: GainNode;\n\n  /**\n   * Whether or not the audio element should loop. If disabled during playback,\n   *   playing continues until the sound ends and then stops looping.\n   */\n  private _loop: boolean = false;\n\n  /**\n   * An Array of deferred-like objects for each pending `play` Promise. When\n   *   .pause() is called or .src is set, all pending play Promises are\n   *   immediately rejected.\n   */\n  private _pendingPlayDeferreds: Array<Deferred<AudioBuffer>> = [];\n\n  /**\n   * The current sinkId of the device audio is being played through.\n   */\n  private _sinkId: string = 'default';\n\n  /**\n   * The source URL of the sound to play. When set, the currently playing sound will stop.\n   */\n  private _src: string = '';\n\n  /**\n   * The Factory to use to construct an XMLHttpRequest.\n   */\n  private _XMLHttpRequest: any;\n\n  get destination(): MediaStreamAudioDestinationNode { return this._destination; }\n  get loop(): boolean { return this._loop; }\n  set loop(shouldLoop: boolean) {\n    const self = this;\n    function pauseAfterPlaythrough() {\n      self._audioNode.removeEventListener('ended', pauseAfterPlaythrough);\n      self.pause();\n    }\n    // If a sound is already looping, it should continue playing\n    //   the current playthrough and then stop.\n    if (!shouldLoop && this.loop && !this.paused) {\n      this._audioNode.addEventListener('ended', pauseAfterPlaythrough);\n    }\n\n    this._loop = shouldLoop;\n  }\n\n  /**\n   * Whether the audio element is muted.\n   */\n  get muted(): boolean { return this._gainNode.gain.value === 0; }\n  set muted(shouldBeMuted: boolean) {\n    this._gainNode.gain.value = shouldBeMuted ? 0 : 1;\n  }\n\n  /**\n   * Whether the sound is paused. this._audioNode only exists when sound is playing;\n   *   otherwise AudioPlayer is considered paused.\n   */\n  get paused(): boolean { return this._audioNode === null; }\n  get src(): string { return this._src; }\n  set src(src: string) {\n    this._load(src);\n  }\n\n  /**\n   * The srcObject of the HTMLMediaElement\n   */\n  get srcObject(): MediaStream | MediaSource | Blob | undefined {\n    return this._audioElement.srcObject;\n  }\n  set srcObject(srcObject: MediaStream | MediaSource | Blob | undefined) {\n    this._audioElement.srcObject = srcObject;\n  }\n  get sinkId(): string { return this._sinkId; }\n\n  /**\n   * @param audioContext - The AudioContext to use for controlling sound the through.\n   * @param options\n   */\n  constructor(audioContext: any,\n              options?: IAudioPlayerOptions);\n\n  /**\n   * @param audioContext - The AudioContext to use for controlling sound the through.\n   * @param src - The URL of the sound to load.\n   * @param options\n   */\n  constructor(audioContext: any,\n              src: string,\n              options?: IAudioPlayerOptions);\n\n  /**\n   * @private\n   */\n  constructor(audioContext: any,\n              srcOrOptions: string|IAudioPlayerOptions = { } as IAudioPlayerOptions,\n              options: IAudioPlayerOptions = { } as IAudioPlayerOptions) {\n    super();\n\n    if (typeof srcOrOptions !== 'string') {\n      options = srcOrOptions;\n    }\n\n    this._audioContext = audioContext as ChromeAudioContext;\n    this._audioElement = new (options.AudioFactory || Audio)();\n    this._bufferPromise = this._createPlayDeferred().promise;\n    this._destination = this._audioContext.destination;\n    this._gainNode = this._audioContext.createGain();\n    this._gainNode.connect(this._destination);\n    this._XMLHttpRequest = options.XMLHttpRequestFactory || XMLHttpRequest;\n\n    this.addEventListener('canplaythrough', () => {\n      this._resolvePlayDeferreds();\n    });\n\n    if (typeof srcOrOptions === 'string') {\n      this.src = srcOrOptions;\n    }\n  }\n\n  /**\n   * Stop any ongoing playback and reload the source file.\n   */\n  load(): void {\n    this._load(this._src);\n  }\n\n  /**\n   * Pause the audio coming from this AudioPlayer. This will reject any pending\n   *   play Promises.\n   */\n  pause(): void {\n    if (this.paused) { return; }\n\n    this._audioElement.pause();\n\n    this._audioNode.stop();\n    this._audioNode.disconnect(this._gainNode);\n    this._audioNode = null;\n\n    this._rejectPlayDeferreds(new Error('The play() request was interrupted by a call to pause().'));\n  }\n\n  /**\n   * Play the sound. If the buffer hasn't loaded yet, wait for the buffer to load. If\n   *   the source URL is not set yet, this Promise will remain pending until a source\n   *   URL is set.\n   */\n  async play(): Promise<void> {\n    if (!this.paused) {\n      await this._bufferPromise;\n      if (!this.paused) { return; }\n      throw new Error('The play() request was interrupted by a call to pause().');\n    }\n\n    this._audioNode = this._audioContext.createBufferSource();\n    this._audioNode.loop = this.loop;\n\n    this._audioNode.addEventListener('ended', () => {\n      if (this._audioNode && this._audioNode.loop) { return; }\n      this.dispatchEvent('ended');\n    });\n\n    const buffer: AudioBuffer = await this._bufferPromise;\n\n    if (this.paused) {\n      throw new Error('The play() request was interrupted by a call to pause().');\n    }\n\n    this._audioNode.buffer = buffer;\n    this._audioNode.connect(this._gainNode);\n    this._audioNode.start();\n\n    if (this._audioElement.srcObject) {\n      return this._audioElement.play();\n    }\n  }\n\n  /**\n   * Change which device the sound should play through.\n   * @param sinkId - The sink of the device to play sound through.\n   */\n  async setSinkId(sinkId: string): Promise<void> {\n    if (typeof this._audioElement.setSinkId !== 'function') {\n      throw new Error('This browser does not support setSinkId.');\n    }\n\n    if (sinkId === this.sinkId) {\n      return;\n    }\n\n    if (sinkId === 'default') {\n      if (!this.paused) {\n        this._gainNode.disconnect(this._destination);\n      }\n\n      this._audioElement.srcObject = null;\n      this._destination = this._audioContext.destination;\n      this._gainNode.connect(this._destination);\n      this._sinkId = sinkId;\n      return;\n    }\n\n    await this._audioElement.setSinkId(sinkId);\n    if (this._audioElement.srcObject) { return; }\n\n    this._gainNode.disconnect(this._audioContext.destination);\n    this._destination = this._audioContext.createMediaStreamDestination();\n    this._audioElement.srcObject = this._destination.stream;\n    this._sinkId = sinkId;\n\n    this._gainNode.connect(this._destination);\n  }\n\n  /**\n   * Create a Deferred for a Promise that will be resolved when .src is set or rejected\n   *   when .pause is called.\n   */\n  private _createPlayDeferred(): Deferred<AudioBuffer> {\n    const deferred = new Deferred();\n    this._pendingPlayDeferreds.push(deferred as Deferred<AudioBuffer>);\n    return deferred as Deferred<AudioBuffer>;\n  }\n\n  /**\n   * Stop current playback and load a sound file.\n   * @param src - The source URL of the file to load\n   */\n  private _load(src: string): void {\n    if (this._src && this._src !== src) {\n      this.pause();\n    }\n\n    this._src = src;\n    this._bufferPromise = new Promise(async (resolve, reject) => {\n      if (!src) {\n        return this._createPlayDeferred().promise;\n      }\n\n      const buffer = await bufferSound(this._audioContext, this._XMLHttpRequest, src);\n      this.dispatchEvent('canplaythrough');\n      resolve(buffer);\n    });\n  }\n\n  /**\n   * Reject all deferreds for the Play promise.\n   * @param reason\n   */\n  private _rejectPlayDeferreds(reason?: any): void {\n    const deferreds = this._pendingPlayDeferreds;\n    deferreds.splice(0, deferreds.length).forEach(({ reject }) => reject(reason));\n  }\n\n  /**\n   * Resolve all deferreds for the Play promise.\n   * @param result\n   */\n  private _resolvePlayDeferreds(result?: any): void {\n    const deferreds = this._pendingPlayDeferreds;\n    deferreds.splice(0, deferreds.length).forEach(({ resolve }) => resolve(result));\n  }\n}\n\n/**\n * Use XMLHttpRequest to load the AudioBuffer of a remote audio asset.\n * @private\n * @param context - The AudioContext to use to decode the audio data\n * @param RequestFactory - The XMLHttpRequest factory to build\n * @param src - The URL of the audio asset to load.\n * @returns A Promise containing the decoded AudioBuffer.\n */\n// tslint:disable-next-line:variable-name\nasync function bufferSound(context: any, RequestFactory: any, src: string): Promise<AudioBuffer> {\n  const request: XMLHttpRequest = new RequestFactory();\n  request.open('GET', src, true);\n  request.responseType = 'arraybuffer';\n\n  const event: any = await new Promise(resolve => {\n    request.addEventListener('load', resolve);\n    request.send();\n  });\n\n  // Safari uses a callback here instead of a Promise.\n  try {\n    return context.decodeAudioData(event.target.response);\n  } catch (e) {\n    return new Promise(resolve => {\n      context.decodeAudioData(event.target.response, resolve);\n    }) as Promise<AudioBuffer>;\n  }\n}\n\nexport default AudioPlayer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}