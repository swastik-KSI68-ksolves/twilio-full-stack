{"ast":null,"code":"\"use strict\";\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n  return r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRTCIceCandidateStatsReport = exports.getRTCStats = void 0;\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n// @ts-nocheck\n// tslint:disable no-empty\nvar errors_1 = require(\"../errors\");\nvar mockrtcstatsreport_1 = require(\"./mockrtcstatsreport\");\nvar ERROR_PEER_CONNECTION_NULL = 'PeerConnection is null';\nvar ERROR_WEB_RTC_UNSUPPORTED = 'WebRTC statistics are unsupported';\n/**\n * Helper function to find a specific stat from a report.\n * Some environment provide the stats report as a map (regular browsers)\n * but some provide stats report as an array (citrix vdi)\n * @private\n */\nfunction findStatById(report, id) {\n  if (typeof report.get === 'function') {\n    return report.get(id);\n  }\n  return report.find(function (s) {\n    return s.id === id;\n  });\n}\n/**\n * Generate WebRTC statistics report for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCStatsReport>} WebRTC RTCStatsReport object\n */\nfunction getRTCStatsReport(peerConnection) {\n  if (!peerConnection) {\n    return Promise.reject(new errors_1.InvalidArgumentError(ERROR_PEER_CONNECTION_NULL));\n  }\n  if (typeof peerConnection.getStats !== 'function') {\n    return Promise.reject(new errors_1.NotSupportedError(ERROR_WEB_RTC_UNSUPPORTED));\n  }\n  var promise;\n  try {\n    promise = peerConnection.getStats();\n  } catch (e) {\n    promise = new Promise(function (resolve) {\n      return peerConnection.getStats(resolve);\n    }).then(mockrtcstatsreport_1.default.fromRTCStatsResponse);\n  }\n  return promise;\n}\n/**\n * @typedef {Object} StatsOptions\n * Used for testing to inject and extract methods.\n * @property {function} [createRTCSample] - Method for parsing an RTCStatsReport\n */\n/**\n * Collects any WebRTC statistics for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @param {StatsOptions} options - List of custom options.\n * @return {Promise<RTCSample>} Universally-formatted version of RTC stats.\n */\nfunction getRTCStats(peerConnection, options) {\n  options = Object.assign({\n    createRTCSample: createRTCSample\n  }, options);\n  return getRTCStatsReport(peerConnection).then(options.createRTCSample);\n}\nexports.getRTCStats = getRTCStats;\n/**\n * Generate WebRTC stats report containing relevant information about ICE candidates for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCIceCandidateStatsReport>} RTCIceCandidateStatsReport object\n */\nfunction getRTCIceCandidateStatsReport(peerConnection) {\n  return getRTCStatsReport(peerConnection).then(function (report) {\n    // Find the relevant information needed to determine selected candidates later\n    var _a = Array.from(report.values()).reduce(function (rval, stat) {\n        ['candidatePairs', 'localCandidates', 'remoteCandidates'].forEach(function (prop) {\n          if (!rval[prop]) {\n            rval[prop] = [];\n          }\n        });\n        switch (stat.type) {\n          case 'candidate-pair':\n            rval.candidatePairs.push(stat);\n            break;\n          case 'local-candidate':\n            rval.localCandidates.push(stat);\n            break;\n          case 'remote-candidate':\n            rval.remoteCandidates.push(stat);\n            break;\n          case 'transport':\n            // This transport is the one being used if selectedCandidatePairId is populated\n            if (stat.selectedCandidatePairId) {\n              rval.transport = stat;\n            }\n            break;\n        }\n        return rval;\n      }, {}),\n      candidatePairs = _a.candidatePairs,\n      localCandidates = _a.localCandidates,\n      remoteCandidates = _a.remoteCandidates,\n      transport = _a.transport;\n    // This is a report containing information about the selected candidates, such as IDs\n    // This is coming from WebRTC stats directly and doesn't contain the actual ICE Candidates info\n    var selectedCandidatePairReport = candidatePairs.find(function (pair) {\n      // Firefox\n      return pair.selected ||\n      // Spec-compliant way\n      transport && pair.id === transport.selectedCandidatePairId;\n    });\n    var selectedIceCandidatePairStats;\n    if (selectedCandidatePairReport) {\n      selectedIceCandidatePairStats = {\n        localCandidate: localCandidates.find(function (candidate) {\n          return candidate.id === selectedCandidatePairReport.localCandidateId;\n        }),\n        remoteCandidate: remoteCandidates.find(function (candidate) {\n          return candidate.id === selectedCandidatePairReport.remoteCandidateId;\n        })\n      };\n    }\n    // Build the return object\n    return {\n      iceCandidateStats: __spreadArrays(localCandidates, remoteCandidates),\n      selectedIceCandidatePairStats: selectedIceCandidatePairStats\n    };\n  });\n}\nexports.getRTCIceCandidateStatsReport = getRTCIceCandidateStatsReport;\n/**\n * @typedef {Object} RTCSample - A sample containing relevant WebRTC stats information.\n * @property {Number} [timestamp]\n * @property {String} [codecName] - MimeType name of the codec being used by the outbound audio stream\n * @property {Number} [rtt] - Round trip time\n * @property {Number} [jitter]\n * @property {Number} [packetsSent]\n * @property {Number} [packetsLost]\n * @property {Number} [packetsReceived]\n * @property {Number} [bytesReceived]\n * @property {Number} [bytesSent]\n * @property {Number} [localAddress]\n * @property {Number} [remoteAddress]\n */\nfunction RTCSample() {}\n/**\n * Create an RTCSample object from an RTCStatsReport\n * @private\n * @param {RTCStatsReport} statsReport\n * @returns {RTCSample}\n */\nfunction createRTCSample(statsReport) {\n  var activeTransportId = null;\n  var sample = new RTCSample();\n  var fallbackTimestamp;\n  Array.from(statsReport.values()).forEach(function (stats) {\n    // Skip isRemote tracks which will be phased out completely and break in FF66.\n    if (stats.isRemote) {\n      return;\n    }\n    // Firefox hack -- Older firefox doesn't have dashes in type names\n    var type = stats.type.replace('-', '');\n    fallbackTimestamp = fallbackTimestamp || stats.timestamp;\n    // (rrowland) As I understand it, this is supposed to come in on remote-inbound-rtp but it's\n    // currently coming in on remote-outbound-rtp, so I'm leaving this outside the switch until\n    // the appropriate place to look is cleared up.\n    if (stats.remoteId) {\n      var remote = findStatById(statsReport, stats.remoteId);\n      if (remote && remote.roundTripTime) {\n        sample.rtt = remote.roundTripTime * 1000;\n      }\n    }\n    switch (type) {\n      case 'inboundrtp':\n        sample.timestamp = sample.timestamp || stats.timestamp;\n        sample.jitter = stats.jitter * 1000;\n        sample.packetsLost = stats.packetsLost;\n        sample.packetsReceived = stats.packetsReceived;\n        sample.bytesReceived = stats.bytesReceived;\n        break;\n      case 'outboundrtp':\n        sample.timestamp = stats.timestamp;\n        sample.packetsSent = stats.packetsSent;\n        sample.bytesSent = stats.bytesSent;\n        if (stats.codecId) {\n          var codec = findStatById(statsReport, stats.codecId);\n          sample.codecName = codec ? codec.mimeType && codec.mimeType.match(/(.*\\/)?(.*)/)[2] : stats.codecId;\n        }\n        break;\n      case 'transport':\n        activeTransportId = stats.id;\n        break;\n    }\n  });\n  if (!sample.timestamp) {\n    sample.timestamp = fallbackTimestamp;\n  }\n  var activeTransport = findStatById(statsReport, activeTransportId);\n  if (!activeTransport) {\n    return sample;\n  }\n  var selectedCandidatePair = findStatById(statsReport, activeTransport.selectedCandidatePairId);\n  if (!selectedCandidatePair) {\n    return sample;\n  }\n  var localCandidate = findStatById(statsReport, selectedCandidatePair.localCandidateId);\n  var remoteCandidate = findStatById(statsReport, selectedCandidatePair.remoteCandidateId);\n  if (!sample.rtt) {\n    sample.rtt = selectedCandidatePair && selectedCandidatePair.currentRoundTripTime * 1000;\n  }\n  Object.assign(sample, {\n    // ip is deprecated. use address first then ip if on older versions of browser\n    localAddress: localCandidate && (localCandidate.address || localCandidate.ip),\n    remoteAddress: remoteCandidate && (remoteCandidate.address || remoteCandidate.ip)\n  });\n  return sample;\n}","map":{"version":3,"names":["errors_1","require","mockrtcstatsreport_1","ERROR_PEER_CONNECTION_NULL","ERROR_WEB_RTC_UNSUPPORTED","findStatById","report","id","get","find","s","getRTCStatsReport","peerConnection","Promise","reject","InvalidArgumentError","getStats","NotSupportedError","promise","e","resolve","then","default","fromRTCStatsResponse","getRTCStats","options","Object","assign","createRTCSample","exports","getRTCIceCandidateStatsReport","_a","Array","from","values","reduce","rval","stat","forEach","prop","type","candidatePairs","push","localCandidates","remoteCandidates","selectedCandidatePairId","transport","selectedCandidatePairReport","pair","selected","selectedIceCandidatePairStats","localCandidate","candidate","localCandidateId","remoteCandidate","remoteCandidateId","iceCandidateStats","__spreadArrays","RTCSample","statsReport","activeTransportId","sample","fallbackTimestamp","stats","isRemote","replace","timestamp","remoteId","remote","roundTripTime","rtt","jitter","packetsLost","packetsReceived","bytesReceived","packetsSent","bytesSent","codecId","codec","codecName","mimeType","match","activeTransport","selectedCandidatePair","currentRoundTripTime","localAddress","address","ip","remoteAddress"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/@twilio/voice-sdk/lib/twilio/rtc/stats.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n// @ts-nocheck\n// tslint:disable no-empty\nimport { InvalidArgumentError, NotSupportedError } from '../errors';\nimport MockRTCStatsReport from './mockrtcstatsreport';\n\nconst ERROR_PEER_CONNECTION_NULL = 'PeerConnection is null';\nconst ERROR_WEB_RTC_UNSUPPORTED = 'WebRTC statistics are unsupported';\n\n/**\n * Helper function to find a specific stat from a report.\n * Some environment provide the stats report as a map (regular browsers)\n * but some provide stats report as an array (citrix vdi)\n * @private\n */\nfunction findStatById(report, id) {\n  if (typeof report.get === 'function') {\n    return report.get(id);\n  }\n  return report.find(s => s.id === id);\n}\n\n/**\n * Generate WebRTC statistics report for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCStatsReport>} WebRTC RTCStatsReport object\n */\nfunction getRTCStatsReport(peerConnection) {\n  if (!peerConnection) {\n    return Promise.reject(new InvalidArgumentError(ERROR_PEER_CONNECTION_NULL));\n  }\n\n  if (typeof peerConnection.getStats !== 'function') {\n    return Promise.reject(new NotSupportedError(ERROR_WEB_RTC_UNSUPPORTED));\n  }\n\n  let promise;\n  try {\n    promise = peerConnection.getStats();\n  } catch (e) {\n    promise = new Promise(resolve => peerConnection.getStats(resolve)).then(MockRTCStatsReport.fromRTCStatsResponse);\n  }\n\n  return promise;\n}\n\n/**\n * @typedef {Object} StatsOptions\n * Used for testing to inject and extract methods.\n * @property {function} [createRTCSample] - Method for parsing an RTCStatsReport\n */\n/**\n * Collects any WebRTC statistics for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @param {StatsOptions} options - List of custom options.\n * @return {Promise<RTCSample>} Universally-formatted version of RTC stats.\n */\nfunction getRTCStats(peerConnection, options) {\n  options = Object.assign({ createRTCSample }, options);\n\n  return getRTCStatsReport(peerConnection).then(options.createRTCSample);\n}\n\n/**\n * Generate WebRTC stats report containing relevant information about ICE candidates for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCIceCandidateStatsReport>} RTCIceCandidateStatsReport object\n */\nfunction getRTCIceCandidateStatsReport(peerConnection) {\n  return getRTCStatsReport(peerConnection).then((report) => {\n    // Find the relevant information needed to determine selected candidates later\n    const {\n      candidatePairs, localCandidates, remoteCandidates, transport,\n    } = Array.from(report.values()).reduce((rval, stat) => {\n      ['candidatePairs', 'localCandidates', 'remoteCandidates'].forEach((prop) => {\n        if (!rval[prop]) {\n          rval[prop] = [];\n        }\n      });\n\n      switch (stat.type) {\n        case 'candidate-pair':\n          rval.candidatePairs.push(stat);\n          break;\n        case 'local-candidate':\n          rval.localCandidates.push(stat);\n          break;\n        case 'remote-candidate':\n          rval.remoteCandidates.push(stat);\n          break;\n        case 'transport':\n          // This transport is the one being used if selectedCandidatePairId is populated\n          if (stat.selectedCandidatePairId) {\n            rval.transport = stat;\n          }\n          break;\n      }\n\n      return rval;\n    }, {});\n\n    // This is a report containing information about the selected candidates, such as IDs\n    // This is coming from WebRTC stats directly and doesn't contain the actual ICE Candidates info\n    const selectedCandidatePairReport = candidatePairs.find(pair =>\n      // Firefox\n      pair.selected ||\n      // Spec-compliant way\n      (transport && pair.id === transport.selectedCandidatePairId));\n\n    let selectedIceCandidatePairStats;\n    if (selectedCandidatePairReport) {\n      selectedIceCandidatePairStats = {\n        localCandidate: localCandidates.find(candidate => candidate.id === selectedCandidatePairReport.localCandidateId),\n        remoteCandidate: remoteCandidates.find(candidate => candidate.id === selectedCandidatePairReport.remoteCandidateId),\n      };\n    }\n\n    // Build the return object\n    return {\n      iceCandidateStats: [...localCandidates, ...remoteCandidates],\n      selectedIceCandidatePairStats,\n    };\n  });\n}\n\n/**\n * @typedef {Object} RTCSample - A sample containing relevant WebRTC stats information.\n * @property {Number} [timestamp]\n * @property {String} [codecName] - MimeType name of the codec being used by the outbound audio stream\n * @property {Number} [rtt] - Round trip time\n * @property {Number} [jitter]\n * @property {Number} [packetsSent]\n * @property {Number} [packetsLost]\n * @property {Number} [packetsReceived]\n * @property {Number} [bytesReceived]\n * @property {Number} [bytesSent]\n * @property {Number} [localAddress]\n * @property {Number} [remoteAddress]\n */\nfunction RTCSample() { }\n\n/**\n * Create an RTCSample object from an RTCStatsReport\n * @private\n * @param {RTCStatsReport} statsReport\n * @returns {RTCSample}\n */\nfunction createRTCSample(statsReport) {\n  let activeTransportId = null;\n  const sample = new RTCSample();\n  let fallbackTimestamp;\n\n  Array.from(statsReport.values()).forEach(stats => {\n    // Skip isRemote tracks which will be phased out completely and break in FF66.\n    if (stats.isRemote) { return; }\n\n    // Firefox hack -- Older firefox doesn't have dashes in type names\n    const type = stats.type.replace('-', '');\n\n    fallbackTimestamp = fallbackTimestamp || stats.timestamp;\n\n    // (rrowland) As I understand it, this is supposed to come in on remote-inbound-rtp but it's\n    // currently coming in on remote-outbound-rtp, so I'm leaving this outside the switch until\n    // the appropriate place to look is cleared up.\n    if (stats.remoteId) {\n      const remote = findStatById(statsReport, stats.remoteId);\n      if (remote && remote.roundTripTime) {\n        sample.rtt = remote.roundTripTime * 1000;\n      }\n    }\n\n    switch (type) {\n      case 'inboundrtp':\n        sample.timestamp = sample.timestamp || stats.timestamp;\n        sample.jitter = stats.jitter * 1000;\n        sample.packetsLost = stats.packetsLost;\n        sample.packetsReceived = stats.packetsReceived;\n        sample.bytesReceived = stats.bytesReceived;\n\n        break;\n      case 'outboundrtp':\n        sample.timestamp = stats.timestamp;\n        sample.packetsSent = stats.packetsSent;\n        sample.bytesSent = stats.bytesSent;\n\n        if (stats.codecId) {\n          const codec = findStatById(statsReport, stats.codecId);\n          sample.codecName = codec\n            ? codec.mimeType && codec.mimeType.match(/(.*\\/)?(.*)/)[2]\n            : stats.codecId;\n        }\n\n        break;\n      case 'transport':\n        activeTransportId = stats.id;\n        break;\n    }\n  });\n\n  if (!sample.timestamp) {\n    sample.timestamp = fallbackTimestamp;\n  }\n\n  const activeTransport = findStatById(statsReport, activeTransportId);\n  if (!activeTransport) { return sample; }\n\n  const selectedCandidatePair = findStatById(statsReport, activeTransport.selectedCandidatePairId);\n  if (!selectedCandidatePair) { return sample; }\n\n  const localCandidate = findStatById(statsReport, selectedCandidatePair.localCandidateId);\n  const remoteCandidate = findStatById(statsReport, selectedCandidatePair.remoteCandidateId);\n\n  if (!sample.rtt) {\n    sample.rtt = selectedCandidatePair &&\n      (selectedCandidatePair.currentRoundTripTime * 1000);\n  }\n\n  Object.assign(sample, {\n    // ip is deprecated. use address first then ip if on older versions of browser\n    localAddress: localCandidate && (localCandidate.address || localCandidate.ip),\n    remoteAddress: remoteCandidate && (remoteCandidate.address || remoteCandidate.ip),\n  });\n\n  return sample;\n}\n\nexport {\n  getRTCStats,\n  getRTCIceCandidateStatsReport,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}