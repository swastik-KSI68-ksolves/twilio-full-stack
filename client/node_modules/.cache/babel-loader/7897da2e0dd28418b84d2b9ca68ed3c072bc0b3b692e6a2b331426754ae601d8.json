{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PreflightTest = void 0;\n/**\n * @packageDocumentation\n * @module Voice\n * @preferred\n * @publicapi\n */\nvar events_1 = require(\"events\");\nvar call_1 = require(\"../call\");\nvar device_1 = require(\"../device\");\nvar errors_1 = require(\"../errors\");\nvar stats_1 = require(\"../rtc/stats\");\nvar constants_1 = require(\"../constants\");\n/**\n * Runs some tests to identify issues, if any, prohibiting successful calling.\n */\nvar PreflightTest = /** @class */function (_super) {\n  __extends(PreflightTest, _super);\n  /**\n   * Construct a {@link PreflightTest} instance.\n   * @constructor\n   * @param token - A Twilio JWT token string.\n   * @param options\n   */\n  function PreflightTest(token, options) {\n    var _this = _super.call(this) || this;\n    /**\n     * Whether this test has already logged an insights-connection-warning.\n     */\n    _this._hasInsightsErrored = false;\n    /**\n     * Network related timing measurements for this test\n     */\n    _this._networkTiming = {};\n    /**\n     * The options passed to {@link PreflightTest} constructor\n     */\n    _this._options = {\n      codecPreferences: [call_1.default.Codec.PCMU, call_1.default.Codec.Opus],\n      edge: 'roaming',\n      fakeMicInput: false,\n      logLevel: 'error',\n      signalingTimeoutMs: 10000\n    };\n    /**\n     * Current status of this test\n     */\n    _this._status = PreflightTest.Status.Connecting;\n    Object.assign(_this._options, options);\n    _this._samples = [];\n    _this._warnings = [];\n    _this._startTime = Date.now();\n    _this._initDevice(token, __assign(__assign({}, _this._options), {\n      fileInputStream: _this._options.fakeMicInput ? _this._getStreamFromFile() : undefined\n    }));\n    return _this;\n  }\n  /**\n   * Stops the current test and raises a failed event.\n   */\n  PreflightTest.prototype.stop = function () {\n    var _this = this;\n    var error = new errors_1.GeneralErrors.CallCancelledError();\n    if (this._device) {\n      this._device.once(device_1.default.EventName.Unregistered, function () {\n        return _this._onFailed(error);\n      });\n      this._device.destroy();\n    } else {\n      this._onFailed(error);\n    }\n  };\n  /**\n   * Emit a {PreflightTest.Warning}\n   */\n  PreflightTest.prototype._emitWarning = function (name, description, rtcWarning) {\n    var warning = {\n      name: name,\n      description: description\n    };\n    if (rtcWarning) {\n      warning.rtcWarning = rtcWarning;\n    }\n    this._warnings.push(warning);\n    this.emit(PreflightTest.Events.Warning, warning);\n  };\n  /**\n   * Returns call quality base on the RTC Stats\n   */\n  PreflightTest.prototype._getCallQuality = function (mos) {\n    if (mos > 4.2) {\n      return PreflightTest.CallQuality.Excellent;\n    } else if (mos >= 4.1 && mos <= 4.2) {\n      return PreflightTest.CallQuality.Great;\n    } else if (mos >= 3.7 && mos <= 4) {\n      return PreflightTest.CallQuality.Good;\n    } else if (mos >= 3.1 && mos <= 3.6) {\n      return PreflightTest.CallQuality.Fair;\n    } else {\n      return PreflightTest.CallQuality.Degraded;\n    }\n  };\n  /**\n   * Returns the report for this test.\n   */\n  PreflightTest.prototype._getReport = function () {\n    var stats = this._getRTCStats();\n    var testTiming = {\n      start: this._startTime\n    };\n    if (this._endTime) {\n      testTiming.end = this._endTime;\n      testTiming.duration = this._endTime - this._startTime;\n    }\n    var report = {\n      callSid: this._callSid,\n      edge: this._edge,\n      iceCandidateStats: this._rtcIceCandidateStatsReport.iceCandidateStats,\n      networkTiming: this._networkTiming,\n      samples: this._samples,\n      selectedEdge: this._options.edge,\n      stats: stats,\n      testTiming: testTiming,\n      totals: this._getRTCSampleTotals(),\n      warnings: this._warnings\n    };\n    var selectedIceCandidatePairStats = this._rtcIceCandidateStatsReport.selectedIceCandidatePairStats;\n    if (selectedIceCandidatePairStats) {\n      report.selectedIceCandidatePairStats = selectedIceCandidatePairStats;\n      report.isTurnRequired = selectedIceCandidatePairStats.localCandidate.candidateType === 'relay' || selectedIceCandidatePairStats.remoteCandidate.candidateType === 'relay';\n    }\n    if (stats) {\n      report.callQuality = this._getCallQuality(stats.mos.average);\n    }\n    return report;\n  };\n  /**\n   * Returns RTC stats totals for this test\n   */\n  PreflightTest.prototype._getRTCSampleTotals = function () {\n    if (!this._latestSample) {\n      return;\n    }\n    return __assign({}, this._latestSample.totals);\n  };\n  /**\n   * Returns RTC related stats captured during the test call\n   */\n  PreflightTest.prototype._getRTCStats = function () {\n    var firstMosSampleIdx = this._samples.findIndex(function (sample) {\n      return typeof sample.mos === 'number' && sample.mos > 0;\n    });\n    var samples = firstMosSampleIdx >= 0 ? this._samples.slice(firstMosSampleIdx) : [];\n    if (!samples || !samples.length) {\n      return;\n    }\n    return ['jitter', 'mos', 'rtt'].reduce(function (statObj, stat) {\n      var _a;\n      var values = samples.map(function (s) {\n        return s[stat];\n      });\n      return __assign(__assign({}, statObj), (_a = {}, _a[stat] = {\n        average: Number((values.reduce(function (total, value) {\n          return total + value;\n        }) / values.length).toPrecision(5)),\n        max: Math.max.apply(Math, values),\n        min: Math.min.apply(Math, values)\n      }, _a));\n    }, {});\n  };\n  /**\n   * Returns a MediaStream from a media file\n   */\n  PreflightTest.prototype._getStreamFromFile = function () {\n    var audioContext = this._options.audioContext;\n    if (!audioContext) {\n      throw new errors_1.NotSupportedError('Cannot fake input audio stream: AudioContext is not supported by this browser.');\n    }\n    var audioEl = new Audio(constants_1.COWBELL_AUDIO_URL);\n    audioEl.addEventListener('canplaythrough', function () {\n      return audioEl.play();\n    });\n    if (typeof audioEl.setAttribute === 'function') {\n      audioEl.setAttribute('crossorigin', 'anonymous');\n    }\n    var src = audioContext.createMediaElementSource(audioEl);\n    var dest = audioContext.createMediaStreamDestination();\n    src.connect(dest);\n    return dest.stream;\n  };\n  /**\n   * Initialize the device\n   */\n  PreflightTest.prototype._initDevice = function (token, options) {\n    var _this = this;\n    try {\n      this._device = new (options.deviceFactory || device_1.default)(token, {\n        codecPreferences: options.codecPreferences,\n        edge: options.edge,\n        fileInputStream: options.fileInputStream,\n        logLevel: options.logLevel,\n        preflight: true\n      });\n      this._device.once(device_1.default.EventName.Registered, function () {\n        _this._onDeviceRegistered();\n      });\n      this._device.once(device_1.default.EventName.Error, function (error) {\n        _this._onDeviceError(error);\n      });\n      this._device.register();\n    } catch (error) {\n      // We want to return before failing so the consumer can capture the event\n      setTimeout(function () {\n        _this._onFailed(error);\n      });\n      return;\n    }\n    this._signalingTimeoutTimer = setTimeout(function () {\n      _this._onDeviceError(new errors_1.SignalingErrors.ConnectionError('WebSocket Connection Timeout'));\n    }, options.signalingTimeoutMs);\n  };\n  /**\n   * Called on {@link Device} error event\n   * @param error\n   */\n  PreflightTest.prototype._onDeviceError = function (error) {\n    this._device.destroy();\n    this._onFailed(error);\n  };\n  /**\n   * Called on {@link Device} ready event\n   */\n  PreflightTest.prototype._onDeviceRegistered = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, audio, publisher;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            clearTimeout(this._echoTimer);\n            clearTimeout(this._signalingTimeoutTimer);\n            _a = this;\n            return [4 /*yield*/, this._device.connect({\n              rtcConfiguration: this._options.rtcConfiguration\n            })];\n          case 1:\n            _a._call = _b.sent();\n            this._networkTiming.signaling = {\n              start: Date.now()\n            };\n            this._setupCallHandlers(this._call);\n            this._edge = this._device.edge || undefined;\n            if (this._options.fakeMicInput) {\n              this._echoTimer = setTimeout(function () {\n                return _this._device.disconnectAll();\n              }, constants_1.ECHO_TEST_DURATION);\n              audio = this._device.audio;\n              if (audio) {\n                audio.disconnect(false);\n                audio.outgoing(false);\n              }\n            }\n            this._call.once('disconnect', function () {\n              _this._device.once(device_1.default.EventName.Unregistered, function () {\n                return _this._onUnregistered();\n              });\n              _this._device.destroy();\n            });\n            publisher = this._call['_publisher'];\n            publisher.on('error', function () {\n              if (!_this._hasInsightsErrored) {\n                _this._emitWarning('insights-connection-error', 'Received an error when attempting to connect to Insights gateway');\n              }\n              _this._hasInsightsErrored = true;\n            });\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Called when there is a fatal error\n   * @param error\n   */\n  PreflightTest.prototype._onFailed = function (error) {\n    clearTimeout(this._echoTimer);\n    clearTimeout(this._signalingTimeoutTimer);\n    this._releaseHandlers();\n    this._endTime = Date.now();\n    this._status = PreflightTest.Status.Failed;\n    this.emit(PreflightTest.Events.Failed, error);\n  };\n  /**\n   * Called when the device goes offline.\n   * This indicates that the test has been completed, but we won't know if it failed or not.\n   * The onError event will be the indicator whether the test failed.\n   */\n  PreflightTest.prototype._onUnregistered = function () {\n    var _this = this;\n    // We need to make sure we always execute preflight.on('completed') last\n    // as client SDK sometimes emits 'offline' event before emitting fatal errors.\n    setTimeout(function () {\n      if (_this._status === PreflightTest.Status.Failed) {\n        return;\n      }\n      clearTimeout(_this._echoTimer);\n      clearTimeout(_this._signalingTimeoutTimer);\n      _this._releaseHandlers();\n      _this._endTime = Date.now();\n      _this._status = PreflightTest.Status.Completed;\n      _this._report = _this._getReport();\n      _this.emit(PreflightTest.Events.Completed, _this._report);\n    }, 10);\n  };\n  /**\n   * Clean up all handlers for device and call\n   */\n  PreflightTest.prototype._releaseHandlers = function () {\n    [this._device, this._call].forEach(function (emitter) {\n      if (emitter) {\n        emitter.eventNames().forEach(function (name) {\n          return emitter.removeAllListeners(name);\n        });\n      }\n    });\n  };\n  /**\n   * Setup the event handlers for the {@link Call} of the test call\n   * @param call\n   */\n  PreflightTest.prototype._setupCallHandlers = function (call) {\n    var _this = this;\n    if (this._options.fakeMicInput) {\n      // When volume events start emitting, it means all audio outputs have been created.\n      // Let's mute them if we're using fake mic input.\n      call.once('volume', function () {\n        call['_mediaHandler'].outputs.forEach(function (output) {\n          return output.audio.muted = true;\n        });\n      });\n    }\n    call.on('warning', function (name, data) {\n      _this._emitWarning(name, 'Received an RTCWarning. See .rtcWarning for the RTCWarning', data);\n    });\n    call.once('accept', function () {\n      _this._callSid = call['_mediaHandler'].callSid;\n      _this._status = PreflightTest.Status.Connected;\n      _this.emit(PreflightTest.Events.Connected);\n    });\n    call.on('sample', function (sample) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!!this._latestSample) return [3 /*break*/, 2];\n              _a = this;\n              return [4 /*yield*/, (this._options.getRTCIceCandidateStatsReport || stats_1.getRTCIceCandidateStatsReport)(call['_mediaHandler'].version.pc)];\n            case 1:\n              _a._rtcIceCandidateStatsReport = _b.sent();\n              _b.label = 2;\n            case 2:\n              this._latestSample = sample;\n              this._samples.push(sample);\n              this.emit(PreflightTest.Events.Sample, sample);\n              return [2 /*return*/];\n          }\n        });\n      });\n    });\n    // TODO: Update the following once the SDK supports emitting these events\n    // Let's shim for now\n    [{\n      reportLabel: 'peerConnection',\n      type: 'pcconnection'\n    }, {\n      reportLabel: 'ice',\n      type: 'iceconnection'\n    }, {\n      reportLabel: 'dtls',\n      type: 'dtlstransport'\n    }, {\n      reportLabel: 'signaling',\n      type: 'signaling'\n    }].forEach(function (_a) {\n      var type = _a.type,\n        reportLabel = _a.reportLabel;\n      var handlerName = \"on\" + type + \"statechange\";\n      var originalHandler = call['_mediaHandler'][handlerName];\n      call['_mediaHandler'][handlerName] = function (state) {\n        var timing = _this._networkTiming[reportLabel] = _this._networkTiming[reportLabel] || {\n          start: 0\n        };\n        if (state === 'connecting' || state === 'checking') {\n          timing.start = Date.now();\n        } else if ((state === 'connected' || state === 'stable') && !timing.duration) {\n          timing.end = Date.now();\n          timing.duration = timing.end - timing.start;\n        }\n        originalHandler(state);\n      };\n    });\n  };\n  Object.defineProperty(PreflightTest.prototype, \"callSid\", {\n    /**\n     * The callsid generated for the test call.\n     */\n    get: function () {\n      return this._callSid;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PreflightTest.prototype, \"endTime\", {\n    /**\n     * A timestamp in milliseconds of when the test ended.\n     */\n    get: function () {\n      return this._endTime;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PreflightTest.prototype, \"latestSample\", {\n    /**\n     * The latest WebRTC sample collected.\n     */\n    get: function () {\n      return this._latestSample;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PreflightTest.prototype, \"report\", {\n    /**\n     * The report for this test.\n     */\n    get: function () {\n      return this._report;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PreflightTest.prototype, \"startTime\", {\n    /**\n     * A timestamp in milliseconds of when the test started.\n     */\n    get: function () {\n      return this._startTime;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(PreflightTest.prototype, \"status\", {\n    /**\n     * The status of the test.\n     */\n    get: function () {\n      return this._status;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return PreflightTest;\n}(events_1.EventEmitter);\nexports.PreflightTest = PreflightTest;\n(function (PreflightTest) {\n  /**\n   * The quality of the call determined by different mos ranges.\n   * Mos is calculated base on the WebRTC stats - rtt, jitter, and packet lost.\n   */\n  var CallQuality;\n  (function (CallQuality) {\n    /**\n     * If the average mos is over 4.2.\n     */\n    CallQuality[\"Excellent\"] = \"excellent\";\n    /**\n     * If the average mos is between 4.1 and 4.2 both inclusive.\n     */\n    CallQuality[\"Great\"] = \"great\";\n    /**\n     * If the average mos is between 3.7 and 4.0 both inclusive.\n     */\n    CallQuality[\"Good\"] = \"good\";\n    /**\n     * If the average mos is between 3.1 and 3.6 both inclusive.\n     */\n    CallQuality[\"Fair\"] = \"fair\";\n    /**\n     * If the average mos is 3.0 or below.\n     */\n    CallQuality[\"Degraded\"] = \"degraded\";\n  })(CallQuality = PreflightTest.CallQuality || (PreflightTest.CallQuality = {}));\n  /**\n   * Possible events that a [[PreflightTest]] might emit.\n   */\n  var Events;\n  (function (Events) {\n    /**\n     * See [[PreflightTest.completedEvent]]\n     */\n    Events[\"Completed\"] = \"completed\";\n    /**\n     * See [[PreflightTest.connectedEvent]]\n     */\n    Events[\"Connected\"] = \"connected\";\n    /**\n     * See [[PreflightTest.failedEvent]]\n     */\n    Events[\"Failed\"] = \"failed\";\n    /**\n     * See [[PreflightTest.sampleEvent]]\n     */\n    Events[\"Sample\"] = \"sample\";\n    /**\n     * See [[PreflightTest.warningEvent]]\n     */\n    Events[\"Warning\"] = \"warning\";\n  })(Events = PreflightTest.Events || (PreflightTest.Events = {}));\n  /**\n   * Possible status of the test.\n   */\n  var Status;\n  (function (Status) {\n    /**\n     * Call to Twilio has initiated.\n     */\n    Status[\"Connecting\"] = \"connecting\";\n    /**\n     * Call to Twilio has been established.\n     */\n    Status[\"Connected\"] = \"connected\";\n    /**\n     * The connection to Twilio has been disconnected and the test call has completed.\n     */\n    Status[\"Completed\"] = \"completed\";\n    /**\n     * The test has stopped and failed.\n     */\n    Status[\"Failed\"] = \"failed\";\n  })(Status = PreflightTest.Status || (PreflightTest.Status = {}));\n})(PreflightTest = exports.PreflightTest || (exports.PreflightTest = {}));\nexports.PreflightTest = PreflightTest;","map":{"version":3,"names":["events_1","require","call_1","device_1","errors_1","stats_1","constants_1","PreflightTest","_super","__extends","token","options","_this","call","_hasInsightsErrored","_networkTiming","_options","codecPreferences","default","Codec","PCMU","Opus","edge","fakeMicInput","logLevel","signalingTimeoutMs","_status","Status","Connecting","Object","assign","_samples","_warnings","_startTime","Date","now","_initDevice","__assign","fileInputStream","_getStreamFromFile","undefined","prototype","stop","error","GeneralErrors","CallCancelledError","_device","once","EventName","Unregistered","_onFailed","destroy","_emitWarning","name","description","rtcWarning","warning","push","emit","Events","Warning","_getCallQuality","mos","CallQuality","Excellent","Great","Good","Fair","Degraded","_getReport","stats","_getRTCStats","testTiming","start","_endTime","end","duration","report","callSid","_callSid","_edge","iceCandidateStats","_rtcIceCandidateStatsReport","networkTiming","samples","selectedEdge","totals","_getRTCSampleTotals","warnings","selectedIceCandidatePairStats","isTurnRequired","localCandidate","candidateType","remoteCandidate","callQuality","average","_latestSample","firstMosSampleIdx","findIndex","sample","slice","length","reduce","statObj","stat","values","map","s","_a","Number","total","value","toPrecision","max","Math","apply","min","audioContext","NotSupportedError","audioEl","Audio","COWBELL_AUDIO_URL","addEventListener","play","setAttribute","src","createMediaElementSource","dest","createMediaStreamDestination","connect","stream","deviceFactory","preflight","Registered","_onDeviceRegistered","Error","_onDeviceError","register","setTimeout","_signalingTimeoutTimer","SignalingErrors","ConnectionError","clearTimeout","_echoTimer","rtcConfiguration","_call","_b","sent","signaling","_setupCallHandlers","disconnectAll","ECHO_TEST_DURATION","audio","disconnect","outgoing","_onUnregistered","publisher","on","_releaseHandlers","Failed","Completed","_report","forEach","emitter","eventNames","removeAllListeners","outputs","output","muted","data","Connected","__awaiter","getRTCIceCandidateStatsReport","version","pc","Sample","reportLabel","type","handlerName","originalHandler","state","timing","defineProperty","get","EventEmitter","exports"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/@twilio/voice-sdk/lib/twilio/preflight/preflight.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @preferred\n * @publicapi\n */\nimport { EventEmitter } from 'events';\nimport Call from '../call';\nimport Device, { IExtendedDeviceOptions } from '../device';\nimport {\n  GeneralErrors,\n  NotSupportedError,\n  SignalingErrors,\n  TwilioError,\n} from '../errors';\nimport { RTCSampleTotals } from '../rtc/sample';\nimport RTCSample from '../rtc/sample';\nimport { getRTCIceCandidateStatsReport } from '../rtc/stats';\nimport RTCWarning from '../rtc/warning';\nimport StatsMonitor from '../statsMonitor';\nimport { NetworkTiming, TimeMeasurement } from './timing';\n\nimport { COWBELL_AUDIO_URL, ECHO_TEST_DURATION } from '../constants';\n\n/**\n * Placeholder until we convert peerconnection.js to TypeScript.\n * Represents the audio output object coming from Client SDK's PeerConnection object.\n * @internalapi\n */\nexport interface AudioOutput {\n  /**\n   * The audio element used to play out the sound.\n   */\n  audio: HTMLAudioElement;\n}\n\nexport declare interface PreflightTest {\n  /**\n   * Raised when [[PreflightTest.status]] has transitioned to [[PreflightTest.Status.Completed]].\n   * During this time, [[PreflightTest.report]] is available and ready to be inspected.\n   * In some cases, this will not trigger if the test encounters a fatal error prior connecting to Twilio.\n   * See [[PreflightTest.failedEvent]].\n   * @param report\n   * @example `preflight.on('completed', report => console.log(report))`\n   * @event\n   */\n  completedEvent(report: PreflightTest.Report): void;\n\n  /**\n   * Raised when [[PreflightTest.status]] has transitioned to [[PreflightTest.Status.Connected]].\n   * @example `preflight.on('connected', () => console.log('Test connected'))`\n   * @event\n   */\n  connectedEvent(): void;\n\n  /**\n   * Raised when [[PreflightTest.status]] has transitioned to [[PreflightTest.Status.Failed]].\n   * This happens when establishing a connection to Twilio has failed or when a test call has encountered a fatal error.\n   * This is also raised if [[PreflightTest.stop]] is called while the test is in progress.\n   * @param error\n   * @example `preflight.on('failed', error => console.log(error))`\n   * @event\n   */\n  failedEvent(error: TwilioError | DOMException): void;\n\n  /**\n   * Raised when the [[Call]] gets a webrtc sample object. This event is published every second.\n   * @param sample\n   * @example `preflight.on('sample', sample => console.log(sample))`\n   * @event\n   */\n  sampleEvent(sample: RTCSample): void;\n\n  /**\n   * Raised whenever the [[Call]] encounters a warning.\n   * @param name - The name of the warning.\n   * @example `preflight.on('warning', (name, data) => console.log({ name, data }))`\n   * @event\n   */\n  warningEvent(name: string, data: PreflightTest.Warning): void;\n}\n\n/**\n * Runs some tests to identify issues, if any, prohibiting successful calling.\n */\nexport class PreflightTest extends EventEmitter {\n  /**\n   * The {@link Call} for this test call\n   */\n  private _call: Call;\n\n  /**\n   * Callsid generated for this test call\n   */\n  private _callSid: string | undefined;\n\n  /**\n   * The {@link Device} for this test call\n   */\n  private _device: Device;\n\n  /**\n   * The timer when doing an echo test\n   * The echo test is used when fakeMicInput is set to true\n   */\n  private _echoTimer: NodeJS.Timer;\n\n  /**\n   * The edge that the `Twilio.Device` connected to.\n   */\n  private _edge: string | undefined;\n\n  /**\n   * End of test timestamp\n   */\n  private _endTime: number | undefined;\n\n  /**\n   * Whether this test has already logged an insights-connection-warning.\n   */\n  private _hasInsightsErrored: boolean = false;\n\n  /**\n   * Latest WebRTC sample collected for this test\n   */\n  private _latestSample: RTCSample | undefined;\n\n  /**\n   * Network related timing measurements for this test\n   */\n  private _networkTiming: NetworkTiming = {};\n\n  /**\n   * The options passed to {@link PreflightTest} constructor\n   */\n  private _options: PreflightTest.ExtendedOptions = {\n    codecPreferences: [Call.Codec.PCMU, Call.Codec.Opus],\n    edge: 'roaming',\n    fakeMicInput: false,\n    logLevel: 'error',\n    signalingTimeoutMs: 10000,\n  };\n\n  /**\n   * The report for this test.\n   */\n  private _report: PreflightTest.Report | undefined;\n\n  /**\n   * The WebRTC ICE candidates stats information collected during the test\n   */\n  private _rtcIceCandidateStatsReport: PreflightTest.RTCIceCandidateStatsReport;\n\n  /**\n   * WebRTC samples collected during this test\n   */\n  private _samples: RTCSample[];\n\n  /**\n   * Timer for setting up signaling connection\n   */\n  private _signalingTimeoutTimer: number;\n\n  /**\n   * Start of test timestamp\n   */\n  private _startTime: number;\n\n  /**\n   * Current status of this test\n   */\n  private _status: PreflightTest.Status = PreflightTest.Status.Connecting;\n\n  /**\n   * List of warning names and warning data detected during this test\n   */\n  private _warnings: PreflightTest.Warning[];\n\n  /**\n   * Construct a {@link PreflightTest} instance.\n   * @constructor\n   * @param token - A Twilio JWT token string.\n   * @param options\n   */\n  constructor(token: string, options: PreflightTest.ExtendedOptions) {\n    super();\n\n    Object.assign(this._options, options);\n\n    this._samples = [];\n    this._warnings = [];\n    this._startTime = Date.now();\n\n    this._initDevice(token, {\n      ...this._options,\n      fileInputStream: this._options.fakeMicInput ?\n        this._getStreamFromFile() : undefined,\n    });\n  }\n\n  /**\n   * Stops the current test and raises a failed event.\n   */\n  stop(): void {\n    const error = new GeneralErrors.CallCancelledError();\n    if (this._device) {\n      this._device.once(Device.EventName.Unregistered, () => this._onFailed(error));\n      this._device.destroy();\n    } else {\n      this._onFailed(error);\n    }\n  }\n\n  /**\n   * Emit a {PreflightTest.Warning}\n   */\n  private _emitWarning(name: string, description: string, rtcWarning?: RTCWarning): void {\n    const warning: PreflightTest.Warning = { name, description };\n    if (rtcWarning) {\n      warning.rtcWarning = rtcWarning;\n    }\n    this._warnings.push(warning);\n    this.emit(PreflightTest.Events.Warning, warning);\n  }\n\n  /**\n   * Returns call quality base on the RTC Stats\n   */\n  private _getCallQuality(mos: number): PreflightTest.CallQuality {\n    if (mos > 4.2) {\n      return PreflightTest.CallQuality.Excellent;\n    } else if (mos >= 4.1 && mos <= 4.2) {\n      return PreflightTest.CallQuality.Great;\n    } else if (mos >= 3.7 && mos <= 4) {\n      return PreflightTest.CallQuality.Good;\n    } else if (mos >= 3.1 && mos <= 3.6) {\n      return PreflightTest.CallQuality.Fair;\n    } else {\n      return PreflightTest.CallQuality.Degraded;\n    }\n  }\n\n  /**\n   * Returns the report for this test.\n   */\n  private _getReport(): PreflightTest.Report {\n    const stats = this._getRTCStats();\n    const testTiming: TimeMeasurement = { start: this._startTime };\n    if (this._endTime) {\n      testTiming.end = this._endTime;\n      testTiming.duration  = this._endTime - this._startTime;\n    }\n\n    const report: PreflightTest.Report = {\n      callSid: this._callSid,\n      edge: this._edge,\n      iceCandidateStats: this._rtcIceCandidateStatsReport.iceCandidateStats,\n      networkTiming: this._networkTiming,\n      samples: this._samples,\n      selectedEdge: this._options.edge,\n      stats,\n      testTiming,\n      totals: this._getRTCSampleTotals(),\n      warnings: this._warnings,\n    };\n\n    const selectedIceCandidatePairStats = this._rtcIceCandidateStatsReport.selectedIceCandidatePairStats;\n\n    if (selectedIceCandidatePairStats) {\n      report.selectedIceCandidatePairStats = selectedIceCandidatePairStats;\n      report.isTurnRequired = selectedIceCandidatePairStats.localCandidate.candidateType === 'relay'\n      || selectedIceCandidatePairStats.remoteCandidate.candidateType === 'relay';\n    }\n\n    if (stats) {\n      report.callQuality = this._getCallQuality(stats.mos.average);\n    }\n\n    return report;\n  }\n\n  /**\n   * Returns RTC stats totals for this test\n   */\n  private _getRTCSampleTotals(): RTCSampleTotals | undefined {\n    if (!this._latestSample) {\n      return;\n    }\n\n    return { ...this._latestSample.totals };\n  }\n\n  /**\n   * Returns RTC related stats captured during the test call\n   */\n  private _getRTCStats(): PreflightTest.RTCStats | undefined {\n    const firstMosSampleIdx = this._samples.findIndex(\n      sample => typeof sample.mos === 'number' && sample.mos > 0,\n    );\n\n    const samples = firstMosSampleIdx >= 0\n      ? this._samples.slice(firstMosSampleIdx)\n      : [];\n\n    if (!samples || !samples.length) {\n      return;\n    }\n\n    return ['jitter', 'mos', 'rtt'].reduce((statObj, stat) => {\n      const values = samples.map(s => s[stat]);\n      return {\n        ...statObj,\n        [stat]: {\n          average: Number((values.reduce((total, value) => total + value) / values.length).toPrecision(5)),\n          max: Math.max(...values),\n          min: Math.min(...values),\n        },\n      };\n    }, {} as any);\n  }\n\n  /**\n   * Returns a MediaStream from a media file\n   */\n  private _getStreamFromFile(): MediaStream {\n    const audioContext = this._options.audioContext;\n    if (!audioContext) {\n      throw new NotSupportedError('Cannot fake input audio stream: AudioContext is not supported by this browser.');\n    }\n\n    const audioEl: any = new Audio(COWBELL_AUDIO_URL);\n\n    audioEl.addEventListener('canplaythrough', () => audioEl.play());\n    if (typeof audioEl.setAttribute === 'function') {\n      audioEl.setAttribute('crossorigin', 'anonymous');\n    }\n\n    const src = audioContext.createMediaElementSource(audioEl);\n    const dest = audioContext.createMediaStreamDestination();\n    src.connect(dest);\n\n    return dest.stream;\n  }\n\n  /**\n   * Initialize the device\n   */\n  private _initDevice(token: string, options: PreflightTest.ExtendedOptions): void {\n    try {\n      this._device = new (options.deviceFactory || Device)(token, {\n        codecPreferences: options.codecPreferences,\n        edge: options.edge,\n        fileInputStream: options.fileInputStream,\n        logLevel: options.logLevel,\n        preflight: true,\n      } as IExtendedDeviceOptions);\n\n      this._device.once(Device.EventName.Registered, () => {\n        this._onDeviceRegistered();\n      });\n\n      this._device.once(Device.EventName.Error, (error: TwilioError) => {\n        this._onDeviceError(error);\n      });\n\n      this._device.register();\n    } catch (error) {\n      // We want to return before failing so the consumer can capture the event\n      setTimeout(() => {\n        this._onFailed(error);\n      });\n      return;\n    }\n\n    this._signalingTimeoutTimer = setTimeout(() => {\n      this._onDeviceError(new SignalingErrors.ConnectionError('WebSocket Connection Timeout'));\n    }, options.signalingTimeoutMs);\n  }\n\n  /**\n   * Called on {@link Device} error event\n   * @param error\n   */\n  private _onDeviceError(error: TwilioError): void {\n    this._device.destroy();\n    this._onFailed(error);\n  }\n\n  /**\n   * Called on {@link Device} ready event\n   */\n  private async _onDeviceRegistered(): Promise<void> {\n    clearTimeout(this._echoTimer);\n    clearTimeout(this._signalingTimeoutTimer);\n\n    this._call = await this._device.connect({\n      rtcConfiguration: this._options.rtcConfiguration,\n    });\n    this._networkTiming.signaling = { start: Date.now() };\n    this._setupCallHandlers(this._call);\n\n    this._edge = this._device.edge || undefined;\n    if (this._options.fakeMicInput) {\n      this._echoTimer = setTimeout(() => this._device.disconnectAll(), ECHO_TEST_DURATION);\n\n      const audio = this._device.audio as any;\n      if (audio) {\n        audio.disconnect(false);\n        audio.outgoing(false);\n      }\n    }\n\n    this._call.once('disconnect', () => {\n      this._device.once(Device.EventName.Unregistered, () => this._onUnregistered());\n      this._device.destroy();\n    });\n\n    const publisher = this._call['_publisher'] as any;\n    publisher.on('error', () => {\n      if (!this._hasInsightsErrored) {\n        this._emitWarning('insights-connection-error',\n          'Received an error when attempting to connect to Insights gateway');\n      }\n      this._hasInsightsErrored = true;\n    });\n  }\n\n  /**\n   * Called when there is a fatal error\n   * @param error\n   */\n  private _onFailed(error: TwilioError | DOMException): void {\n    clearTimeout(this._echoTimer);\n    clearTimeout(this._signalingTimeoutTimer);\n    this._releaseHandlers();\n    this._endTime = Date.now();\n    this._status = PreflightTest.Status.Failed;\n    this.emit(PreflightTest.Events.Failed, error);\n  }\n\n  /**\n   * Called when the device goes offline.\n   * This indicates that the test has been completed, but we won't know if it failed or not.\n   * The onError event will be the indicator whether the test failed.\n   */\n  private _onUnregistered(): void {\n    // We need to make sure we always execute preflight.on('completed') last\n    // as client SDK sometimes emits 'offline' event before emitting fatal errors.\n    setTimeout(() => {\n      if (this._status === PreflightTest.Status.Failed) {\n        return;\n      }\n\n      clearTimeout(this._echoTimer);\n      clearTimeout(this._signalingTimeoutTimer);\n\n      this._releaseHandlers();\n      this._endTime = Date.now();\n      this._status = PreflightTest.Status.Completed;\n      this._report = this._getReport();\n      this.emit(PreflightTest.Events.Completed, this._report);\n    }, 10);\n  }\n\n  /**\n   * Clean up all handlers for device and call\n   */\n  private _releaseHandlers(): void {\n    [this._device, this._call].forEach((emitter: EventEmitter) => {\n      if (emitter) {\n        emitter.eventNames().forEach((name: string) => emitter.removeAllListeners(name));\n      }\n    });\n  }\n\n  /**\n   * Setup the event handlers for the {@link Call} of the test call\n   * @param call\n   */\n  private _setupCallHandlers(call: Call): void {\n    if (this._options.fakeMicInput) {\n      // When volume events start emitting, it means all audio outputs have been created.\n      // Let's mute them if we're using fake mic input.\n      call.once('volume', () => {\n        call['_mediaHandler'].outputs\n          .forEach((output: AudioOutput) => output.audio.muted = true);\n      });\n    }\n\n    call.on('warning', (name: string, data: RTCWarning) => {\n      this._emitWarning(name, 'Received an RTCWarning. See .rtcWarning for the RTCWarning', data);\n    });\n\n    call.once('accept', () => {\n      this._callSid = call['_mediaHandler'].callSid;\n      this._status = PreflightTest.Status.Connected;\n      this.emit(PreflightTest.Events.Connected);\n    });\n\n    call.on('sample', async (sample) => {\n      // RTC Stats are ready. We only need to get ICE candidate stats report once.\n      if (!this._latestSample) {\n        this._rtcIceCandidateStatsReport = await (\n          this._options.getRTCIceCandidateStatsReport || getRTCIceCandidateStatsReport\n        )(call['_mediaHandler'].version.pc);\n      }\n\n      this._latestSample = sample;\n      this._samples.push(sample);\n      this.emit(PreflightTest.Events.Sample, sample);\n    });\n\n    // TODO: Update the following once the SDK supports emitting these events\n    // Let's shim for now\n    [{\n      reportLabel: 'peerConnection',\n      type: 'pcconnection',\n     }, {\n      reportLabel: 'ice',\n      type: 'iceconnection',\n     }, {\n      reportLabel: 'dtls',\n      type: 'dtlstransport',\n     }, {\n      reportLabel: 'signaling',\n      type: 'signaling',\n     }].forEach(({type, reportLabel}) => {\n\n      const handlerName = `on${type}statechange`;\n      const originalHandler = call['_mediaHandler'][handlerName];\n\n      call['_mediaHandler'][handlerName] = (state: string) => {\n        const timing = (this._networkTiming as any)[reportLabel]\n          = (this._networkTiming as any)[reportLabel] || { start: 0 };\n\n        if (state === 'connecting' || state === 'checking') {\n          timing.start = Date.now();\n        } else if ((state === 'connected' || state === 'stable') && !timing.duration) {\n          timing.end = Date.now();\n          timing.duration = timing.end - timing.start;\n        }\n\n        originalHandler(state);\n      };\n    });\n  }\n\n  /**\n   * The callsid generated for the test call.\n   */\n  get callSid(): string | undefined {\n    return this._callSid;\n  }\n\n  /**\n   * A timestamp in milliseconds of when the test ended.\n   */\n  get endTime(): number | undefined {\n    return this._endTime;\n  }\n\n  /**\n   * The latest WebRTC sample collected.\n   */\n  get latestSample(): RTCSample | undefined {\n    return this._latestSample;\n  }\n\n  /**\n   * The report for this test.\n   */\n  get report(): PreflightTest.Report | undefined {\n    return this._report;\n  }\n\n  /**\n   * A timestamp in milliseconds of when the test started.\n   */\n  get startTime(): number {\n    return this._startTime;\n  }\n\n  /**\n   * The status of the test.\n   */\n  get status(): PreflightTest.Status {\n    return this._status;\n  }\n}\n\nexport namespace PreflightTest {\n  /**\n   * The quality of the call determined by different mos ranges.\n   * Mos is calculated base on the WebRTC stats - rtt, jitter, and packet lost.\n   */\n  export enum CallQuality {\n    /**\n     * If the average mos is over 4.2.\n     */\n    Excellent = 'excellent',\n\n    /**\n     * If the average mos is between 4.1 and 4.2 both inclusive.\n     */\n    Great = 'great',\n\n    /**\n     * If the average mos is between 3.7 and 4.0 both inclusive.\n     */\n    Good = 'good',\n\n    /**\n     * If the average mos is between 3.1 and 3.6 both inclusive.\n     */\n    Fair = 'fair',\n\n    /**\n     * If the average mos is 3.0 or below.\n     */\n    Degraded = 'degraded',\n  }\n\n  /**\n   * Possible events that a [[PreflightTest]] might emit.\n   */\n  export enum Events {\n    /**\n     * See [[PreflightTest.completedEvent]]\n     */\n    Completed = 'completed',\n\n    /**\n     * See [[PreflightTest.connectedEvent]]\n     */\n    Connected = 'connected',\n\n    /**\n     * See [[PreflightTest.failedEvent]]\n     */\n    Failed = 'failed',\n\n    /**\n     * See [[PreflightTest.sampleEvent]]\n     */\n    Sample = 'sample',\n\n    /**\n     * See [[PreflightTest.warningEvent]]\n     */\n    Warning = 'warning',\n  }\n\n  /**\n   * Possible status of the test.\n   */\n  export enum Status {\n    /**\n     * Call to Twilio has initiated.\n     */\n    Connecting = 'connecting',\n\n    /**\n     * Call to Twilio has been established.\n     */\n    Connected = 'connected',\n\n    /**\n     * The connection to Twilio has been disconnected and the test call has completed.\n     */\n    Completed = 'completed',\n\n    /**\n     * The test has stopped and failed.\n     */\n    Failed = 'failed',\n  }\n\n  /**\n   * The WebRTC API's [RTCIceCandidateStats](https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidateStats)\n   * dictionary which provides information related to an ICE candidate.\n   */\n  export type RTCIceCandidateStats = any;\n\n  /**\n   * Options that may be passed to {@link PreflightTest} constructor for internal testing.\n   * @internalapi\n   */\n  export interface ExtendedOptions extends Options {\n    /**\n     * The AudioContext instance to use\n     */\n    audioContext?: AudioContext;\n\n    /**\n     * Device class to use.\n     */\n    deviceFactory?: typeof Device;\n\n    /**\n     * File input stream to use instead of reading from mic\n     */\n    fileInputStream?: MediaStream;\n\n    /**\n     * The getRTCIceCandidateStatsReport to use for testing.\n     */\n    getRTCIceCandidateStatsReport?: Function;\n\n    /**\n     * An RTCConfiguration to pass to the RTCPeerConnection constructor.\n     */\n    rtcConfiguration?: RTCConfiguration;\n  }\n\n  /**\n   * A WebRTC stats report containing relevant information about selected and gathered ICE candidates\n   */\n  export interface RTCIceCandidateStatsReport {\n    /**\n     * An array of WebRTC stats for the ICE candidates gathered when connecting to media.\n     */\n    iceCandidateStats: RTCIceCandidateStats[];\n\n    /**\n     * A WebRTC stats for the ICE candidate pair used to connect to media, if candidates were selected.\n     */\n    selectedIceCandidatePairStats?: RTCSelectedIceCandidatePairStats;\n  }\n\n  /**\n   * Options passed to {@link PreflightTest} constructor.\n   */\n  export interface Options {\n    /**\n     * An ordered array of codec names that will be used during the test call,\n     * from most to least preferred.\n     * @default ['pcmu','opus']\n     */\n    codecPreferences?: Call.Codec[];\n\n    /**\n     * Specifies which Twilio Data Center to use when initiating the test call.\n     * Please see this\n     * [page](https://www.twilio.com/docs/voice/client/edges)\n     * for the list of available edges.\n     * @default roaming\n     */\n    edge?: string;\n\n    /**\n     * If set to `true`, the test call will ignore microphone input and will use a default audio file.\n     * If set to `false`, the test call will capture the audio from the microphone.\n     * Setting this to `true` is only supported on Chrome and will throw a fatal error on other browsers\n     * @default false\n     */\n    fakeMicInput?: boolean;\n\n    /**\n     * An array of custom ICE servers to use to connect media. If you provide both STUN and TURN server configurations,\n     * the test will detect whether a TURN server is required to establish a connection.\n     *\n     * The following example demonstrates how to use [Twilio's Network Traversal Service](https://www.twilio.com/stun-turn)\n     * to generate STUN/TURN credentials and how to specify a specific [edge location](https://www.twilio.com/docs/global-infrastructure/edge-locations).\n     *\n     * ```ts\n     * import Client from 'twilio';\n     * import { Device } from 'twilio-client';\n     *\n     * // Generate the STUN and TURN server credentials with a ttl of 120 seconds\n     * const client = Client(twilioAccountSid, authToken);\n     * const token = await client.tokens.create({ ttl: 120 });\n     *\n     * let iceServers = token.iceServers;\n     *\n     * // By default, global will be used as the default edge location.\n     * // You can replace global with a specific edge name for each of the iceServer configuration.\n     * iceServers = iceServers.map(config => {\n     *   let { url, urls, ...rest } = config;\n     *   url = url.replace('global', 'ashburn');\n     *   urls = urls.replace('global', 'ashburn');\n     *\n     *   return { url, urls, ...rest };\n     * });\n     *\n     * // Use the TURN credentials using the iceServers parameter\n     * const preflightTest = Device.runPreflight(token, { iceServers });\n     *\n     * // Read from the report object to determine whether TURN is required to connect to media\n     * preflightTest.on('completed', (report) => {\n     *   console.log(report.isTurnRequired);\n     * });\n     * ```\n     *\n     * @default null\n     */\n    iceServers?: RTCIceServer[];\n\n    /**\n     * Log level to use in the Device.\n     * @default 'error'\n     */\n    logLevel?: string;\n\n    /**\n     * Amount of time to wait for setting up signaling connection.\n     * @default 10000\n     */\n    signalingTimeoutMs?: number;\n  }\n\n  /**\n   * Represents the WebRTC stats for the ICE candidate pair used to connect to media, if candidates were selected.\n   */\n  export interface RTCSelectedIceCandidatePairStats {\n    /**\n     * An [RTCIceCandidateStats](https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidateStats)\n     * object which provides information related to the selected local ICE candidate.\n     */\n    localCandidate: RTCIceCandidateStats;\n\n    /**\n     * An [RTCIceCandidateStats](https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidateStats)\n     * object which provides information related to the selected remote ICE candidate.\n     */\n    remoteCandidate: RTCIceCandidateStats;\n  }\n\n  /**\n   * Represents RTC related stats that are extracted from RTC samples.\n   */\n  export interface RTCStats {\n    /**\n     * Packets delay variation.\n     */\n    jitter: Stats;\n\n    /**\n     * Mean opinion score, 1.0 through roughly 4.5.\n     */\n    mos: Stats;\n\n    /**\n     * Round trip time, to the server back to the client.\n     */\n    rtt: Stats;\n  }\n\n  /**\n   * Represents general stats for a specific metric.\n   */\n  export interface Stats {\n    /**\n     * The average value for this metric.\n     */\n    average: number;\n\n    /**\n     * The maximum value for this metric.\n     */\n    max: number;\n\n    /**\n     * The minimum value for this metric.\n     */\n    min: number;\n  }\n\n  /**\n   * Represents the report generated from a {@link PreflightTest}.\n   */\n  export interface Report {\n    /**\n     * The quality of the call determined by different mos ranges.\n     */\n    callQuality?: CallQuality;\n\n    /**\n     * CallSid generaged during the test.\n     */\n    callSid: string | undefined;\n\n    /**\n     * The edge that the test call was connected to.\n     */\n    edge?: string;\n\n    /**\n     * An array of WebRTC stats for the ICE candidates gathered when connecting to media.\n     */\n    iceCandidateStats: RTCIceCandidateStats[];\n\n    /**\n     * Whether a TURN server is required to connect to media.\n     * This is dependent on the selected ICE candidates, and will be true if either is of type \"relay\",\n     * false if both are of another type, or undefined if there are no selected ICE candidates.\n     * See `PreflightTest.Options.iceServers` for more details.\n     */\n    isTurnRequired?: boolean;\n\n    /**\n     * Network related time measurements.\n     */\n    networkTiming: NetworkTiming;\n\n    /**\n     * WebRTC samples collected during the test.\n     */\n    samples: RTCSample[];\n\n    /**\n     * The edge passed to `Device.runPreflight`.\n     */\n    selectedEdge?: string;\n\n    /**\n     * A WebRTC stats for the ICE candidate pair used to connect to media, if candidates were selected.\n     */\n    selectedIceCandidatePairStats?: RTCSelectedIceCandidatePairStats;\n\n    /**\n     * RTC related stats captured during the test.\n     */\n    stats?: RTCStats;\n\n    /**\n     * Time measurements of test run time.\n     */\n    testTiming: TimeMeasurement;\n\n    /**\n     * Calculated totals in RTC statistics samples.\n     */\n    totals?: RTCSampleTotals;\n\n    /**\n     * List of warning names and warning data detected during this test.\n     */\n    warnings: PreflightTest.Warning[];\n  }\n\n  /**\n   * A warning that can be raised by Preflight, and returned in the Report.warnings field.\n   */\n  export interface Warning {\n    /**\n     * Description of the Warning\n     */\n    description: string;\n    /**\n     * Name of the Warning\n     */\n    name: string;\n    /**\n     * If applicable, the RTCWarning that triggered this warning.\n     */\n    rtcWarning?: RTCWarning;\n  }\n }\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}