{"ast":null,"code":"var EventTarget = require('./eventtarget');\nvar inherits = require('util').inherits;\nvar POLL_INTERVAL_MS = 500;\nvar nativeMediaDevices = typeof navigator !== 'undefined' && navigator.mediaDevices;\n/**\n * Make a custom MediaDevices object, and proxy through existing functionality. If\n *   devicechange is present, we simply reemit the event. If not, we will do the\n *   detection ourselves and fire the event when necessary. The same logic exists\n *   for deviceinfochange for consistency, however deviceinfochange is our own event\n *   so it is unlikely that it will ever be native. The w3c spec for devicechange\n *   is unclear as to whether MediaDeviceInfo changes (such as label) will\n *   trigger the devicechange event. We have an open question on this here:\n *   https://bugs.chromium.org/p/chromium/issues/detail?id=585096\n */\nfunction MediaDevicesShim() {\n  EventTarget.call(this);\n  this._defineEventHandler('devicechange');\n  this._defineEventHandler('deviceinfochange');\n  var knownDevices = [];\n  Object.defineProperties(this, {\n    _deviceChangeIsNative: {\n      value: reemitNativeEvent(this, 'devicechange')\n    },\n    _deviceInfoChangeIsNative: {\n      value: reemitNativeEvent(this, 'deviceinfochange')\n    },\n    _knownDevices: {\n      value: knownDevices\n    },\n    _pollInterval: {\n      value: null,\n      writable: true\n    }\n  });\n  if (typeof nativeMediaDevices.enumerateDevices === 'function') {\n    nativeMediaDevices.enumerateDevices().then(function (devices) {\n      devices.sort(sortDevicesById).forEach([].push, knownDevices);\n    });\n  }\n  this._eventEmitter.on('newListener', function maybeStartPolling(eventName) {\n    if (eventName !== 'devicechange' && eventName !== 'deviceinfochange') {\n      return;\n    }\n    this._pollInterval = this._pollInterval || setInterval(sampleDevices.bind(null, this), POLL_INTERVAL_MS);\n  }.bind(this));\n  this._eventEmitter.on('removeListener', function maybeStopPolling() {\n    if (this._pollInterval && !hasChangeListeners(this)) {\n      clearInterval(this._pollInterval);\n      this._pollInterval = null;\n    }\n  }.bind(this));\n}\ninherits(MediaDevicesShim, EventTarget);\nif (nativeMediaDevices && typeof nativeMediaDevices.enumerateDevices === 'function') {\n  MediaDevicesShim.prototype.enumerateDevices = function enumerateDevices() {\n    return nativeMediaDevices.enumerateDevices.apply(nativeMediaDevices, arguments);\n  };\n}\nMediaDevicesShim.prototype.getUserMedia = function getUserMedia() {\n  return nativeMediaDevices.getUserMedia.apply(nativeMediaDevices, arguments);\n};\nfunction deviceInfosHaveChanged(newDevices, oldDevices) {\n  var oldLabels = oldDevices.reduce(function (map, device) {\n    return map.set(device.deviceId, device.label || null);\n  }, new Map());\n  return newDevices.some(function (newDevice) {\n    var oldLabel = oldLabels.get(newDevice.deviceId);\n    return typeof oldLabel !== 'undefined' && oldLabel !== newDevice.label;\n  });\n}\nfunction devicesHaveChanged(newDevices, oldDevices) {\n  return newDevices.length !== oldDevices.length || propertyHasChanged('deviceId', newDevices, oldDevices);\n}\nfunction hasChangeListeners(mediaDevices) {\n  return ['devicechange', 'deviceinfochange'].reduce(function (count, event) {\n    return count + mediaDevices._eventEmitter.listenerCount(event);\n  }, 0) > 0;\n}\n/**\n * Sample the current set of devices and emit devicechange event if a device has been\n *   added or removed, and deviceinfochange if a device's label has changed.\n * @param {MediaDevicesShim} mediaDevices\n * @private\n */\nfunction sampleDevices(mediaDevices) {\n  nativeMediaDevices.enumerateDevices().then(function (newDevices) {\n    var knownDevices = mediaDevices._knownDevices;\n    var oldDevices = knownDevices.slice();\n    // Replace known devices in-place\n    [].splice.apply(knownDevices, [0, knownDevices.length].concat(newDevices.sort(sortDevicesById)));\n    if (!mediaDevices._deviceChangeIsNative && devicesHaveChanged(knownDevices, oldDevices)) {\n      mediaDevices.dispatchEvent(new Event('devicechange'));\n    }\n    if (!mediaDevices._deviceInfoChangeIsNative && deviceInfosHaveChanged(knownDevices, oldDevices)) {\n      mediaDevices.dispatchEvent(new Event('deviceinfochange'));\n    }\n  });\n}\n/**\n * Accepts two sorted arrays and the name of a property to compare on objects from each.\n *   Arrays should also be of the same length.\n * @param {string} propertyName - Name of the property to compare on each object\n * @param {Array<Object>} as - The left-side array of objects to compare.\n * @param {Array<Object>} bs - The right-side array of objects to compare.\n * @private\n * @returns {boolean} True if the property of any object in array A is different than\n *   the same property of its corresponding object in array B.\n */\nfunction propertyHasChanged(propertyName, as, bs) {\n  return as.some(function (a, i) {\n    return a[propertyName] !== bs[i][propertyName];\n  });\n}\n/**\n * Re-emit the native event, if the native mediaDevices has the corresponding property.\n * @param {MediaDevicesShim} mediaDevices\n * @param {string} eventName - Name of the event\n * @private\n * @returns {boolean} Whether the native mediaDevice had the corresponding property\n */\nfunction reemitNativeEvent(mediaDevices, eventName) {\n  var methodName = \"on\" + eventName;\n  function dispatchEvent(event) {\n    mediaDevices.dispatchEvent(event);\n  }\n  if (methodName in nativeMediaDevices) {\n    // Use addEventListener if it's available so we don't stomp on any other listeners\n    // for this event. Currently, navigator.mediaDevices.addEventListener does not exist in Safari.\n    if ('addEventListener' in nativeMediaDevices) {\n      nativeMediaDevices.addEventListener(eventName, dispatchEvent);\n    } else {\n      nativeMediaDevices[methodName] = dispatchEvent;\n    }\n    return true;\n  }\n  return false;\n}\nfunction sortDevicesById(a, b) {\n  return a.deviceId < b.deviceId;\n}\nmodule.exports = function shimMediaDevices() {\n  return nativeMediaDevices ? new MediaDevicesShim() : null;\n}();","map":{"version":3,"names":["EventTarget","require","inherits","POLL_INTERVAL_MS","nativeMediaDevices","navigator","mediaDevices","MediaDevicesShim","call","_defineEventHandler","knownDevices","Object","defineProperties","_deviceChangeIsNative","value","reemitNativeEvent","_deviceInfoChangeIsNative","_knownDevices","_pollInterval","writable","enumerateDevices","then","devices","sort","sortDevicesById","forEach","push","_eventEmitter","on","maybeStartPolling","eventName","setInterval","sampleDevices","bind","maybeStopPolling","hasChangeListeners","clearInterval","prototype","apply","arguments","getUserMedia","deviceInfosHaveChanged","newDevices","oldDevices","oldLabels","reduce","map","device","set","deviceId","label","Map","some","newDevice","oldLabel","get","devicesHaveChanged","length","propertyHasChanged","count","event","listenerCount","slice","splice","concat","dispatchEvent","Event","propertyName","as","bs","a","i","methodName","addEventListener","b","module","exports","shimMediaDevices"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/twilio-client/lib/twilio/shims/mediadevices.js"],"sourcesContent":["const EventTarget = require('./eventtarget');\nconst inherits = require('util').inherits;\n\nconst POLL_INTERVAL_MS = 500;\n\nconst nativeMediaDevices = typeof navigator !== 'undefined' && navigator.mediaDevices;\n\n/**\n * Make a custom MediaDevices object, and proxy through existing functionality. If\n *   devicechange is present, we simply reemit the event. If not, we will do the\n *   detection ourselves and fire the event when necessary. The same logic exists\n *   for deviceinfochange for consistency, however deviceinfochange is our own event\n *   so it is unlikely that it will ever be native. The w3c spec for devicechange\n *   is unclear as to whether MediaDeviceInfo changes (such as label) will\n *   trigger the devicechange event. We have an open question on this here:\n *   https://bugs.chromium.org/p/chromium/issues/detail?id=585096\n */\nfunction MediaDevicesShim() {\n  EventTarget.call(this);\n\n  this._defineEventHandler('devicechange');\n  this._defineEventHandler('deviceinfochange');\n\n  const knownDevices = [];\n  Object.defineProperties(this, {\n    _deviceChangeIsNative: {\n      value: reemitNativeEvent(this, 'devicechange')\n    },\n    _deviceInfoChangeIsNative: {\n      value: reemitNativeEvent(this, 'deviceinfochange')\n    },\n    _knownDevices: {\n      value: knownDevices\n    },\n    _pollInterval: {\n      value: null,\n      writable: true\n    }\n  });\n\n  if (typeof nativeMediaDevices.enumerateDevices === 'function') {\n    nativeMediaDevices.enumerateDevices().then(devices => {\n      devices.sort(sortDevicesById).forEach([].push, knownDevices);\n    });\n  }\n\n  this._eventEmitter.on('newListener', function maybeStartPolling(eventName) {\n    if (eventName !== 'devicechange' && eventName !== 'deviceinfochange') {\n      return;\n    }\n\n    this._pollInterval = this._pollInterval\n      || setInterval(sampleDevices.bind(null, this), POLL_INTERVAL_MS);\n  }.bind(this));\n\n  this._eventEmitter.on('removeListener', function maybeStopPolling() {\n    if (this._pollInterval && !hasChangeListeners(this)) {\n      clearInterval(this._pollInterval);\n      this._pollInterval = null;\n    }\n  }.bind(this));\n}\n\ninherits(MediaDevicesShim, EventTarget);\n\nif (nativeMediaDevices && typeof nativeMediaDevices.enumerateDevices === 'function') {\n  MediaDevicesShim.prototype.enumerateDevices = function enumerateDevices() {\n    return nativeMediaDevices.enumerateDevices(...arguments);\n  };\n}\n\nMediaDevicesShim.prototype.getUserMedia = function getUserMedia() {\n  return nativeMediaDevices.getUserMedia(...arguments);\n};\n\nfunction deviceInfosHaveChanged(newDevices, oldDevices) {\n  const oldLabels = oldDevices.reduce((map, device) => map.set(device.deviceId, device.label || null), new Map());\n\n  return newDevices.some(newDevice => {\n    const oldLabel = oldLabels.get(newDevice.deviceId);\n    return typeof oldLabel !== 'undefined' && oldLabel !== newDevice.label;\n  });\n}\n\nfunction devicesHaveChanged(newDevices, oldDevices) {\n  return newDevices.length !== oldDevices.length\n    || propertyHasChanged('deviceId', newDevices, oldDevices);\n}\n\nfunction hasChangeListeners(mediaDevices) {\n  return ['devicechange', 'deviceinfochange'].reduce((count, event) => count + mediaDevices._eventEmitter.listenerCount(event), 0) > 0;\n}\n\n/**\n * Sample the current set of devices and emit devicechange event if a device has been\n *   added or removed, and deviceinfochange if a device's label has changed.\n * @param {MediaDevicesShim} mediaDevices\n * @private\n */\nfunction sampleDevices(mediaDevices) {\n  nativeMediaDevices.enumerateDevices().then(newDevices => {\n    const knownDevices = mediaDevices._knownDevices;\n    const oldDevices = knownDevices.slice();\n\n    // Replace known devices in-place\n    [].splice.apply(knownDevices, [0, knownDevices.length]\n      .concat(newDevices.sort(sortDevicesById)));\n\n    if (!mediaDevices._deviceChangeIsNative\n      && devicesHaveChanged(knownDevices, oldDevices)) {\n      mediaDevices.dispatchEvent(new Event('devicechange'));\n    }\n\n    if (!mediaDevices._deviceInfoChangeIsNative\n      && deviceInfosHaveChanged(knownDevices, oldDevices)) {\n      mediaDevices.dispatchEvent(new Event('deviceinfochange'));\n    }\n  });\n}\n\n/**\n * Accepts two sorted arrays and the name of a property to compare on objects from each.\n *   Arrays should also be of the same length.\n * @param {string} propertyName - Name of the property to compare on each object\n * @param {Array<Object>} as - The left-side array of objects to compare.\n * @param {Array<Object>} bs - The right-side array of objects to compare.\n * @private\n * @returns {boolean} True if the property of any object in array A is different than\n *   the same property of its corresponding object in array B.\n */\nfunction propertyHasChanged(propertyName, as, bs) {\n  return as.some((a, i) => a[propertyName] !== bs[i][propertyName]);\n}\n\n/**\n * Re-emit the native event, if the native mediaDevices has the corresponding property.\n * @param {MediaDevicesShim} mediaDevices\n * @param {string} eventName - Name of the event\n * @private\n * @returns {boolean} Whether the native mediaDevice had the corresponding property\n */\nfunction reemitNativeEvent(mediaDevices, eventName) {\n  const methodName = `on${eventName}`;\n\n  function dispatchEvent(event) {\n    mediaDevices.dispatchEvent(event);\n  }\n\n  if (methodName in nativeMediaDevices) {\n    // Use addEventListener if it's available so we don't stomp on any other listeners\n    // for this event. Currently, navigator.mediaDevices.addEventListener does not exist in Safari.\n    if ('addEventListener' in nativeMediaDevices) {\n      nativeMediaDevices.addEventListener(eventName, dispatchEvent);\n    } else {\n      nativeMediaDevices[methodName] = dispatchEvent;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction sortDevicesById(a, b) {\n  return a.deviceId < b.deviceId;\n}\n\nmodule.exports = (function shimMediaDevices() {\n  return nativeMediaDevices ? new MediaDevicesShim() : null;\n})();\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}