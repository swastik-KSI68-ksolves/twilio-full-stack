{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n// @ts-nocheck\nvar asyncQueue_1 = require(\"./asyncQueue\");\nvar audioplayer_1 = require(\"./audioplayer/audioplayer\");\nvar errors_1 = require(\"./errors\");\n/**\n * @class\n * @param {string} name - Name of the sound\n * @param {string} url - URL of the sound\n * @param {Sound#ConstructorOptions} options\n * @property {boolean} isPlaying - Whether the Sound is currently playing audio.\n * @property {string} name - Name of the sound\n * @property {string} url - URL of the sound\n * @property {AudioContext} audioContext - The AudioContext to use if available for AudioPlayer.\n */\n/**\n * @typedef {Object} Sound#ConstructorOptions\n * @property {number} [maxDuration=0] - The maximum length of time to play the sound\n *   before stopping it.\n * @property {Boolean} [shouldLoop=false] - Whether the sound should be looped.\n */\nfunction Sound(name, url, options) {\n  if (!(this instanceof Sound)) {\n    return new Sound(name, url, options);\n  }\n  if (!name || !url) {\n    throw new errors_1.InvalidArgumentError('name and url are required arguments');\n  }\n  options = Object.assign({\n    AudioFactory: typeof Audio !== 'undefined' ? Audio : null,\n    maxDuration: 0,\n    shouldLoop: false\n  }, options);\n  options.AudioPlayer = options.audioContext ? audioplayer_1.default.bind(audioplayer_1.default, options.audioContext) : options.AudioFactory;\n  Object.defineProperties(this, {\n    _Audio: {\n      value: options.AudioPlayer\n    },\n    _activeEls: {\n      value: new Map()\n    },\n    _isSinkSupported: {\n      value: options.AudioFactory !== null && typeof options.AudioFactory.prototype.setSinkId === 'function'\n    },\n    _maxDuration: {\n      value: options.maxDuration\n    },\n    _maxDurationTimeout: {\n      value: null,\n      writable: true\n    },\n    _operations: {\n      value: new asyncQueue_1.AsyncQueue()\n    },\n    _playPromise: {\n      value: null,\n      writable: true\n    },\n    _shouldLoop: {\n      value: options.shouldLoop\n    },\n    _sinkIds: {\n      value: ['default']\n    },\n    isPlaying: {\n      enumerable: true,\n      get: function () {\n        return !!this._playPromise;\n      }\n    },\n    name: {\n      enumerable: true,\n      value: name\n    },\n    url: {\n      enumerable: true,\n      value: url\n    }\n  });\n  if (this._Audio) {\n    // Play it (muted and should not loop) as soon as possible so that it does not get incorrectly caught by Chrome's\n    // \"gesture requirement for media playback\" feature.\n    // https://plus.google.com/+FrancoisBeaufort/posts/6PiJQqJzGqX\n    this._play(true, false);\n  }\n}\nfunction destroyAudioElement(audioElement) {\n  if (audioElement) {\n    audioElement.pause();\n    audioElement.src = '';\n    audioElement.srcObject = null;\n    audioElement.load();\n  }\n}\n/**\n * Plays the audio element that was initialized using the speficied sinkId\n */\nSound.prototype._playAudioElement = function _playAudioElement(sinkId, isMuted, shouldLoop) {\n  var _this = this;\n  var audioElement = this._activeEls.get(sinkId);\n  if (!audioElement) {\n    throw new errors_1.InvalidArgumentError(\"sinkId: \\\"\" + sinkId + \"\\\" doesn't have an audio element\");\n  }\n  audioElement.muted = !!isMuted;\n  audioElement.loop = !!shouldLoop;\n  return audioElement.play().then(function () {\n    return audioElement;\n  }).catch(function (reason) {\n    destroyAudioElement(audioElement);\n    _this._activeEls.delete(sinkId);\n    throw reason;\n  });\n};\n/**\n * Start playing the sound. Will stop the currently playing sound first.\n * If it exists, the audio element that was initialized for the sinkId will be used\n */\nSound.prototype._play = function _play(forceIsMuted, forceShouldLoop) {\n  if (this.isPlaying) {\n    this._stop();\n  }\n  if (this._maxDuration > 0) {\n    this._maxDurationTimeout = setTimeout(this._stop.bind(this), this._maxDuration);\n  }\n  forceShouldLoop = typeof forceShouldLoop === 'boolean' ? forceShouldLoop : this._shouldLoop;\n  var self = this;\n  var playPromise = this._playPromise = Promise.all(this._sinkIds.map(function createAudioElement(sinkId) {\n    if (!self._Audio) {\n      return Promise.resolve();\n    }\n    var audioElement = self._activeEls.get(sinkId);\n    if (audioElement) {\n      return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n    }\n    audioElement = new self._Audio(self.url);\n    // Make sure the browser always retrieves the resource using CORS.\n    // By default when using media tags, origin header is not sent to server\n    // which causes the server to not return CORS headers. When this caches\n    // on the CDN or browser, it causes issues to future requests that needs CORS,\n    // which is true when using AudioContext. Please note that we won't have to do this\n    // once we migrate to CloudFront.\n    if (typeof audioElement.setAttribute === 'function') {\n      audioElement.setAttribute('crossorigin', 'anonymous');\n    }\n    /**\n     * (rrowland) Bug in Chrome 53 & 54 prevents us from calling Audio.setSinkId without\n     *   crashing the tab. https://bugs.chromium.org/p/chromium/issues/detail?id=655342\n     */\n    return new Promise(function (resolve) {\n      audioElement.addEventListener('canplaythrough', resolve);\n    }).then(function () {\n      return (self._isSinkSupported ? audioElement.setSinkId(sinkId) : Promise.resolve()).then(function setSinkIdSuccess() {\n        self._activeEls.set(sinkId, audioElement);\n        // Stop has been called, bail out\n        if (!self._playPromise) {\n          return Promise.resolve();\n        }\n        return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n      });\n    });\n  }));\n  return playPromise;\n};\n/**\n * Stop playing the sound.\n */\nSound.prototype._stop = function _stop() {\n  var _this = this;\n  this._activeEls.forEach(function (audioEl, sinkId) {\n    if (_this._sinkIds.includes(sinkId)) {\n      audioEl.pause();\n      audioEl.currentTime = 0;\n    } else {\n      // Destroy the ones that are not used anymore\n      destroyAudioElement(audioEl);\n      _this._activeEls.delete(sinkId);\n    }\n  });\n  clearTimeout(this._maxDurationTimeout);\n  this._playPromise = null;\n  this._maxDurationTimeout = null;\n};\n/**\n * Update the sinkIds of the audio output devices this sound should play through.\n */\nSound.prototype.setSinkIds = function setSinkIds(ids) {\n  if (!this._isSinkSupported) {\n    return;\n  }\n  ids = ids.forEach ? ids : [ids];\n  [].splice.apply(this._sinkIds, [0, this._sinkIds.length].concat(ids));\n};\n/**\n * Add a stop operation to the queue\n */\nSound.prototype.stop = function stop() {\n  var _this = this;\n  this._operations.enqueue(function () {\n    _this._stop();\n    return Promise.resolve();\n  });\n};\n/**\n * Add a play operation to the queue\n */\nSound.prototype.play = function play() {\n  var _this = this;\n  return this._operations.enqueue(function () {\n    return _this._play();\n  });\n};\nexports.default = Sound;","map":{"version":3,"names":["asyncQueue_1","require","audioplayer_1","errors_1","Sound","name","url","options","InvalidArgumentError","Object","assign","AudioFactory","Audio","maxDuration","shouldLoop","AudioPlayer","audioContext","default","bind","defineProperties","_Audio","value","_activeEls","Map","_isSinkSupported","prototype","setSinkId","_maxDuration","_maxDurationTimeout","writable","_operations","AsyncQueue","_playPromise","_shouldLoop","_sinkIds","isPlaying","enumerable","get","_play","destroyAudioElement","audioElement","pause","src","srcObject","load","_playAudioElement","sinkId","isMuted","_this","muted","loop","play","then","catch","reason","delete","forceIsMuted","forceShouldLoop","_stop","setTimeout","self","playPromise","Promise","all","map","createAudioElement","resolve","setAttribute","addEventListener","setSinkIdSuccess","set","forEach","audioEl","includes","currentTime","clearTimeout","setSinkIds","ids","splice","apply","length","concat","stop","enqueue","exports"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/@twilio/voice-sdk/lib/twilio/sound.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n// @ts-nocheck\nimport { AsyncQueue } from './asyncQueue';\nimport AudioPlayer from './audioplayer/audioplayer';\nimport { InvalidArgumentError } from './errors';\n\n/**\n * @class\n * @param {string} name - Name of the sound\n * @param {string} url - URL of the sound\n * @param {Sound#ConstructorOptions} options\n * @property {boolean} isPlaying - Whether the Sound is currently playing audio.\n * @property {string} name - Name of the sound\n * @property {string} url - URL of the sound\n * @property {AudioContext} audioContext - The AudioContext to use if available for AudioPlayer.\n */\n/**\n * @typedef {Object} Sound#ConstructorOptions\n * @property {number} [maxDuration=0] - The maximum length of time to play the sound\n *   before stopping it.\n * @property {Boolean} [shouldLoop=false] - Whether the sound should be looped.\n */\nfunction Sound(name, url, options) {\n  if (!(this instanceof Sound)) {\n    return new Sound(name, url, options);\n  }\n\n  if (!name || !url) {\n    throw new InvalidArgumentError('name and url are required arguments');\n  }\n\n  options = Object.assign({\n    AudioFactory: typeof Audio !== 'undefined' ? Audio : null,\n    maxDuration: 0,\n    shouldLoop: false,\n  }, options);\n\n  options.AudioPlayer = options.audioContext\n    ? AudioPlayer.bind(AudioPlayer, options.audioContext)\n    : options.AudioFactory;\n\n  Object.defineProperties(this, {\n    _Audio: { value: options.AudioPlayer },\n    _activeEls: { value: new Map() },\n    _isSinkSupported: {\n      value: options.AudioFactory !== null\n        && typeof options.AudioFactory.prototype.setSinkId === 'function',\n    },\n    _maxDuration: { value: options.maxDuration },\n    _maxDurationTimeout: {\n      value: null,\n      writable: true,\n    },\n    _operations: { value: new AsyncQueue() },\n    _playPromise: {\n      value: null,\n      writable: true,\n    },\n    _shouldLoop: { value: options.shouldLoop },\n    _sinkIds: { value: ['default'] },\n    isPlaying: {\n      enumerable: true,\n      get() {\n        return !!this._playPromise;\n      },\n    },\n    name: {\n      enumerable: true,\n      value: name,\n    },\n    url: {\n      enumerable: true,\n      value: url,\n    },\n  });\n\n  if (this._Audio) {\n    // Play it (muted and should not loop) as soon as possible so that it does not get incorrectly caught by Chrome's\n    // \"gesture requirement for media playback\" feature.\n    // https://plus.google.com/+FrancoisBeaufort/posts/6PiJQqJzGqX\n    this._play(true, false);\n  }\n}\n\nfunction destroyAudioElement(audioElement) {\n  if (audioElement) {\n    audioElement.pause();\n    audioElement.src = '';\n    audioElement.srcObject = null;\n    audioElement.load();\n  }\n}\n\n/**\n * Plays the audio element that was initialized using the speficied sinkId\n */\nSound.prototype._playAudioElement = function _playAudioElement(sinkId, isMuted, shouldLoop) {\n  const audioElement = this._activeEls.get(sinkId);\n\n  if (!audioElement) {\n    throw new InvalidArgumentError(`sinkId: \"${sinkId}\" doesn't have an audio element`);\n  }\n\n  audioElement.muted = !!isMuted;\n  audioElement.loop = !!shouldLoop;\n\n  return audioElement.play()\n    .then(() => audioElement)\n    .catch((reason) => {\n      destroyAudioElement(audioElement);\n      this._activeEls.delete(sinkId);\n      throw reason;\n    });\n};\n\n/**\n * Start playing the sound. Will stop the currently playing sound first.\n * If it exists, the audio element that was initialized for the sinkId will be used\n */\nSound.prototype._play = function _play(forceIsMuted, forceShouldLoop) {\n  if (this.isPlaying) {\n    this._stop();\n  }\n\n  if (this._maxDuration > 0) {\n    this._maxDurationTimeout = setTimeout(this._stop.bind(this), this._maxDuration);\n  }\n\n  forceShouldLoop = typeof forceShouldLoop === 'boolean' ? forceShouldLoop : this._shouldLoop;\n  const self = this;\n  const playPromise = this._playPromise = Promise.all(this._sinkIds.map(function createAudioElement(sinkId) {\n    if (!self._Audio) {\n      return Promise.resolve();\n    }\n\n    let audioElement = self._activeEls.get(sinkId);\n    if (audioElement) {\n      return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n    }\n\n    audioElement = new self._Audio(self.url);\n\n    // Make sure the browser always retrieves the resource using CORS.\n    // By default when using media tags, origin header is not sent to server\n    // which causes the server to not return CORS headers. When this caches\n    // on the CDN or browser, it causes issues to future requests that needs CORS,\n    // which is true when using AudioContext. Please note that we won't have to do this\n    // once we migrate to CloudFront.\n    if (typeof audioElement.setAttribute === 'function') {\n      audioElement.setAttribute('crossorigin', 'anonymous');\n    }\n\n    /**\n     * (rrowland) Bug in Chrome 53 & 54 prevents us from calling Audio.setSinkId without\n     *   crashing the tab. https://bugs.chromium.org/p/chromium/issues/detail?id=655342\n     */\n    return new Promise(resolve => {\n      audioElement.addEventListener('canplaythrough', resolve);\n    }).then(() => {\n      return (self._isSinkSupported\n          ? audioElement.setSinkId(sinkId)\n          : Promise.resolve()).then(function setSinkIdSuccess() {\n        self._activeEls.set(sinkId, audioElement);\n\n        // Stop has been called, bail out\n        if (!self._playPromise) {\n          return Promise.resolve();\n        }\n        return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n      });\n    });\n  }));\n\n  return playPromise;\n};\n\n/**\n * Stop playing the sound.\n */\nSound.prototype._stop = function _stop() {\n  this._activeEls.forEach((audioEl, sinkId) => {\n    if (this._sinkIds.includes(sinkId)) {\n      audioEl.pause();\n      audioEl.currentTime = 0;\n    } else {\n      // Destroy the ones that are not used anymore\n      destroyAudioElement(audioEl);\n      this._activeEls.delete(sinkId);\n    }\n  });\n\n  clearTimeout(this._maxDurationTimeout);\n\n  this._playPromise = null;\n  this._maxDurationTimeout = null;\n};\n\n/**\n * Update the sinkIds of the audio output devices this sound should play through.\n */\nSound.prototype.setSinkIds = function setSinkIds(ids) {\n  if (!this._isSinkSupported) { return; }\n\n  ids = ids.forEach ? ids : [ids];\n  [].splice.apply(this._sinkIds, [0, this._sinkIds.length].concat(ids));\n};\n\n/**\n * Add a stop operation to the queue\n */\nSound.prototype.stop = function stop() {\n  this._operations.enqueue(() => {\n    this._stop();\n    return Promise.resolve();\n  });\n};\n\n/**\n * Add a play operation to the queue\n */\nSound.prototype.play = function play() {\n  return this._operations.enqueue(() => this._play());\n};\n\nexport default Sound;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}