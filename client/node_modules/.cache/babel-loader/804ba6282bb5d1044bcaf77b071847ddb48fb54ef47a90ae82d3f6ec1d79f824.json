{"ast":null,"code":"\"use strict\";\n\n/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WSTransportState = void 0;\nvar events_1 = require(\"events\");\nvar backoff_1 = require(\"./backoff\");\nvar errors_1 = require(\"./errors\");\nvar log_1 = require(\"./log\");\nvar WebSocket = globalThis.WebSocket;\nvar CONNECT_SUCCESS_TIMEOUT = 10000;\nvar CONNECT_TIMEOUT = 5000;\nvar HEARTBEAT_TIMEOUT = 15000;\nvar MAX_PREFERRED_DURATION = 15000;\nvar MAX_PRIMARY_DURATION = Infinity;\nvar MAX_PREFERRED_DELAY = 1000;\nvar MAX_PRIMARY_DELAY = 20000;\n/**\n * All possible states of WSTransport.\n */\nvar WSTransportState;\n(function (WSTransportState) {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  WSTransportState[\"Connecting\"] = \"connecting\";\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n  WSTransportState[\"Closed\"] = \"closed\";\n  /**\n   * The underlying WebSocket is open and active.\n   */\n  WSTransportState[\"Open\"] = \"open\";\n})(WSTransportState = exports.WSTransportState || (exports.WSTransportState = {}));\n/**\n * WebSocket Transport\n */\nvar WSTransport = /** @class */function (_super) {\n  __extends(WSTransport, _super);\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n  function WSTransport(uris, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = _super.call(this) || this;\n    /**\n     * The current state of the WSTransport.\n     */\n    _this.state = WSTransportState.Closed;\n    /**\n     * Start timestamp values for backoffs.\n     */\n    _this._backoffStartTime = {\n      preferred: null,\n      primary: null\n    };\n    /**\n     * The URI that the transport is connecting or connected to. The value of this\n     * property is `null` if a connection attempt has not been made yet.\n     */\n    _this._connectedUri = null;\n    /**\n     * An instance of Logger to use.\n     */\n    _this._log = log_1.default.getInstance();\n    /**\n     * Whether we should attempt to fallback if we receive an applicable error\n     * when trying to connect to a signaling endpoint.\n     */\n    _this._shouldFallback = false;\n    /**\n     * The current uri index that the transport is connected to.\n     */\n    _this._uriIndex = 0;\n    /**\n     * Move the uri index to the next index\n     * If the index is at the end, the index goes back to the first one.\n     */\n    _this._moveUriIndex = function () {\n      _this._uriIndex++;\n      if (_this._uriIndex >= _this._uris.length) {\n        _this._uriIndex = 0;\n      }\n    };\n    /**\n     * Called in response to WebSocket#close event.\n     */\n    _this._onSocketClose = function (event) {\n      _this._log.info(\"Received websocket close event code: \" + event.code + \". Reason: \" + event.reason);\n      // 1006: Abnormal close. When the server is unreacheable\n      // 1015: TLS Handshake error\n      if (event.code === 1006 || event.code === 1015) {\n        _this.emit('error', {\n          code: 31005,\n          message: event.reason || 'Websocket connection to Twilio\\'s signaling servers were ' + 'unexpectedly ended. If this is happening consistently, there may ' + 'be an issue resolving the hostname provided. If a region or an ' + 'edge is being specified in Device setup, ensure it is valid.',\n          twilioError: new errors_1.SignalingErrors.ConnectionError()\n        });\n        var wasConnected =\n        // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        _this.state === WSTransportState.Open ||\n        // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        _this._previousState === WSTransportState.Open;\n        // Only fallback if this is not the first error\n        // and if we were not connected previously\n        if (_this._shouldFallback || !wasConnected) {\n          _this._moveUriIndex();\n        }\n        _this._shouldFallback = true;\n      }\n      _this._closeSocket();\n    };\n    /**\n     * Called in response to WebSocket#error event.\n     */\n    _this._onSocketError = function (err) {\n      _this._log.info(\"WebSocket received error: \" + err.message);\n      _this.emit('error', {\n        code: 31000,\n        message: err.message || 'WSTransport socket error',\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n    };\n    /**\n     * Called in response to WebSocket#message event.\n     */\n    _this._onSocketMessage = function (message) {\n      // Clear heartbeat timeout on any incoming message, as they\n      // all indicate an active connection.\n      _this._setHeartbeatTimeout();\n      // Filter and respond to heartbeats\n      if (_this._socket && message.data === '\\n') {\n        _this._socket.send('\\n');\n        return;\n      }\n      _this.emit('message', message);\n    };\n    /**\n     * Called in response to WebSocket#open event.\n     */\n    _this._onSocketOpen = function () {\n      _this._log.info('WebSocket opened successfully.');\n      _this._timeOpened = Date.now();\n      _this._shouldFallback = false;\n      _this._setState(WSTransportState.Open);\n      clearTimeout(_this._connectTimeout);\n      _this._resetBackoffs();\n      _this._setHeartbeatTimeout();\n      _this.emit('open');\n    };\n    _this._options = __assign(__assign({}, WSTransport.defaultConstructorOptions), options);\n    _this._uris = uris;\n    _this._backoff = _this._setupBackoffs();\n    return _this;\n  }\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  WSTransport.prototype.close = function () {\n    this._log.info('WSTransport.close() called...');\n    this._close();\n  };\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n  WSTransport.prototype.open = function () {\n    this._log.info('WSTransport.open() called...');\n    if (this._socket && (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n      return;\n    }\n    if (this._preferredUri) {\n      this._connect(this._preferredUri);\n    } else {\n      this._connect(this._uris[this._uriIndex]);\n    }\n  };\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n  WSTransport.prototype.send = function (message) {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n      this._closeSocket();\n      return false;\n    }\n    return true;\n  };\n  /**\n   * Update the preferred URI to connect to. Useful for Call signaling\n   * reconnection, which requires connecting on the same edge. If `null` is\n   * passed, the preferred URI is unset and the original `uris` array and\n   * `uriIndex` is used to determine the signaling URI to connect to.\n   * @param uri\n   */\n  WSTransport.prototype.updatePreferredURI = function (uri) {\n    this._preferredUri = uri;\n  };\n  /**\n   * Update acceptable URIs to reconnect to. Resets the URI index to 0.\n   */\n  WSTransport.prototype.updateURIs = function (uris) {\n    if (typeof uris === 'string') {\n      uris = [uris];\n    }\n    this._uris = uris;\n    this._uriIndex = 0;\n  };\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  WSTransport.prototype._close = function () {\n    this._setState(WSTransportState.Closed);\n    this._closeSocket();\n  };\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n  WSTransport.prototype._closeSocket = function () {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n    this._log.info('Closing and cleaning up WebSocket...');\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n      return;\n    }\n    this._socket.removeEventListener('close', this._onSocketClose);\n    this._socket.removeEventListener('error', this._onSocketError);\n    this._socket.removeEventListener('message', this._onSocketMessage);\n    this._socket.removeEventListener('open', this._onSocketOpen);\n    if (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    }\n    // Reset backoff counter if connection was open for long enough to be considered successful\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._resetBackoffs();\n    }\n    if (this.state !== WSTransportState.Closed) {\n      this._performBackoff();\n    }\n    delete this._socket;\n    this.emit('close');\n  };\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [uri] - URI string to connect to.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n  WSTransport.prototype._connect = function (uri, retryCount) {\n    var _this = this;\n    this._log.info(typeof retryCount === 'number' ? \"Attempting to reconnect (retry #\" + retryCount + \")...\" : 'Attempting to connect...');\n    this._closeSocket();\n    this._setState(WSTransportState.Connecting);\n    this._connectedUri = uri;\n    try {\n      this._socket = new this._options.WebSocket(this._connectedUri);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n      this._close();\n      this.emit('error', {\n        code: 31000,\n        message: e.message || \"Could not connect to \" + this._connectedUri,\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n      return;\n    }\n    this._socket.addEventListener('close', this._onSocketClose);\n    this._socket.addEventListener('error', this._onSocketError);\n    this._socket.addEventListener('message', this._onSocketMessage);\n    this._socket.addEventListener('open', this._onSocketOpen);\n    delete this._timeOpened;\n    this._connectTimeout = setTimeout(function () {\n      _this._log.info('WebSocket connection attempt timed out.');\n      _this._moveUriIndex();\n      _this._closeSocket();\n    }, this._options.connectTimeoutMs);\n  };\n  /**\n   * Perform a backoff. If a preferred URI is set (not null), then backoff\n   * using the preferred mechanism. Otherwise, use the primary mechanism.\n   */\n  WSTransport.prototype._performBackoff = function () {\n    if (this._preferredUri) {\n      this._log.info('Preferred URI set; backing off.');\n      this._backoff.preferred.backoff();\n    } else {\n      this._log.info('Preferred URI not set; backing off.');\n      this._backoff.primary.backoff();\n    }\n  };\n  /**\n   * Reset both primary and preferred backoff mechanisms.\n   */\n  WSTransport.prototype._resetBackoffs = function () {\n    this._backoff.preferred.reset();\n    this._backoff.primary.reset();\n    this._backoffStartTime.preferred = null;\n    this._backoffStartTime.primary = null;\n  };\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n  WSTransport.prototype._setHeartbeatTimeout = function () {\n    var _this = this;\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(function () {\n      _this._log.info(\"No messages received in \" + HEARTBEAT_TIMEOUT / 1000 + \" seconds. Reconnecting...\");\n      _this._shouldFallback = true;\n      _this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  };\n  /**\n   * Set the current and previous state\n   */\n  WSTransport.prototype._setState = function (state) {\n    this._previousState = this.state;\n    this.state = state;\n  };\n  /**\n   * Set up the primary and preferred backoff mechanisms.\n   */\n  WSTransport.prototype._setupBackoffs = function () {\n    var _this = this;\n    var preferredBackoffConfig = {\n      factor: 2.0,\n      jitter: 0.40,\n      max: this._options.maxPreferredDelayMs,\n      min: 100\n    };\n    this._log.info('Initializing preferred transport backoff using config: ', preferredBackoffConfig);\n    var preferredBackoff = new backoff_1.default(preferredBackoffConfig);\n    preferredBackoff.on('backoff', function (attempt, delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Preferred backoff initiated but transport state is closed; not attempting a connection.');\n        return;\n      }\n      _this._log.info(\"Will attempt to reconnect Websocket to preferred URI in \" + delay + \"ms\");\n      if (attempt === 0) {\n        _this._backoffStartTime.preferred = Date.now();\n        _this._log.info(\"Preferred backoff start; \" + _this._backoffStartTime.preferred);\n      }\n    });\n    preferredBackoff.on('ready', function (attempt, _delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Preferred backoff ready but transport state is closed; not attempting a connection.');\n        return;\n      }\n      if (_this._backoffStartTime.preferred === null) {\n        _this._log.info('Preferred backoff start time invalid; not attempting a connection.');\n        return;\n      }\n      if (Date.now() - _this._backoffStartTime.preferred > _this._options.maxPreferredDurationMs) {\n        _this._log.info('Max preferred backoff attempt time exceeded; falling back to primary backoff.');\n        _this._preferredUri = null;\n        _this._backoff.primary.backoff();\n        return;\n      }\n      if (typeof _this._preferredUri !== 'string') {\n        _this._log.info('Preferred URI cleared; falling back to primary backoff.');\n        _this._preferredUri = null;\n        _this._backoff.primary.backoff();\n        return;\n      }\n      _this._connect(_this._preferredUri, attempt + 1);\n    });\n    var primaryBackoffConfig = {\n      factor: 2.0,\n      jitter: 0.40,\n      max: this._options.maxPrimaryDelayMs,\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      min: this._uris && this._uris.length > 1 ? Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000 : 100\n    };\n    this._log.info('Initializing primary transport backoff using config: ', primaryBackoffConfig);\n    var primaryBackoff = new backoff_1.default(primaryBackoffConfig);\n    primaryBackoff.on('backoff', function (attempt, delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Primary backoff initiated but transport state is closed; not attempting a connection.');\n        return;\n      }\n      _this._log.info(\"Will attempt to reconnect WebSocket in \" + delay + \"ms\");\n      if (attempt === 0) {\n        _this._backoffStartTime.primary = Date.now();\n        _this._log.info(\"Primary backoff start; \" + _this._backoffStartTime.primary);\n      }\n    });\n    primaryBackoff.on('ready', function (attempt, _delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Primary backoff ready but transport state is closed; not attempting a connection.');\n        return;\n      }\n      if (_this._backoffStartTime.primary === null) {\n        _this._log.info('Primary backoff start time invalid; not attempting a connection.');\n        return;\n      }\n      if (Date.now() - _this._backoffStartTime.primary > _this._options.maxPrimaryDurationMs) {\n        _this._log.info('Max primary backoff attempt time exceeded; not attempting a connection.');\n        return;\n      }\n      _this._connect(_this._uris[_this._uriIndex], attempt + 1);\n    });\n    return {\n      preferred: preferredBackoff,\n      primary: primaryBackoff\n    };\n  };\n  Object.defineProperty(WSTransport.prototype, \"uri\", {\n    /**\n     * The uri the transport is currently connected to\n     */\n    get: function () {\n      return this._connectedUri;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  WSTransport.defaultConstructorOptions = {\n    WebSocket: WebSocket,\n    connectTimeoutMs: CONNECT_TIMEOUT,\n    maxPreferredDelayMs: MAX_PREFERRED_DELAY,\n    maxPreferredDurationMs: MAX_PREFERRED_DURATION,\n    maxPrimaryDelayMs: MAX_PRIMARY_DELAY,\n    maxPrimaryDurationMs: MAX_PRIMARY_DURATION\n  };\n  return WSTransport;\n}(events_1.EventEmitter);\nexports.default = WSTransport;","map":{"version":3,"names":["events_1","require","backoff_1","errors_1","log_1","WebSocket","globalThis","CONNECT_SUCCESS_TIMEOUT","CONNECT_TIMEOUT","HEARTBEAT_TIMEOUT","MAX_PREFERRED_DURATION","MAX_PRIMARY_DURATION","Infinity","MAX_PREFERRED_DELAY","MAX_PRIMARY_DELAY","WSTransportState","exports","WSTransport","_super","__extends","uris","options","_this","call","state","Closed","_backoffStartTime","preferred","primary","_connectedUri","_log","default","getInstance","_shouldFallback","_uriIndex","_moveUriIndex","_uris","length","_onSocketClose","event","info","code","reason","emit","message","twilioError","SignalingErrors","ConnectionError","wasConnected","Open","_previousState","_closeSocket","_onSocketError","err","ConnectionDisconnected","_onSocketMessage","_setHeartbeatTimeout","_socket","data","send","_onSocketOpen","_timeOpened","Date","now","_setState","clearTimeout","_connectTimeout","_resetBackoffs","_options","__assign","defaultConstructorOptions","_backoff","_setupBackoffs","prototype","close","_close","open","readyState","CONNECTING","OPEN","_preferredUri","_connect","e","updatePreferredURI","uri","updateURIs","_heartbeatTimeout","removeEventListener","_performBackoff","retryCount","Connecting","addEventListener","setTimeout","connectTimeoutMs","backoff","reset","preferredBackoffConfig","factor","jitter","max","maxPreferredDelayMs","min","preferredBackoff","on","attempt","delay","_delay","maxPreferredDurationMs","primaryBackoffConfig","maxPrimaryDelayMs","Math","floor","random","primaryBackoff","maxPrimaryDurationMs","Object","defineProperty","get","EventEmitter"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/@twilio/voice-sdk/lib/twilio/wstransport.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\n\nimport { EventEmitter } from 'events';\nimport Backoff from './backoff';\nimport { SignalingErrors } from './errors';\nimport Log from './log';\n\nconst WebSocket = globalThis.WebSocket;\n\nconst CONNECT_SUCCESS_TIMEOUT = 10000;\nconst CONNECT_TIMEOUT = 5000;\nconst HEARTBEAT_TIMEOUT = 15000;\nconst MAX_PREFERRED_DURATION = 15000;\nconst MAX_PRIMARY_DURATION = Infinity;\nconst MAX_PREFERRED_DELAY = 1000;\nconst MAX_PRIMARY_DELAY = 20000;\n\nexport interface IMessageEvent {\n  data: string;\n  target: WebSocket;\n  type: string;\n}\n\n/**\n * All possible states of WSTransport.\n */\nexport enum WSTransportState {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  Connecting = 'connecting',\n\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n  Closed = 'closed',\n\n  /**\n   * The underlying WebSocket is open and active.\n   */\n  Open = 'open',\n}\n\n/**\n * Options to be passed to the WSTransport constructor.\n */\nexport interface IWSTransportConstructorOptions {\n  /**\n   * Time in milliseconds before websocket times out when attempting to connect\n   */\n  connectTimeoutMs?: number;\n\n  /**\n   * The maximum delay for the preferred backoff to make a connection attempt.\n   */\n  maxPreferredDelayMs?: number;\n\n  /**\n   * Max duration to attempt connecting to a preferred URI.\n   */\n  maxPreferredDurationMs?: number;\n\n  /**\n   * The maximum delay for the rimary backoff to make a connection attempt.\n   */\n  maxPrimaryDelayMs?: number;\n\n  /**\n   * Max duration to attempt connecting to a preferred URI.\n   */\n  maxPrimaryDurationMs?: number;\n\n  /**\n   * A WebSocket factory to use instead of WebSocket.\n   */\n  WebSocket?: typeof WebSocket;\n}\n\n/**\n * Type of the stored options property internally used by the WSTransport class.\n */\ntype IInternalWSTransportConstructorOptions = Required<IWSTransportConstructorOptions>;\n\n/**\n * WebSocket Transport\n */\nexport default class WSTransport extends EventEmitter {\n  private static defaultConstructorOptions: IInternalWSTransportConstructorOptions = {\n    WebSocket,\n    connectTimeoutMs: CONNECT_TIMEOUT,\n    maxPreferredDelayMs: MAX_PREFERRED_DELAY,\n    maxPreferredDurationMs: MAX_PREFERRED_DURATION,\n    maxPrimaryDelayMs: MAX_PRIMARY_DELAY,\n    maxPrimaryDurationMs: MAX_PRIMARY_DURATION,\n  };\n\n  /**\n   * The current state of the WSTransport.\n   */\n  state: WSTransportState = WSTransportState.Closed;\n\n  /**\n   * The backoff instance used to schedule reconnection attempts.\n   */\n  private readonly _backoff: {\n    preferred: any;\n    primary: any;\n  };\n\n  /**\n   * Start timestamp values for backoffs.\n   */\n  private _backoffStartTime: {\n    preferred: number | null;\n    primary: number | null;\n  } = {\n    preferred: null,\n    primary: null,\n  };\n\n  /**\n   * The URI that the transport is connecting or connected to. The value of this\n   * property is `null` if a connection attempt has not been made yet.\n   */\n  private _connectedUri: string | null = null;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _connectTimeout?: any;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _heartbeatTimeout?: any;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = Log.getInstance();\n\n  /**\n   * Options after missing values are defaulted.\n   */\n  private _options: IInternalWSTransportConstructorOptions;\n\n  /**\n   * Preferred URI endpoint to connect to.\n   */\n  private _preferredUri: string | null;\n\n  /**\n   * Previous state of the connection\n   */\n  private _previousState: WSTransportState;\n\n  /**\n   * Whether we should attempt to fallback if we receive an applicable error\n   * when trying to connect to a signaling endpoint.\n   */\n  private _shouldFallback: boolean = false;\n\n  /**\n   * The currently connecting or open WebSocket.\n   */\n  private _socket?: WebSocket;\n\n  /**\n   * The time the active connection was opened.\n   */\n  private _timeOpened?: number;\n\n  /**\n   * The current uri index that the transport is connected to.\n   */\n  private _uriIndex: number = 0;\n\n  /**\n   * List of URI of the endpoints to connect to.\n   */\n  private _uris: string[];\n\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n  constructor(uris: string[], options: IWSTransportConstructorOptions = { }) {\n    super();\n\n    this._options = { ...WSTransport.defaultConstructorOptions, ...options };\n\n    this._uris = uris;\n\n    this._backoff = this._setupBackoffs();\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  close(): void {\n    this._log.info('WSTransport.close() called...');\n    this._close();\n  }\n\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n  open(): void {\n    this._log.info('WSTransport.open() called...');\n\n    if (this._socket &&\n        (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n      return;\n    }\n\n    if (this._preferredUri) {\n      this._connect(this._preferredUri);\n    } else {\n      this._connect(this._uris[this._uriIndex]);\n    }\n  }\n\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n  send(message: string): boolean {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n      this._closeSocket();\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Update the preferred URI to connect to. Useful for Call signaling\n   * reconnection, which requires connecting on the same edge. If `null` is\n   * passed, the preferred URI is unset and the original `uris` array and\n   * `uriIndex` is used to determine the signaling URI to connect to.\n   * @param uri\n   */\n  updatePreferredURI(uri: string | null) {\n    this._preferredUri = uri;\n  }\n\n  /**\n   * Update acceptable URIs to reconnect to. Resets the URI index to 0.\n   */\n  updateURIs(uris: string[] | string) {\n    if (typeof uris === 'string') {\n      uris = [uris];\n    }\n\n    this._uris = uris;\n    this._uriIndex = 0;\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  private _close(): void {\n    this._setState(WSTransportState.Closed);\n    this._closeSocket();\n  }\n\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n  private _closeSocket(): void {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n\n    this._log.info('Closing and cleaning up WebSocket...');\n\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n      return;\n    }\n\n    this._socket.removeEventListener('close', this._onSocketClose as any);\n    this._socket.removeEventListener('error', this._onSocketError as any);\n    this._socket.removeEventListener('message', this._onSocketMessage as any);\n    this._socket.removeEventListener('open', this._onSocketOpen as any);\n\n    if (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    }\n\n    // Reset backoff counter if connection was open for long enough to be considered successful\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._resetBackoffs();\n    }\n\n    if (this.state !== WSTransportState.Closed) {\n      this._performBackoff();\n    }\n    delete this._socket;\n\n    this.emit('close');\n  }\n\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [uri] - URI string to connect to.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n  private _connect(uri: string, retryCount?: number): void {\n    this._log.info(\n      typeof retryCount === 'number'\n        ? `Attempting to reconnect (retry #${retryCount})...`\n        : 'Attempting to connect...',\n    );\n\n    this._closeSocket();\n\n    this._setState(WSTransportState.Connecting);\n    this._connectedUri = uri;\n\n    try {\n      this._socket = new this._options.WebSocket(this._connectedUri);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n      this._close();\n      this.emit('error', {\n        code: 31000,\n        message: e.message || `Could not connect to ${this._connectedUri}`,\n        twilioError: new SignalingErrors.ConnectionDisconnected(),\n      });\n      return;\n    }\n\n    this._socket.addEventListener('close', this._onSocketClose as any);\n    this._socket.addEventListener('error', this._onSocketError as any);\n    this._socket.addEventListener('message', this._onSocketMessage as any);\n    this._socket.addEventListener('open', this._onSocketOpen as any);\n\n    delete this._timeOpened;\n\n    this._connectTimeout = setTimeout(() => {\n      this._log.info('WebSocket connection attempt timed out.');\n      this._moveUriIndex();\n      this._closeSocket();\n    }, this._options.connectTimeoutMs);\n  }\n\n  /**\n   * Move the uri index to the next index\n   * If the index is at the end, the index goes back to the first one.\n   */\n  private _moveUriIndex = (): void => {\n    this._uriIndex++;\n    if (this._uriIndex >= this._uris.length) {\n      this._uriIndex = 0;\n    }\n  }\n\n  /**\n   * Called in response to WebSocket#close event.\n   */\n  private _onSocketClose = (event: CloseEvent): void => {\n    this._log.info(`Received websocket close event code: ${event.code}. Reason: ${event.reason}`);\n    // 1006: Abnormal close. When the server is unreacheable\n    // 1015: TLS Handshake error\n    if (event.code === 1006 || event.code === 1015) {\n      this.emit('error', {\n        code: 31005,\n        message: event.reason ||\n          'Websocket connection to Twilio\\'s signaling servers were ' +\n          'unexpectedly ended. If this is happening consistently, there may ' +\n          'be an issue resolving the hostname provided. If a region or an ' +\n          'edge is being specified in Device setup, ensure it is valid.',\n        twilioError: new SignalingErrors.ConnectionError(),\n      });\n\n      const wasConnected = (\n        // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        this.state === WSTransportState.Open ||\n\n        // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        this._previousState === WSTransportState.Open\n      );\n\n      // Only fallback if this is not the first error\n      // and if we were not connected previously\n      if (this._shouldFallback || !wasConnected) {\n        this._moveUriIndex();\n      }\n\n      this._shouldFallback = true;\n    }\n    this._closeSocket();\n  }\n\n  /**\n   * Called in response to WebSocket#error event.\n   */\n  private _onSocketError = (err: Error): void => {\n    this._log.info(`WebSocket received error: ${err.message}`);\n    this.emit('error', {\n      code: 31000,\n      message: err.message || 'WSTransport socket error',\n      twilioError: new SignalingErrors.ConnectionDisconnected(),\n    });\n  }\n\n  /**\n   * Called in response to WebSocket#message event.\n   */\n  private _onSocketMessage = (message: IMessageEvent): void => {\n    // Clear heartbeat timeout on any incoming message, as they\n    // all indicate an active connection.\n    this._setHeartbeatTimeout();\n\n    // Filter and respond to heartbeats\n    if (this._socket && message.data === '\\n') {\n      this._socket.send('\\n');\n      return;\n    }\n\n    this.emit('message', message);\n  }\n\n  /**\n   * Called in response to WebSocket#open event.\n   */\n  private _onSocketOpen = (): void => {\n    this._log.info('WebSocket opened successfully.');\n    this._timeOpened = Date.now();\n    this._shouldFallback = false;\n    this._setState(WSTransportState.Open);\n    clearTimeout(this._connectTimeout);\n\n    this._resetBackoffs();\n\n    this._setHeartbeatTimeout();\n    this.emit('open');\n  }\n\n  /**\n   * Perform a backoff. If a preferred URI is set (not null), then backoff\n   * using the preferred mechanism. Otherwise, use the primary mechanism.\n   */\n  private _performBackoff(): void {\n    if (this._preferredUri) {\n      this._log.info('Preferred URI set; backing off.');\n      this._backoff.preferred.backoff();\n    } else {\n      this._log.info('Preferred URI not set; backing off.');\n      this._backoff.primary.backoff();\n    }\n  }\n\n  /**\n   * Reset both primary and preferred backoff mechanisms.\n   */\n  private _resetBackoffs() {\n    this._backoff.preferred.reset();\n    this._backoff.primary.reset();\n\n    this._backoffStartTime.preferred = null;\n    this._backoffStartTime.primary = null;\n  }\n\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n  private _setHeartbeatTimeout(): void {\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(() => {\n      this._log.info(`No messages received in ${HEARTBEAT_TIMEOUT / 1000} seconds. Reconnecting...`);\n      this._shouldFallback = true;\n      this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  }\n\n  /**\n   * Set the current and previous state\n   */\n  private _setState(state: WSTransportState): void {\n    this._previousState = this.state;\n    this.state = state;\n  }\n\n  /**\n   * Set up the primary and preferred backoff mechanisms.\n   */\n  private _setupBackoffs(): typeof WSTransport.prototype._backoff {\n    const preferredBackoffConfig = {\n      factor: 2.0,\n      jitter: 0.40,\n      max: this._options.maxPreferredDelayMs,\n      min: 100,\n    };\n    this._log.info('Initializing preferred transport backoff using config: ', preferredBackoffConfig);\n    const preferredBackoff = new Backoff(preferredBackoffConfig);\n\n    preferredBackoff.on('backoff', (attempt: number, delay: number) => {\n      if (this.state === WSTransportState.Closed) {\n        this._log.info('Preferred backoff initiated but transport state is closed; not attempting a connection.');\n        return;\n      }\n      this._log.info(`Will attempt to reconnect Websocket to preferred URI in ${delay}ms`);\n      if (attempt === 0) {\n        this._backoffStartTime.preferred = Date.now();\n        this._log.info(`Preferred backoff start; ${this._backoffStartTime.preferred}`);\n      }\n    });\n\n    preferredBackoff.on('ready', (attempt: number, _delay: number) => {\n      if (this.state === WSTransportState.Closed) {\n        this._log.info('Preferred backoff ready but transport state is closed; not attempting a connection.');\n        return;\n      }\n      if (this._backoffStartTime.preferred === null) {\n        this._log.info('Preferred backoff start time invalid; not attempting a connection.');\n        return;\n      }\n      if (Date.now() - this._backoffStartTime.preferred > this._options.maxPreferredDurationMs) {\n        this._log.info('Max preferred backoff attempt time exceeded; falling back to primary backoff.');\n        this._preferredUri = null;\n        this._backoff.primary.backoff();\n        return;\n      }\n      if (typeof this._preferredUri !== 'string') {\n        this._log.info('Preferred URI cleared; falling back to primary backoff.');\n        this._preferredUri = null;\n        this._backoff.primary.backoff();\n        return;\n      }\n      this._connect(this._preferredUri, attempt + 1);\n    });\n\n    const primaryBackoffConfig = {\n      factor: 2.0,\n      jitter: 0.40,\n      max: this._options.maxPrimaryDelayMs,\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      min: this._uris && this._uris.length > 1\n        ? Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000\n        : 100,\n    };\n    this._log.info('Initializing primary transport backoff using config: ', primaryBackoffConfig);\n    const primaryBackoff = new Backoff(primaryBackoffConfig);\n\n    primaryBackoff.on('backoff', (attempt: number, delay: number) => {\n      if (this.state === WSTransportState.Closed) {\n        this._log.info('Primary backoff initiated but transport state is closed; not attempting a connection.');\n        return;\n      }\n      this._log.info(`Will attempt to reconnect WebSocket in ${delay}ms`);\n      if (attempt === 0) {\n        this._backoffStartTime.primary = Date.now();\n        this._log.info(`Primary backoff start; ${this._backoffStartTime.primary}`);\n      }\n    });\n\n    primaryBackoff.on('ready', (attempt: number, _delay: number) => {\n      if (this.state === WSTransportState.Closed) {\n        this._log.info('Primary backoff ready but transport state is closed; not attempting a connection.');\n        return;\n      }\n      if (this._backoffStartTime.primary === null) {\n        this._log.info('Primary backoff start time invalid; not attempting a connection.');\n        return;\n      }\n      if (Date.now() - this._backoffStartTime.primary > this._options.maxPrimaryDurationMs) {\n        this._log.info('Max primary backoff attempt time exceeded; not attempting a connection.');\n        return;\n      }\n      this._connect(this._uris[this._uriIndex], attempt + 1);\n    });\n\n    return {\n      preferred: preferredBackoff,\n      primary: primaryBackoff,\n    };\n  }\n\n  /**\n   * The uri the transport is currently connected to\n   */\n  get uri(): string | null {\n    return this._connectedUri;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}