{"ast":null,"code":"//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar events = require('events');\nvar precond = require('precond');\nvar util = require('util');\nvar Backoff = require('./backoff');\nvar FibonacciBackoffStrategy = require('./strategy/fibonacci');\n\n// Wraps a function to be called in a backoff loop.\nfunction FunctionCall(fn, args, callback) {\n  events.EventEmitter.call(this);\n  precond.checkIsFunction(fn, 'Expected fn to be a function.');\n  precond.checkIsArray(args, 'Expected args to be an array.');\n  precond.checkIsFunction(callback, 'Expected callback to be a function.');\n  this.function_ = fn;\n  this.arguments_ = args;\n  this.callback_ = callback;\n  this.lastResult_ = [];\n  this.numRetries_ = 0;\n  this.backoff_ = null;\n  this.strategy_ = null;\n  this.failAfter_ = -1;\n  this.retryPredicate_ = FunctionCall.DEFAULT_RETRY_PREDICATE_;\n  this.state_ = FunctionCall.State_.PENDING;\n}\nutil.inherits(FunctionCall, events.EventEmitter);\n\n// States in which the call can be.\nFunctionCall.State_ = {\n  // Call isn't started yet.\n  PENDING: 0,\n  // Call is in progress.\n  RUNNING: 1,\n  // Call completed successfully which means that either the wrapped function\n  // returned successfully or the maximal number of backoffs was reached.\n  COMPLETED: 2,\n  // The call was aborted.\n  ABORTED: 3\n};\n\n// The default retry predicate which considers any error as retriable.\nFunctionCall.DEFAULT_RETRY_PREDICATE_ = function (err) {\n  return true;\n};\n\n// Checks whether the call is pending.\nFunctionCall.prototype.isPending = function () {\n  return this.state_ == FunctionCall.State_.PENDING;\n};\n\n// Checks whether the call is in progress.\nFunctionCall.prototype.isRunning = function () {\n  return this.state_ == FunctionCall.State_.RUNNING;\n};\n\n// Checks whether the call is completed.\nFunctionCall.prototype.isCompleted = function () {\n  return this.state_ == FunctionCall.State_.COMPLETED;\n};\n\n// Checks whether the call is aborted.\nFunctionCall.prototype.isAborted = function () {\n  return this.state_ == FunctionCall.State_.ABORTED;\n};\n\n// Sets the backoff strategy to use. Can only be called before the call is\n// started otherwise an exception will be thrown.\nFunctionCall.prototype.setStrategy = function (strategy) {\n  precond.checkState(this.isPending(), 'FunctionCall in progress.');\n  this.strategy_ = strategy;\n  return this; // Return this for chaining.\n};\n\n// Sets the predicate which will be used to determine whether the errors\n// returned from the wrapped function should be retried or not, e.g. a\n// network error would be retriable while a type error would stop the\n// function call.\nFunctionCall.prototype.retryIf = function (retryPredicate) {\n  precond.checkState(this.isPending(), 'FunctionCall in progress.');\n  this.retryPredicate_ = retryPredicate;\n  return this;\n};\n\n// Returns all intermediary results returned by the wrapped function since\n// the initial call.\nFunctionCall.prototype.getLastResult = function () {\n  return this.lastResult_.concat();\n};\n\n// Returns the number of times the wrapped function call was retried.\nFunctionCall.prototype.getNumRetries = function () {\n  return this.numRetries_;\n};\n\n// Sets the backoff limit.\nFunctionCall.prototype.failAfter = function (maxNumberOfRetry) {\n  precond.checkState(this.isPending(), 'FunctionCall in progress.');\n  this.failAfter_ = maxNumberOfRetry;\n  return this; // Return this for chaining.\n};\n\n// Aborts the call.\nFunctionCall.prototype.abort = function () {\n  if (this.isCompleted() || this.isAborted()) {\n    return;\n  }\n  if (this.isRunning()) {\n    this.backoff_.reset();\n  }\n  this.state_ = FunctionCall.State_.ABORTED;\n  this.lastResult_ = [new Error('Backoff aborted.')];\n  this.emit('abort');\n  this.doCallback_();\n};\n\n// Initiates the call to the wrapped function. Accepts an optional factory\n// function used to create the backoff instance; used when testing.\nFunctionCall.prototype.start = function (backoffFactory) {\n  precond.checkState(!this.isAborted(), 'FunctionCall is aborted.');\n  precond.checkState(this.isPending(), 'FunctionCall already started.');\n  var strategy = this.strategy_ || new FibonacciBackoffStrategy();\n  this.backoff_ = backoffFactory ? backoffFactory(strategy) : new Backoff(strategy);\n  this.backoff_.on('ready', this.doCall_.bind(this, true /* isRetry */));\n  this.backoff_.on('fail', this.doCallback_.bind(this));\n  this.backoff_.on('backoff', this.handleBackoff_.bind(this));\n  if (this.failAfter_ > 0) {\n    this.backoff_.failAfter(this.failAfter_);\n  }\n  this.state_ = FunctionCall.State_.RUNNING;\n  this.doCall_(false /* isRetry */);\n};\n\n// Calls the wrapped function.\nFunctionCall.prototype.doCall_ = function (isRetry) {\n  if (isRetry) {\n    this.numRetries_++;\n  }\n  var eventArgs = ['call'].concat(this.arguments_);\n  events.EventEmitter.prototype.emit.apply(this, eventArgs);\n  var callback = this.handleFunctionCallback_.bind(this);\n  this.function_.apply(null, this.arguments_.concat(callback));\n};\n\n// Calls the wrapped function's callback with the last result returned by the\n// wrapped function.\nFunctionCall.prototype.doCallback_ = function () {\n  this.callback_.apply(null, this.lastResult_);\n};\n\n// Handles wrapped function's completion. This method acts as a replacement\n// for the original callback function.\nFunctionCall.prototype.handleFunctionCallback_ = function () {\n  if (this.isAborted()) {\n    return;\n  }\n  var args = Array.prototype.slice.call(arguments);\n  this.lastResult_ = args; // Save last callback arguments.\n  events.EventEmitter.prototype.emit.apply(this, ['callback'].concat(args));\n  var err = args[0];\n  if (err && this.retryPredicate_(err)) {\n    this.backoff_.backoff(err);\n  } else {\n    this.state_ = FunctionCall.State_.COMPLETED;\n    this.doCallback_();\n  }\n};\n\n// Handles the backoff event by reemitting it.\nFunctionCall.prototype.handleBackoff_ = function (number, delay, err) {\n  this.emit('backoff', number, delay, err);\n};\nmodule.exports = FunctionCall;","map":{"version":3,"names":["events","require","precond","util","Backoff","FibonacciBackoffStrategy","FunctionCall","fn","args","callback","EventEmitter","call","checkIsFunction","checkIsArray","function_","arguments_","callback_","lastResult_","numRetries_","backoff_","strategy_","failAfter_","retryPredicate_","DEFAULT_RETRY_PREDICATE_","state_","State_","PENDING","inherits","RUNNING","COMPLETED","ABORTED","err","prototype","isPending","isRunning","isCompleted","isAborted","setStrategy","strategy","checkState","retryIf","retryPredicate","getLastResult","concat","getNumRetries","failAfter","maxNumberOfRetry","abort","reset","Error","emit","doCallback_","start","backoffFactory","on","doCall_","bind","handleBackoff_","isRetry","eventArgs","apply","handleFunctionCallback_","Array","slice","arguments","backoff","number","delay","module","exports"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/backoff/lib/function_call.js"],"sourcesContent":["//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar events = require('events');\nvar precond = require('precond');\nvar util = require('util');\n\nvar Backoff = require('./backoff');\nvar FibonacciBackoffStrategy = require('./strategy/fibonacci');\n\n// Wraps a function to be called in a backoff loop.\nfunction FunctionCall(fn, args, callback) {\n    events.EventEmitter.call(this);\n\n    precond.checkIsFunction(fn, 'Expected fn to be a function.');\n    precond.checkIsArray(args, 'Expected args to be an array.');\n    precond.checkIsFunction(callback, 'Expected callback to be a function.');\n\n    this.function_ = fn;\n    this.arguments_ = args;\n    this.callback_ = callback;\n    this.lastResult_ = [];\n    this.numRetries_ = 0;\n\n    this.backoff_ = null;\n    this.strategy_ = null;\n    this.failAfter_ = -1;\n    this.retryPredicate_ = FunctionCall.DEFAULT_RETRY_PREDICATE_;\n\n    this.state_ = FunctionCall.State_.PENDING;\n}\nutil.inherits(FunctionCall, events.EventEmitter);\n\n// States in which the call can be.\nFunctionCall.State_ = {\n    // Call isn't started yet.\n    PENDING: 0,\n    // Call is in progress.\n    RUNNING: 1,\n    // Call completed successfully which means that either the wrapped function\n    // returned successfully or the maximal number of backoffs was reached.\n    COMPLETED: 2,\n    // The call was aborted.\n    ABORTED: 3\n};\n\n// The default retry predicate which considers any error as retriable.\nFunctionCall.DEFAULT_RETRY_PREDICATE_ = function(err) {\n  return true;\n};\n\n// Checks whether the call is pending.\nFunctionCall.prototype.isPending = function() {\n    return this.state_ == FunctionCall.State_.PENDING;\n};\n\n// Checks whether the call is in progress.\nFunctionCall.prototype.isRunning = function() {\n    return this.state_ == FunctionCall.State_.RUNNING;\n};\n\n// Checks whether the call is completed.\nFunctionCall.prototype.isCompleted = function() {\n    return this.state_ == FunctionCall.State_.COMPLETED;\n};\n\n// Checks whether the call is aborted.\nFunctionCall.prototype.isAborted = function() {\n    return this.state_ == FunctionCall.State_.ABORTED;\n};\n\n// Sets the backoff strategy to use. Can only be called before the call is\n// started otherwise an exception will be thrown.\nFunctionCall.prototype.setStrategy = function(strategy) {\n    precond.checkState(this.isPending(), 'FunctionCall in progress.');\n    this.strategy_ = strategy;\n    return this; // Return this for chaining.\n};\n\n// Sets the predicate which will be used to determine whether the errors\n// returned from the wrapped function should be retried or not, e.g. a\n// network error would be retriable while a type error would stop the\n// function call.\nFunctionCall.prototype.retryIf = function(retryPredicate) {\n    precond.checkState(this.isPending(), 'FunctionCall in progress.');\n    this.retryPredicate_ = retryPredicate;\n    return this;\n};\n\n// Returns all intermediary results returned by the wrapped function since\n// the initial call.\nFunctionCall.prototype.getLastResult = function() {\n    return this.lastResult_.concat();\n};\n\n// Returns the number of times the wrapped function call was retried.\nFunctionCall.prototype.getNumRetries = function() {\n    return this.numRetries_;\n};\n\n// Sets the backoff limit.\nFunctionCall.prototype.failAfter = function(maxNumberOfRetry) {\n    precond.checkState(this.isPending(), 'FunctionCall in progress.');\n    this.failAfter_ = maxNumberOfRetry;\n    return this; // Return this for chaining.\n};\n\n// Aborts the call.\nFunctionCall.prototype.abort = function() {\n    if (this.isCompleted() || this.isAborted()) {\n      return;\n    }\n\n    if (this.isRunning()) {\n        this.backoff_.reset();\n    }\n\n    this.state_ = FunctionCall.State_.ABORTED;\n    this.lastResult_ = [new Error('Backoff aborted.')];\n    this.emit('abort');\n    this.doCallback_();\n};\n\n// Initiates the call to the wrapped function. Accepts an optional factory\n// function used to create the backoff instance; used when testing.\nFunctionCall.prototype.start = function(backoffFactory) {\n    precond.checkState(!this.isAborted(), 'FunctionCall is aborted.');\n    precond.checkState(this.isPending(), 'FunctionCall already started.');\n\n    var strategy = this.strategy_ || new FibonacciBackoffStrategy();\n\n    this.backoff_ = backoffFactory ?\n        backoffFactory(strategy) :\n        new Backoff(strategy);\n\n    this.backoff_.on('ready', this.doCall_.bind(this, true /* isRetry */));\n    this.backoff_.on('fail', this.doCallback_.bind(this));\n    this.backoff_.on('backoff', this.handleBackoff_.bind(this));\n\n    if (this.failAfter_ > 0) {\n        this.backoff_.failAfter(this.failAfter_);\n    }\n\n    this.state_ = FunctionCall.State_.RUNNING;\n    this.doCall_(false /* isRetry */);\n};\n\n// Calls the wrapped function.\nFunctionCall.prototype.doCall_ = function(isRetry) {\n    if (isRetry) {\n        this.numRetries_++;\n    }\n    var eventArgs = ['call'].concat(this.arguments_);\n    events.EventEmitter.prototype.emit.apply(this, eventArgs);\n    var callback = this.handleFunctionCallback_.bind(this);\n    this.function_.apply(null, this.arguments_.concat(callback));\n};\n\n// Calls the wrapped function's callback with the last result returned by the\n// wrapped function.\nFunctionCall.prototype.doCallback_ = function() {\n    this.callback_.apply(null, this.lastResult_);\n};\n\n// Handles wrapped function's completion. This method acts as a replacement\n// for the original callback function.\nFunctionCall.prototype.handleFunctionCallback_ = function() {\n    if (this.isAborted()) {\n        return;\n    }\n\n    var args = Array.prototype.slice.call(arguments);\n    this.lastResult_ = args; // Save last callback arguments.\n    events.EventEmitter.prototype.emit.apply(this, ['callback'].concat(args));\n\n    var err = args[0];\n    if (err && this.retryPredicate_(err)) {\n        this.backoff_.backoff(err);\n    } else {\n        this.state_ = FunctionCall.State_.COMPLETED;\n        this.doCallback_();\n    }\n};\n\n// Handles the backoff event by reemitting it.\nFunctionCall.prototype.handleBackoff_ = function(number, delay, err) {\n    this.emit('backoff', number, delay, err);\n};\n\nmodule.exports = FunctionCall;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}