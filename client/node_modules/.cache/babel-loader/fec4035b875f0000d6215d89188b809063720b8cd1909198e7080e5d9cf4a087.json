{"ast":null,"code":"var __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n  return r;\n};\n/* eslint-disable no-fallthrough */\nvar _a = require('../errors'),\n  NotSupportedError = _a.NotSupportedError,\n  InvalidArgumentError = _a.InvalidArgumentError;\nvar MockRTCStatsReport = require('./mockrtcstatsreport');\nvar ERROR_PEER_CONNECTION_NULL = 'PeerConnection is null';\nvar ERROR_WEB_RTC_UNSUPPORTED = 'WebRTC statistics are unsupported';\n/**\n * Helper function to find a specific stat from a report.\n * Some environment provide the stats report as a map (regular browsers)\n * but some provide stats report as an array (citrix vdi)\n * @private\n */\nfunction findStatById(report, id) {\n  if (typeof report.get === 'function') {\n    return report.get(id);\n  }\n  return report.find(function (s) {\n    return s.id === id;\n  });\n}\n/**\n * Generate WebRTC statistics report for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCStatsReport>} WebRTC RTCStatsReport object\n */\nfunction getRTCStatsReport(peerConnection) {\n  if (!peerConnection) {\n    return Promise.reject(new InvalidArgumentError(ERROR_PEER_CONNECTION_NULL));\n  }\n  if (typeof peerConnection.getStats !== 'function') {\n    return Promise.reject(new NotSupportedError(ERROR_WEB_RTC_UNSUPPORTED));\n  }\n  var promise;\n  try {\n    promise = peerConnection.getStats();\n  } catch (e) {\n    promise = new Promise(function (resolve) {\n      return peerConnection.getStats(resolve);\n    }).then(MockRTCStatsReport.fromRTCStatsResponse);\n  }\n  return promise;\n}\n/**\n * @typedef {Object} StatsOptions\n * Used for testing to inject and extract methods.\n * @property {function} [createRTCSample] - Method for parsing an RTCStatsReport\n */\n/**\n * Collects any WebRTC statistics for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @param {StatsOptions} options - List of custom options.\n * @return {Promise<RTCSample>} Universally-formatted version of RTC stats.\n */\nfunction getRTCStats(peerConnection, options) {\n  options = Object.assign({\n    createRTCSample: createRTCSample\n  }, options);\n  return getRTCStatsReport(peerConnection).then(options.createRTCSample);\n}\n/**\n * Generate WebRTC stats report containing relevant information about ICE candidates for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCIceCandidateStatsReport>} RTCIceCandidateStatsReport object\n */\nfunction getRTCIceCandidateStatsReport(peerConnection) {\n  return getRTCStatsReport(peerConnection).then(function (report) {\n    // Find the relevant information needed to determine selected candidates later\n    var _a = Array.from(report.values()).reduce(function (rval, stat) {\n        ['candidatePairs', 'localCandidates', 'remoteCandidates'].forEach(function (prop) {\n          if (!rval[prop]) {\n            rval[prop] = [];\n          }\n        });\n        switch (stat.type) {\n          case 'candidate-pair':\n            rval.candidatePairs.push(stat);\n            break;\n          case 'local-candidate':\n            rval.localCandidates.push(stat);\n            break;\n          case 'remote-candidate':\n            rval.remoteCandidates.push(stat);\n            break;\n          case 'transport':\n            // This transport is the one being used if selectedCandidatePairId is populated\n            if (stat.selectedCandidatePairId) {\n              rval.transport = stat;\n            }\n            break;\n        }\n        return rval;\n      }, {}),\n      candidatePairs = _a.candidatePairs,\n      localCandidates = _a.localCandidates,\n      remoteCandidates = _a.remoteCandidates,\n      transport = _a.transport;\n    // This is a report containing information about the selected candidates, such as IDs\n    // This is coming from WebRTC stats directly and doesn't contain the actual ICE Candidates info\n    var selectedCandidatePairReport = candidatePairs.find(function (pair) {\n      // Firefox\n      return pair.selected ||\n      // Spec-compliant way\n      transport && pair.id === transport.selectedCandidatePairId;\n    });\n    var selectedIceCandidatePairStats;\n    if (selectedCandidatePairReport) {\n      selectedIceCandidatePairStats = {\n        localCandidate: localCandidates.find(function (candidate) {\n          return candidate.id === selectedCandidatePairReport.localCandidateId;\n        }),\n        remoteCandidate: remoteCandidates.find(function (candidate) {\n          return candidate.id === selectedCandidatePairReport.remoteCandidateId;\n        })\n      };\n    }\n    // Build the return object\n    return {\n      iceCandidateStats: __spreadArrays(localCandidates, remoteCandidates),\n      selectedIceCandidatePairStats: selectedIceCandidatePairStats\n    };\n  });\n}\n/**\n * @typedef {Object} RTCSample - A sample containing relevant WebRTC stats information.\n * @property {Number} [timestamp]\n * @property {String} [codecName] - MimeType name of the codec being used by the outbound audio stream\n * @property {Number} [rtt] - Round trip time\n * @property {Number} [jitter]\n * @property {Number} [packetsSent]\n * @property {Number} [packetsLost]\n * @property {Number} [packetsReceived]\n * @property {Number} [bytesReceived]\n * @property {Number} [bytesSent]\n * @property {Number} [localAddress]\n * @property {Number} [remoteAddress]\n */\nfunction RTCSample() {}\n/**\n * Create an RTCSample object from an RTCStatsReport\n * @private\n * @param {RTCStatsReport} statsReport\n * @returns {RTCSample}\n */\nfunction createRTCSample(statsReport) {\n  var activeTransportId = null;\n  var sample = new RTCSample();\n  var fallbackTimestamp;\n  Array.from(statsReport.values()).forEach(function (stats) {\n    // Skip isRemote tracks which will be phased out completely and break in FF66.\n    if (stats.isRemote) {\n      return;\n    }\n    // Firefox hack -- Older firefox doesn't have dashes in type names\n    var type = stats.type.replace('-', '');\n    fallbackTimestamp = fallbackTimestamp || stats.timestamp;\n    // (rrowland) As I understand it, this is supposed to come in on remote-inbound-rtp but it's\n    // currently coming in on remote-outbound-rtp, so I'm leaving this outside the switch until\n    // the appropriate place to look is cleared up.\n    if (stats.remoteId) {\n      var remote = findStatById(statsReport, stats.remoteId);\n      if (remote && remote.roundTripTime) {\n        sample.rtt = remote.roundTripTime * 1000;\n      }\n    }\n    switch (type) {\n      case 'inboundrtp':\n        sample.timestamp = sample.timestamp || stats.timestamp;\n        sample.jitter = stats.jitter * 1000;\n        sample.packetsLost = stats.packetsLost;\n        sample.packetsReceived = stats.packetsReceived;\n        sample.bytesReceived = stats.bytesReceived;\n        break;\n      case 'outboundrtp':\n        sample.timestamp = stats.timestamp;\n        sample.packetsSent = stats.packetsSent;\n        sample.bytesSent = stats.bytesSent;\n        if (stats.codecId) {\n          var codec = findStatById(statsReport, stats.codecId);\n          sample.codecName = codec ? codec.mimeType && codec.mimeType.match(/(.*\\/)?(.*)/)[2] : stats.codecId;\n        }\n        break;\n      case 'transport':\n        activeTransportId = stats.id;\n        break;\n    }\n  });\n  if (!sample.timestamp) {\n    sample.timestamp = fallbackTimestamp;\n  }\n  var activeTransport = findStatById(statsReport, activeTransportId);\n  if (!activeTransport) {\n    return sample;\n  }\n  var selectedCandidatePair = findStatById(statsReport, activeTransport.selectedCandidatePairId);\n  if (!selectedCandidatePair) {\n    return sample;\n  }\n  var localCandidate = findStatById(statsReport, selectedCandidatePair.localCandidateId);\n  var remoteCandidate = findStatById(statsReport, selectedCandidatePair.remoteCandidateId);\n  if (!sample.rtt) {\n    sample.rtt = selectedCandidatePair && selectedCandidatePair.currentRoundTripTime * 1000;\n  }\n  Object.assign(sample, {\n    localAddress: localCandidate && localCandidate.ip,\n    remoteAddress: remoteCandidate && remoteCandidate.ip\n  });\n  return sample;\n}\nmodule.exports = {\n  getRTCStats: getRTCStats,\n  getRTCIceCandidateStatsReport: getRTCIceCandidateStatsReport\n};","map":{"version":3,"names":["_a","require","NotSupportedError","InvalidArgumentError","MockRTCStatsReport","ERROR_PEER_CONNECTION_NULL","ERROR_WEB_RTC_UNSUPPORTED","findStatById","report","id","get","find","s","getRTCStatsReport","peerConnection","Promise","reject","getStats","promise","e","resolve","then","fromRTCStatsResponse","getRTCStats","options","Object","assign","createRTCSample","getRTCIceCandidateStatsReport","Array","from","values","reduce","rval","stat","candidatePairs","localCandidates","remoteCandidates","transport","selectedCandidatePairReport","pair","selected","selectedCandidatePairId","selectedIceCandidatePairStats","localCandidate","candidate","localCandidateId","remoteCandidate","remoteCandidateId","iceCandidateStats","__spreadArrays","RTCSample","statsReport","activeTransportId","sample","fallbackTimestamp","forEach","stats","isRemote","type","replace","timestamp","remoteId","remote","roundTripTime","rtt","jitter","packetsLost","packetsReceived","bytesReceived","packetsSent","bytesSent","codecId","codec","codecName","mimeType","match","activeTransport","selectedCandidatePair","currentRoundTripTime","localAddress","ip","remoteAddress","module","exports"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/twilio-client/lib/twilio/rtc/stats.js"],"sourcesContent":["/* eslint-disable no-fallthrough */\nconst { NotSupportedError, InvalidArgumentError } = require('../errors');\nconst MockRTCStatsReport = require('./mockrtcstatsreport');\n\nconst ERROR_PEER_CONNECTION_NULL = 'PeerConnection is null';\nconst ERROR_WEB_RTC_UNSUPPORTED = 'WebRTC statistics are unsupported';\n\n/**\n * Helper function to find a specific stat from a report.\n * Some environment provide the stats report as a map (regular browsers)\n * but some provide stats report as an array (citrix vdi)\n * @private\n */\nfunction findStatById(report, id) {\n  if (typeof report.get === 'function') {\n    return report.get(id);\n  }\n  return report.find(s => s.id === id);\n}\n\n/**\n * Generate WebRTC statistics report for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCStatsReport>} WebRTC RTCStatsReport object\n */\nfunction getRTCStatsReport(peerConnection) {\n  if (!peerConnection) {\n    return Promise.reject(new InvalidArgumentError(ERROR_PEER_CONNECTION_NULL));\n  }\n\n  if (typeof peerConnection.getStats !== 'function') {\n    return Promise.reject(new NotSupportedError(ERROR_WEB_RTC_UNSUPPORTED));\n  }\n\n  let promise;\n  try {\n    promise = peerConnection.getStats();\n  } catch (e) {\n    promise = new Promise(resolve => peerConnection.getStats(resolve)).then(MockRTCStatsReport.fromRTCStatsResponse);\n  }\n\n  return promise;\n}\n\n/**\n * @typedef {Object} StatsOptions\n * Used for testing to inject and extract methods.\n * @property {function} [createRTCSample] - Method for parsing an RTCStatsReport\n */\n/**\n * Collects any WebRTC statistics for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @param {StatsOptions} options - List of custom options.\n * @return {Promise<RTCSample>} Universally-formatted version of RTC stats.\n */\nfunction getRTCStats(peerConnection, options) {\n  options = Object.assign({\n    createRTCSample\n  }, options);\n\n  return getRTCStatsReport(peerConnection).then(options.createRTCSample);\n}\n\n/**\n * Generate WebRTC stats report containing relevant information about ICE candidates for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCIceCandidateStatsReport>} RTCIceCandidateStatsReport object\n */\nfunction getRTCIceCandidateStatsReport(peerConnection) {\n  return getRTCStatsReport(peerConnection).then((report) => {\n    // Find the relevant information needed to determine selected candidates later\n    const {\n      candidatePairs, localCandidates, remoteCandidates, transport,\n    } = Array.from(report.values()).reduce((rval, stat) => {\n      ['candidatePairs', 'localCandidates', 'remoteCandidates'].forEach((prop) => {\n        if (!rval[prop]) {\n          rval[prop] = [];\n        }\n      });\n\n      switch (stat.type) {\n        case 'candidate-pair':\n          rval.candidatePairs.push(stat);\n          break;\n        case 'local-candidate':\n          rval.localCandidates.push(stat);\n          break;\n        case 'remote-candidate':\n          rval.remoteCandidates.push(stat);\n          break;\n        case 'transport':\n          // This transport is the one being used if selectedCandidatePairId is populated\n          if (stat.selectedCandidatePairId) {\n            rval.transport = stat;\n          }\n          break;\n      }\n\n      return rval;\n    }, {});\n\n    // This is a report containing information about the selected candidates, such as IDs\n    // This is coming from WebRTC stats directly and doesn't contain the actual ICE Candidates info\n    const selectedCandidatePairReport = candidatePairs.find(pair =>\n      // Firefox\n      pair.selected ||\n      // Spec-compliant way\n      (transport && pair.id === transport.selectedCandidatePairId)\n    );\n\n    let selectedIceCandidatePairStats;\n    if (selectedCandidatePairReport) {\n      selectedIceCandidatePairStats = {\n        localCandidate: localCandidates.find(candidate => candidate.id === selectedCandidatePairReport.localCandidateId),\n        remoteCandidate: remoteCandidates.find(candidate => candidate.id === selectedCandidatePairReport.remoteCandidateId),\n      };\n    }\n\n    // Build the return object\n    return {\n      iceCandidateStats: [...localCandidates, ...remoteCandidates],\n      selectedIceCandidatePairStats,\n    };\n  });\n}\n\n/**\n * @typedef {Object} RTCSample - A sample containing relevant WebRTC stats information.\n * @property {Number} [timestamp]\n * @property {String} [codecName] - MimeType name of the codec being used by the outbound audio stream\n * @property {Number} [rtt] - Round trip time\n * @property {Number} [jitter]\n * @property {Number} [packetsSent]\n * @property {Number} [packetsLost]\n * @property {Number} [packetsReceived]\n * @property {Number} [bytesReceived]\n * @property {Number} [bytesSent]\n * @property {Number} [localAddress]\n * @property {Number} [remoteAddress]\n */\nfunction RTCSample() { }\n\n/**\n * Create an RTCSample object from an RTCStatsReport\n * @private\n * @param {RTCStatsReport} statsReport\n * @returns {RTCSample}\n */\nfunction createRTCSample(statsReport) {\n  let activeTransportId = null;\n  const sample = new RTCSample();\n  let fallbackTimestamp;\n\n  Array.from(statsReport.values()).forEach(stats => {\n    // Skip isRemote tracks which will be phased out completely and break in FF66.\n    if (stats.isRemote) { return; }\n\n    // Firefox hack -- Older firefox doesn't have dashes in type names\n    const type = stats.type.replace('-', '');\n\n    fallbackTimestamp = fallbackTimestamp || stats.timestamp;\n\n    // (rrowland) As I understand it, this is supposed to come in on remote-inbound-rtp but it's\n    // currently coming in on remote-outbound-rtp, so I'm leaving this outside the switch until\n    // the appropriate place to look is cleared up.\n    if (stats.remoteId) {\n      const remote = findStatById(statsReport, stats.remoteId);\n      if (remote && remote.roundTripTime) {\n        sample.rtt = remote.roundTripTime * 1000;\n      }\n    }\n\n    switch (type) {\n      case 'inboundrtp':\n        sample.timestamp = sample.timestamp || stats.timestamp;\n        sample.jitter = stats.jitter * 1000;\n        sample.packetsLost = stats.packetsLost;\n        sample.packetsReceived = stats.packetsReceived;\n        sample.bytesReceived = stats.bytesReceived;\n\n        break;\n      case 'outboundrtp':\n        sample.timestamp = stats.timestamp;\n        sample.packetsSent = stats.packetsSent;\n        sample.bytesSent = stats.bytesSent;\n\n        if (stats.codecId) {\n          const codec = findStatById(statsReport, stats.codecId);\n          sample.codecName = codec\n            ? codec.mimeType && codec.mimeType.match(/(.*\\/)?(.*)/)[2]\n            : stats.codecId;\n        }\n\n        break;\n      case 'transport':\n        activeTransportId = stats.id;\n        break;\n    }\n  });\n\n  if (!sample.timestamp) {\n    sample.timestamp = fallbackTimestamp;\n  }\n\n  const activeTransport = findStatById(statsReport, activeTransportId);\n  if (!activeTransport) { return sample; }\n\n  const selectedCandidatePair = findStatById(statsReport, activeTransport.selectedCandidatePairId);\n  if (!selectedCandidatePair) { return sample; }\n\n  const localCandidate = findStatById(statsReport, selectedCandidatePair.localCandidateId);\n  const remoteCandidate = findStatById(statsReport, selectedCandidatePair.remoteCandidateId);\n\n  if (!sample.rtt) {\n    sample.rtt = selectedCandidatePair &&\n      (selectedCandidatePair.currentRoundTripTime * 1000);\n  }\n\n  Object.assign(sample, {\n    localAddress: localCandidate && localCandidate.ip,\n    remoteAddress: remoteCandidate && remoteCandidate.ip,\n  });\n\n  return sample;\n}\n\nmodule.exports = {\n  getRTCStats,\n  getRTCIceCandidateStatsReport,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}