{"ast":null,"code":"//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar events = require('events');\nvar util = require('util');\nfunction isDef(value) {\n  return value !== undefined && value !== null;\n}\n\n// Abstract class defining the skeleton for the backoff strategies. Accepts an\n// object holding the options for the backoff strategy:\n//\n//  * `randomisationFactor`: The randomisation factor which must be between 0\n//     and 1 where 1 equates to a randomization factor of 100% and 0 to no\n//     randomization.\n//  * `initialDelay`: The backoff initial delay in milliseconds.\n//  * `maxDelay`: The backoff maximal delay in milliseconds.\nfunction BackoffStrategy(options) {\n  options = options || {};\n  if (isDef(options.initialDelay) && options.initialDelay < 1) {\n    throw new Error('The initial timeout must be greater than 0.');\n  } else if (isDef(options.maxDelay) && options.maxDelay < 1) {\n    throw new Error('The maximal timeout must be greater than 0.');\n  }\n  this.initialDelay_ = options.initialDelay || 100;\n  this.maxDelay_ = options.maxDelay || 10000;\n  if (this.maxDelay_ <= this.initialDelay_) {\n    throw new Error('The maximal backoff delay must be ' + 'greater than the initial backoff delay.');\n  }\n  if (isDef(options.randomisationFactor) && (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {\n    throw new Error('The randomisation factor must be between 0 and 1.');\n  }\n  this.randomisationFactor_ = options.randomisationFactor || 0;\n}\n\n// Gets the maximal backoff delay.\nBackoffStrategy.prototype.getMaxDelay = function () {\n  return this.maxDelay_;\n};\n\n// Gets the initial backoff delay.\nBackoffStrategy.prototype.getInitialDelay = function () {\n  return this.initialDelay_;\n};\n\n// Template method that computes and returns the next backoff delay in\n// milliseconds.\nBackoffStrategy.prototype.next = function () {\n  var backoffDelay = this.next_();\n  var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;\n  var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);\n  return randomizedDelay;\n};\n\n// Computes and returns the next backoff delay. Intended to be overridden by\n// subclasses.\nBackoffStrategy.prototype.next_ = function () {\n  throw new Error('BackoffStrategy.next_() unimplemented.');\n};\n\n// Template method that resets the backoff delay to its initial value.\nBackoffStrategy.prototype.reset = function () {\n  this.reset_();\n};\n\n// Resets the backoff delay to its initial value. Intended to be overridden by\n// subclasses.\nBackoffStrategy.prototype.reset_ = function () {\n  throw new Error('BackoffStrategy.reset_() unimplemented.');\n};\nmodule.exports = BackoffStrategy;","map":{"version":3,"names":["events","require","util","isDef","value","undefined","BackoffStrategy","options","initialDelay","Error","maxDelay","initialDelay_","maxDelay_","randomisationFactor","randomisationFactor_","prototype","getMaxDelay","getInitialDelay","next","backoffDelay","next_","randomisationMultiple","Math","random","randomizedDelay","round","reset","reset_","module","exports"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/backoff/lib/strategy/strategy.js"],"sourcesContent":["//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar events = require('events');\nvar util = require('util');\n\nfunction isDef(value) {\n    return value !== undefined && value !== null;\n}\n\n// Abstract class defining the skeleton for the backoff strategies. Accepts an\n// object holding the options for the backoff strategy:\n//\n//  * `randomisationFactor`: The randomisation factor which must be between 0\n//     and 1 where 1 equates to a randomization factor of 100% and 0 to no\n//     randomization.\n//  * `initialDelay`: The backoff initial delay in milliseconds.\n//  * `maxDelay`: The backoff maximal delay in milliseconds.\nfunction BackoffStrategy(options) {\n    options = options || {};\n\n    if (isDef(options.initialDelay) && options.initialDelay < 1) {\n        throw new Error('The initial timeout must be greater than 0.');\n    } else if (isDef(options.maxDelay) && options.maxDelay < 1) {\n        throw new Error('The maximal timeout must be greater than 0.');\n    }\n\n    this.initialDelay_ = options.initialDelay || 100;\n    this.maxDelay_ = options.maxDelay || 10000;\n\n    if (this.maxDelay_ <= this.initialDelay_) {\n        throw new Error('The maximal backoff delay must be ' +\n                        'greater than the initial backoff delay.');\n    }\n\n    if (isDef(options.randomisationFactor) &&\n        (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {\n        throw new Error('The randomisation factor must be between 0 and 1.');\n    }\n\n    this.randomisationFactor_ = options.randomisationFactor || 0;\n}\n\n// Gets the maximal backoff delay.\nBackoffStrategy.prototype.getMaxDelay = function() {\n    return this.maxDelay_;\n};\n\n// Gets the initial backoff delay.\nBackoffStrategy.prototype.getInitialDelay = function() {\n    return this.initialDelay_;\n};\n\n// Template method that computes and returns the next backoff delay in\n// milliseconds.\nBackoffStrategy.prototype.next = function() {\n    var backoffDelay = this.next_();\n    var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;\n    var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);\n    return randomizedDelay;\n};\n\n// Computes and returns the next backoff delay. Intended to be overridden by\n// subclasses.\nBackoffStrategy.prototype.next_ = function() {\n    throw new Error('BackoffStrategy.next_() unimplemented.');\n};\n\n// Template method that resets the backoff delay to its initial value.\nBackoffStrategy.prototype.reset = function() {\n    this.reset_();\n};\n\n// Resets the backoff delay to its initial value. Intended to be overridden by\n// subclasses.\nBackoffStrategy.prototype.reset_ = function() {\n    throw new Error('BackoffStrategy.reset_() unimplemented.');\n};\n\nmodule.exports = BackoffStrategy;\n"],"mappings":"AAAA;AACA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAC9B,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAE1B,SAASE,KAAKA,CAACC,KAAK,EAAE;EAClB,OAAOA,KAAK,KAAKC,SAAS,IAAID,KAAK,KAAK,IAAI;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,eAAeA,CAACC,OAAO,EAAE;EAC9BA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAEvB,IAAIJ,KAAK,CAACI,OAAO,CAACC,YAAY,CAAC,IAAID,OAAO,CAACC,YAAY,GAAG,CAAC,EAAE;IACzD,MAAM,IAAIC,KAAK,CAAC,6CAA6C,CAAC;EAClE,CAAC,MAAM,IAAIN,KAAK,CAACI,OAAO,CAACG,QAAQ,CAAC,IAAIH,OAAO,CAACG,QAAQ,GAAG,CAAC,EAAE;IACxD,MAAM,IAAID,KAAK,CAAC,6CAA6C,CAAC;EAClE;EAEA,IAAI,CAACE,aAAa,GAAGJ,OAAO,CAACC,YAAY,IAAI,GAAG;EAChD,IAAI,CAACI,SAAS,GAAGL,OAAO,CAACG,QAAQ,IAAI,KAAK;EAE1C,IAAI,IAAI,CAACE,SAAS,IAAI,IAAI,CAACD,aAAa,EAAE;IACtC,MAAM,IAAIF,KAAK,CAAC,oCAAoC,GACpC,yCAAyC,CAAC;EAC9D;EAEA,IAAIN,KAAK,CAACI,OAAO,CAACM,mBAAmB,CAAC,KACjCN,OAAO,CAACM,mBAAmB,GAAG,CAAC,IAAIN,OAAO,CAACM,mBAAmB,GAAG,CAAC,CAAC,EAAE;IACtE,MAAM,IAAIJ,KAAK,CAAC,mDAAmD,CAAC;EACxE;EAEA,IAAI,CAACK,oBAAoB,GAAGP,OAAO,CAACM,mBAAmB,IAAI,CAAC;AAChE;;AAEA;AACAP,eAAe,CAACS,SAAS,CAACC,WAAW,GAAG,YAAW;EAC/C,OAAO,IAAI,CAACJ,SAAS;AACzB,CAAC;;AAED;AACAN,eAAe,CAACS,SAAS,CAACE,eAAe,GAAG,YAAW;EACnD,OAAO,IAAI,CAACN,aAAa;AAC7B,CAAC;;AAED;AACA;AACAL,eAAe,CAACS,SAAS,CAACG,IAAI,GAAG,YAAW;EACxC,IAAIC,YAAY,GAAG,IAAI,CAACC,KAAK,CAAC,CAAC;EAC/B,IAAIC,qBAAqB,GAAG,CAAC,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,IAAI,CAACT,oBAAoB;EACzE,IAAIU,eAAe,GAAGF,IAAI,CAACG,KAAK,CAACN,YAAY,GAAGE,qBAAqB,CAAC;EACtE,OAAOG,eAAe;AAC1B,CAAC;;AAED;AACA;AACAlB,eAAe,CAACS,SAAS,CAACK,KAAK,GAAG,YAAW;EACzC,MAAM,IAAIX,KAAK,CAAC,wCAAwC,CAAC;AAC7D,CAAC;;AAED;AACAH,eAAe,CAACS,SAAS,CAACW,KAAK,GAAG,YAAW;EACzC,IAAI,CAACC,MAAM,CAAC,CAAC;AACjB,CAAC;;AAED;AACA;AACArB,eAAe,CAACS,SAAS,CAACY,MAAM,GAAG,YAAW;EAC1C,MAAM,IAAIlB,KAAK,CAAC,yCAAyC,CAAC;AAC9D,CAAC;AAEDmB,MAAM,CAACC,OAAO,GAAGvB,eAAe"},"metadata":{},"sourceType":"script","externalDependencies":[]}