{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n * @publicapi\n * @internal\n */\nvar events_1 = require(\"events\");\nvar backoff_1 = require(\"./backoff\");\nvar device_1 = require(\"./device\");\nvar errors_1 = require(\"./errors\");\nvar log_1 = require(\"./log\");\nvar rtc_1 = require(\"./rtc\");\nvar icecandidate_1 = require(\"./rtc/icecandidate\");\nvar sdp_1 = require(\"./rtc/sdp\");\nvar statsMonitor_1 = require(\"./statsMonitor\");\nvar util_1 = require(\"./util\");\nvar uuid_1 = require(\"./uuid\");\nvar RELEASE_VERSION = require('./constants').RELEASE_VERSION;\nvar BACKOFF_CONFIG = {\n  factor: 1.1,\n  jitter: 0.5,\n  max: 30000,\n  min: 1\n};\nvar DTMF_INTER_TONE_GAP = 70;\nvar DTMF_PAUSE_DURATION = 500;\nvar DTMF_TONE_DURATION = 160;\nvar METRICS_BATCH_SIZE = 10;\nvar METRICS_DELAY = 5000;\nvar MEDIA_DISCONNECT_ERROR = {\n  disconnect: true,\n  info: {\n    code: 31003,\n    message: 'Connection with Twilio was interrupted.',\n    twilioError: new errors_1.MediaErrors.ConnectionError()\n  }\n};\nvar MULTIPLE_THRESHOLD_WARNING_NAMES = {\n  // The stat `packetsLostFraction` is monitored by two separate thresholds,\n  // `maxAverage` and `max`. Each threshold emits a different warning name.\n  packetsLostFraction: {\n    max: 'packet-loss',\n    maxAverage: 'packets-lost-fraction'\n  }\n};\nvar WARNING_NAMES = {\n  audioInputLevel: 'audio-input-level',\n  audioOutputLevel: 'audio-output-level',\n  bytesReceived: 'bytes-received',\n  bytesSent: 'bytes-sent',\n  jitter: 'jitter',\n  mos: 'mos',\n  rtt: 'rtt'\n};\nvar WARNING_PREFIXES = {\n  max: 'high-',\n  maxAverage: 'high-',\n  maxDuration: 'constant-',\n  min: 'low-',\n  minStandardDeviation: 'constant-'\n};\n/**\n * A {@link Call} represents a media and signaling connection to a TwiML application.\n * @publicapi\n */\nvar Call = /** @class */function (_super) {\n  __extends(Call, _super);\n  /**\n   * @constructor\n   * @private\n   * @param config - Mandatory configuration options\n   * @param [options] - Optional settings\n   */\n  function Call(config, options) {\n    var _this = _super.call(this) || this;\n    /**\n     * Call parameters received from Twilio for an incoming call.\n     */\n    _this.parameters = {};\n    /**\n     * The number of times input volume has been the same consecutively.\n     */\n    _this._inputVolumeStreak = 0;\n    /**\n     * Whether the call has been answered.\n     */\n    _this._isAnswered = false;\n    /**\n     * Whether the call has been cancelled.\n     */\n    _this._isCancelled = false;\n    /**\n     * Whether the call has been rejected\n     */\n    _this._isRejected = false;\n    /**\n     * The most recent public input volume value. 0 -> 1 representing -100 to -30 dB.\n     */\n    _this._latestInputVolume = 0;\n    /**\n     * The most recent public output volume value. 0 -> 1 representing -100 to -30 dB.\n     */\n    _this._latestOutputVolume = 0;\n    /**\n     * An instance of Logger to use.\n     */\n    _this._log = log_1.default.getInstance();\n    /**\n     * State of the {@link Call}'s media.\n     */\n    _this._mediaStatus = Call.State.Pending;\n    /**\n     * A map of messages sent via sendMessage API using voiceEventSid as the key.\n     * The message will be deleted once an 'ack' or an error is received from the server.\n     */\n    _this._messages = new Map();\n    /**\n     * A batch of metrics samples to send to Insights. Gets cleared after\n     * each send and appended to on each new sample.\n     */\n    _this._metricsSamples = [];\n    /**\n     * Options passed to this {@link Call}.\n     */\n    _this._options = {\n      MediaHandler: rtc_1.PeerConnection,\n      offerSdp: null,\n      shouldPlayDisconnect: function () {\n        return true;\n      },\n      voiceEventSidGenerator: uuid_1.generateVoiceEventSid\n    };\n    /**\n     * The number of times output volume has been the same consecutively.\n     */\n    _this._outputVolumeStreak = 0;\n    /**\n     * Whether the {@link Call} should send a hangup on disconnect.\n     */\n    _this._shouldSendHangup = true;\n    /**\n     * State of the {@link Call}'s signaling.\n     */\n    _this._signalingStatus = Call.State.Pending;\n    /**\n     * A Map of Sounds to play.\n     */\n    _this._soundcache = new Map();\n    /**\n     * State of the {@link Call}.\n     */\n    _this._status = Call.State.Pending;\n    /**\n     * Whether the {@link Call} has been connected. Used to determine if we are reconnected.\n     */\n    _this._wasConnected = false;\n    /**\n     * String representation of {@link Call} instance.\n     * @private\n     */\n    _this.toString = function () {\n      return '[Twilio.Call instance]';\n    };\n    _this._emitWarning = function (groupPrefix, warningName, threshold, value, wasCleared, warningData) {\n      var groupSuffix = wasCleared ? '-cleared' : '-raised';\n      var groupName = groupPrefix + \"warning\" + groupSuffix;\n      // Ignore constant input if the Call is muted (Expected)\n      if (warningName === 'constant-audio-input-level' && _this.isMuted()) {\n        return;\n      }\n      var level = wasCleared ? 'info' : 'warning';\n      // Avoid throwing false positives as warnings until we refactor volume metrics\n      if (warningName === 'constant-audio-output-level') {\n        level = 'info';\n      }\n      var payloadData = {\n        threshold: threshold\n      };\n      if (value) {\n        if (value instanceof Array) {\n          payloadData.values = value.map(function (val) {\n            if (typeof val === 'number') {\n              return Math.round(val * 100) / 100;\n            }\n            return value;\n          });\n        } else {\n          payloadData.value = value;\n        }\n      }\n      _this._publisher.post(level, groupName, warningName, {\n        data: payloadData\n      }, _this);\n      if (warningName !== 'constant-audio-output-level') {\n        var emitName = wasCleared ? 'warning-cleared' : 'warning';\n        _this.emit(emitName, warningName, warningData && !wasCleared ? warningData : null);\n      }\n    };\n    /**\n     * Called when the {@link Call} receives an ack from signaling\n     * @param payload\n     */\n    _this._onAck = function (payload) {\n      var acktype = payload.acktype,\n        callsid = payload.callsid,\n        voiceeventsid = payload.voiceeventsid;\n      if (_this.parameters.CallSid !== callsid) {\n        _this._log.warn(\"Received ack from a different callsid: \" + callsid);\n        return;\n      }\n      if (acktype === 'message') {\n        _this._onMessageSent(voiceeventsid);\n      }\n    };\n    /**\n     * Called when the {@link Call} is answered.\n     * @param payload\n     */\n    _this._onAnswer = function (payload) {\n      if (typeof payload.reconnect === 'string') {\n        _this._signalingReconnectToken = payload.reconnect;\n      }\n      // answerOnBridge=false will send a 183 which we need to catch in _onRinging when\n      // the enableRingingState flag is disabled. In that case, we will receive a 200 after\n      // the callee accepts the call firing a second `accept` event if we don't\n      // short circuit here.\n      if (_this._isAnswered && _this._status !== Call.State.Reconnecting) {\n        return;\n      }\n      _this._setCallSid(payload);\n      _this._isAnswered = true;\n      _this._maybeTransitionToOpen();\n    };\n    /**\n     * Called when the {@link Call} is cancelled.\n     * @param payload\n     */\n    _this._onCancel = function (payload) {\n      // (rrowland) Is this check necessary? Verify, and if so move to pstream / VSP module.\n      var callsid = payload.callsid;\n      if (_this.parameters.CallSid === callsid) {\n        _this._isCancelled = true;\n        _this._publisher.info('connection', 'cancel', null, _this);\n        _this._cleanupEventListeners();\n        _this._mediaHandler.close();\n        _this._status = Call.State.Closed;\n        _this.emit('cancel');\n        _this._pstream.removeListener('cancel', _this._onCancel);\n      }\n    };\n    /**\n     * Called when we receive a connected event from pstream.\n     * Re-emits the event.\n     */\n    _this._onConnected = function () {\n      _this._log.info('Received connected from pstream');\n      if (_this._signalingReconnectToken) {\n        _this._pstream.reconnect(_this._mediaHandler.version.getSDP(), _this.parameters.CallSid, _this._signalingReconnectToken);\n      }\n    };\n    /**\n     * Called when the {@link Call} is hung up.\n     * @param payload\n     */\n    _this._onHangup = function (payload) {\n      if (_this.status() === Call.State.Closed) {\n        return;\n      }\n      /**\n       *  see if callsid passed in message matches either callsid or outbound id\n       *  call should always have either callsid or outbound id\n       *  if no callsid passed hangup anyways\n       */\n      if (payload.callsid && (_this.parameters.CallSid || _this.outboundConnectionId)) {\n        if (payload.callsid !== _this.parameters.CallSid && payload.callsid !== _this.outboundConnectionId) {\n          return;\n        }\n      } else if (payload.callsid) {\n        // hangup is for another call\n        return;\n      }\n      _this._log.info('Received HANGUP from gateway');\n      if (payload.error) {\n        var error = new errors_1.GeneralErrors.ConnectionError('Error sent from gateway in HANGUP');\n        _this._log.error('Received an error from the gateway:', error);\n        _this.emit('error', error);\n      }\n      _this._shouldSendHangup = false;\n      _this._publisher.info('connection', 'disconnected-by-remote', null, _this);\n      _this._disconnect(null, true);\n      _this._cleanupEventListeners();\n    };\n    /**\n     * Called when there is a media failure.\n     * Manages all media-related states and takes action base on the states\n     * @param type - Type of media failure\n     */\n    _this._onMediaFailure = function (type) {\n      var _a = Call.MediaFailure,\n        ConnectionDisconnected = _a.ConnectionDisconnected,\n        ConnectionFailed = _a.ConnectionFailed,\n        IceGatheringFailed = _a.IceGatheringFailed,\n        LowBytes = _a.LowBytes;\n      // These types signifies the end of a single ICE cycle\n      var isEndOfIceCycle = type === ConnectionFailed || type === IceGatheringFailed;\n      // All browsers except chrome doesn't update pc.iceConnectionState and pc.connectionState\n      // after issuing an ICE Restart, which we use to determine if ICE Restart is complete.\n      // Since we cannot detect if ICE Restart is complete, we will not retry.\n      if (!util_1.isChrome(window, window.navigator) && type === ConnectionFailed) {\n        return _this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n      }\n      // Ignore subsequent requests if ice restart is in progress\n      if (_this._mediaStatus === Call.State.Reconnecting) {\n        // This is a retry. Previous ICE Restart failed\n        if (isEndOfIceCycle) {\n          // We already exceeded max retry time.\n          if (Date.now() - _this._mediaReconnectStartTime > BACKOFF_CONFIG.max) {\n            _this._log.info('Exceeded max ICE retries');\n            return _this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n          }\n          // Issue ICE restart with backoff\n          try {\n            _this._mediaReconnectBackoff.backoff();\n          } catch (error) {\n            // Catch and ignore 'Backoff in progress.' errors. If a backoff is\n            // ongoing and we try to start another one, there shouldn't be a\n            // problem.\n            if (!(error.message && error.message === 'Backoff in progress.')) {\n              throw error;\n            }\n          }\n        }\n        return;\n      }\n      var pc = _this._mediaHandler.version.pc;\n      var isIceDisconnected = pc && pc.iceConnectionState === 'disconnected';\n      var hasLowBytesWarning = _this._monitor.hasActiveWarning('bytesSent', 'min') || _this._monitor.hasActiveWarning('bytesReceived', 'min');\n      // Only certain conditions can trigger media reconnection\n      if (type === LowBytes && isIceDisconnected || type === ConnectionDisconnected && hasLowBytesWarning || isEndOfIceCycle) {\n        var mediaReconnectionError = new errors_1.MediaErrors.ConnectionError('Media connection failed.');\n        _this._log.warn('ICE Connection disconnected.');\n        _this._publisher.warn('connection', 'error', mediaReconnectionError, _this);\n        _this._publisher.info('connection', 'reconnecting', null, _this);\n        _this._mediaReconnectStartTime = Date.now();\n        _this._status = Call.State.Reconnecting;\n        _this._mediaStatus = Call.State.Reconnecting;\n        _this._mediaReconnectBackoff.reset();\n        _this._mediaReconnectBackoff.backoff();\n        _this.emit('reconnecting', mediaReconnectionError);\n      }\n    };\n    /**\n     * Called when media call is restored\n     */\n    _this._onMediaReconnected = function () {\n      // Only trigger once.\n      // This can trigger on pc.onIceConnectionChange and pc.onConnectionChange.\n      if (_this._mediaStatus !== Call.State.Reconnecting) {\n        return;\n      }\n      _this._log.info('ICE Connection reestablished.');\n      _this._mediaStatus = Call.State.Open;\n      if (_this._signalingStatus === Call.State.Open) {\n        _this._publisher.info('connection', 'reconnected', null, _this);\n        _this.emit('reconnected');\n        _this._status = Call.State.Open;\n      }\n    };\n    /**\n     * Raised when a Call receives a message from the backend.\n     * @param payload - A record representing the payload of the message from the\n     * Twilio backend.\n     */\n    _this._onMessageReceived = function (payload) {\n      var callsid = payload.callsid,\n        content = payload.content,\n        contenttype = payload.contenttype,\n        messagetype = payload.messagetype,\n        voiceeventsid = payload.voiceeventsid;\n      if (_this.parameters.CallSid !== callsid) {\n        _this._log.warn(\"Received a message from a different callsid: \" + callsid);\n        return;\n      }\n      _this.emit('messageReceived', {\n        content: content,\n        contentType: contenttype,\n        messageType: messagetype,\n        voiceEventSid: voiceeventsid\n      });\n    };\n    /**\n     * Raised when a Call receives an 'ack' with an 'acktype' of 'message.\n     * This means that the message sent via sendMessage API has been received by the signaling server.\n     * @param voiceEventSid\n     */\n    _this._onMessageSent = function (voiceEventSid) {\n      if (!_this._messages.has(voiceEventSid)) {\n        _this._log.warn(\"Received a messageSent with a voiceEventSid that doesn't exists: \" + voiceEventSid);\n        return;\n      }\n      var message = _this._messages.get(voiceEventSid);\n      _this._messages.delete(voiceEventSid);\n      _this.emit('messageSent', message);\n    };\n    /**\n     * When we get a RINGING signal from PStream, update the {@link Call} status.\n     * @param payload\n     */\n    _this._onRinging = function (payload) {\n      _this._setCallSid(payload);\n      // If we're not in 'connecting' or 'ringing' state, this event was received out of order.\n      if (_this._status !== Call.State.Connecting && _this._status !== Call.State.Ringing) {\n        return;\n      }\n      var hasEarlyMedia = !!payload.sdp;\n      _this._status = Call.State.Ringing;\n      _this._publisher.info('connection', 'outgoing-ringing', {\n        hasEarlyMedia: hasEarlyMedia\n      }, _this);\n      _this.emit('ringing', hasEarlyMedia);\n    };\n    /**\n     * Called each time StatsMonitor emits a sample.\n     * Emits stats event and batches the call stats metrics and sends them to Insights.\n     * @param sample\n     */\n    _this._onRTCSample = function (sample) {\n      var callMetrics = __assign(__assign({}, sample), {\n        inputVolume: _this._latestInputVolume,\n        outputVolume: _this._latestOutputVolume\n      });\n      _this._codec = callMetrics.codecName;\n      _this._metricsSamples.push(callMetrics);\n      if (_this._metricsSamples.length >= METRICS_BATCH_SIZE) {\n        _this._publishMetrics();\n      }\n      _this.emit('sample', sample);\n    };\n    /**\n     * Called when an 'error' event is received from the signaling stream.\n     */\n    _this._onSignalingError = function (payload) {\n      var callsid = payload.callsid,\n        voiceeventsid = payload.voiceeventsid;\n      if (_this.parameters.CallSid !== callsid) {\n        _this._log.warn(\"Received an error from a different callsid: \" + callsid);\n        return;\n      }\n      if (voiceeventsid && _this._messages.has(voiceeventsid)) {\n        // Do not emit an error here. Device is handling all signaling related errors.\n        _this._messages.delete(voiceeventsid);\n        _this._log.warn(\"Received an error while sending a message.\", payload);\n      }\n    };\n    /**\n     * Called when signaling is restored\n     */\n    _this._onSignalingReconnected = function () {\n      if (_this._signalingStatus !== Call.State.Reconnecting) {\n        return;\n      }\n      _this._log.info('Signaling Connection reestablished.');\n      _this._signalingStatus = Call.State.Open;\n      if (_this._mediaStatus === Call.State.Open) {\n        _this._publisher.info('connection', 'reconnected', null, _this);\n        _this.emit('reconnected');\n        _this._status = Call.State.Open;\n      }\n    };\n    /**\n     * Called when we receive a transportClose event from pstream.\n     * Re-emits the event.\n     */\n    _this._onTransportClose = function () {\n      _this._log.error('Received transportClose from pstream');\n      _this.emit('transportClose');\n      if (_this._signalingReconnectToken) {\n        _this._status = Call.State.Reconnecting;\n        _this._signalingStatus = Call.State.Reconnecting;\n        _this.emit('reconnecting', new errors_1.SignalingErrors.ConnectionDisconnected());\n      } else {\n        _this._status = Call.State.Closed;\n        _this._signalingStatus = Call.State.Closed;\n      }\n    };\n    /**\n     * Re-emit an StatsMonitor warning as a {@link Call}.warning or .warning-cleared event.\n     * @param warningData\n     * @param wasCleared - Whether this is a -cleared or -raised event.\n     */\n    _this._reemitWarning = function (warningData, wasCleared) {\n      var groupPrefix = /^audio/.test(warningData.name) ? 'audio-level-' : 'network-quality-';\n      var warningPrefix = WARNING_PREFIXES[warningData.threshold.name];\n      /**\n       * NOTE: There are two \"packet-loss\" warnings: `high-packet-loss` and\n       * `high-packets-lost-fraction`, so in this case we need to use a different\n       * `WARNING_NAME` mapping.\n       */\n      var warningName;\n      if (warningData.name in MULTIPLE_THRESHOLD_WARNING_NAMES) {\n        warningName = MULTIPLE_THRESHOLD_WARNING_NAMES[warningData.name][warningData.threshold.name];\n      } else if (warningData.name in WARNING_NAMES) {\n        warningName = WARNING_NAMES[warningData.name];\n      }\n      var warning = warningPrefix + warningName;\n      _this._emitWarning(groupPrefix, warning, warningData.threshold.value, warningData.values || warningData.value, wasCleared, warningData);\n    };\n    /**\n     * Re-emit an StatsMonitor warning-cleared as a .warning-cleared event.\n     * @param warningData\n     */\n    _this._reemitWarningCleared = function (warningData) {\n      _this._reemitWarning(warningData, true);\n    };\n    _this._isUnifiedPlanDefault = config.isUnifiedPlanDefault;\n    _this._soundcache = config.soundcache;\n    if (typeof config.onIgnore === 'function') {\n      _this._onIgnore = config.onIgnore;\n    }\n    var message = options && options.twimlParams || {};\n    _this.customParameters = new Map(Object.entries(message).map(function (_a) {\n      var key = _a[0],\n        val = _a[1];\n      return [key, String(val)];\n    }));\n    Object.assign(_this._options, options);\n    if (_this._options.callParameters) {\n      _this.parameters = _this._options.callParameters;\n    }\n    if (_this._options.reconnectToken) {\n      _this._signalingReconnectToken = _this._options.reconnectToken;\n    }\n    _this._voiceEventSidGenerator = _this._options.voiceEventSidGenerator || uuid_1.generateVoiceEventSid;\n    _this._direction = _this.parameters.CallSid ? Call.CallDirection.Incoming : Call.CallDirection.Outgoing;\n    if (_this._direction === Call.CallDirection.Incoming && _this.parameters) {\n      _this.callerInfo = _this.parameters.StirStatus ? {\n        isVerified: _this.parameters.StirStatus === 'TN-Validation-Passed-A'\n      } : null;\n    } else {\n      _this.callerInfo = null;\n    }\n    _this._mediaReconnectBackoff = new backoff_1.default(BACKOFF_CONFIG);\n    _this._mediaReconnectBackoff.on('ready', function () {\n      return _this._mediaHandler.iceRestart();\n    });\n    // temporary call sid to be used for outgoing calls\n    _this.outboundConnectionId = generateTempCallSid();\n    var publisher = _this._publisher = config.publisher;\n    if (_this._direction === Call.CallDirection.Incoming) {\n      publisher.info('connection', 'incoming', null, _this);\n    } else {\n      publisher.info('connection', 'outgoing', {\n        preflight: _this._options.preflight\n      }, _this);\n    }\n    var monitor = _this._monitor = new (_this._options.StatsMonitor || statsMonitor_1.default)();\n    monitor.on('sample', _this._onRTCSample);\n    // First 20 seconds or so are choppy, so let's not bother with these warnings.\n    monitor.disableWarnings();\n    setTimeout(function () {\n      return monitor.enableWarnings();\n    }, METRICS_DELAY);\n    monitor.on('warning', function (data, wasCleared) {\n      if (data.name === 'bytesSent' || data.name === 'bytesReceived') {\n        _this._onMediaFailure(Call.MediaFailure.LowBytes);\n      }\n      _this._reemitWarning(data, wasCleared);\n    });\n    monitor.on('warning-cleared', function (data) {\n      _this._reemitWarningCleared(data);\n    });\n    _this._mediaHandler = new _this._options.MediaHandler(config.audioHelper, config.pstream, config.getUserMedia, {\n      RTCPeerConnection: _this._options.RTCPeerConnection,\n      codecPreferences: _this._options.codecPreferences,\n      dscp: _this._options.dscp,\n      forceAggressiveIceNomination: _this._options.forceAggressiveIceNomination,\n      isUnifiedPlan: _this._isUnifiedPlanDefault,\n      maxAverageBitrate: _this._options.maxAverageBitrate,\n      preflight: _this._options.preflight\n    });\n    _this.on('volume', function (inputVolume, outputVolume) {\n      _this._inputVolumeStreak = _this._checkVolume(inputVolume, _this._inputVolumeStreak, _this._latestInputVolume, 'input');\n      _this._outputVolumeStreak = _this._checkVolume(outputVolume, _this._outputVolumeStreak, _this._latestOutputVolume, 'output');\n      _this._latestInputVolume = inputVolume;\n      _this._latestOutputVolume = outputVolume;\n    });\n    _this._mediaHandler.onaudio = function (remoteAudio) {\n      _this._log.info('Remote audio created');\n      _this.emit('audio', remoteAudio);\n    };\n    _this._mediaHandler.onvolume = function (inputVolume, outputVolume, internalInputVolume, internalOutputVolume) {\n      // (rrowland) These values mock the 0 -> 32767 format used by legacy getStats. We should look into\n      // migrating to a newer standard, either 0.0 -> linear or -127 to 0 in dB, matching the range\n      // chosen below.\n      monitor.addVolumes(internalInputVolume / 255 * 32767, internalOutputVolume / 255 * 32767);\n      // (rrowland) 0.0 -> 1.0 linear\n      _this.emit('volume', inputVolume, outputVolume);\n    };\n    _this._mediaHandler.ondtlstransportstatechange = function (state) {\n      var level = state === 'failed' ? 'error' : 'debug';\n      _this._publisher.post(level, 'dtls-transport-state', state, null, _this);\n    };\n    _this._mediaHandler.onpcconnectionstatechange = function (state) {\n      var level = 'debug';\n      var dtlsTransport = _this._mediaHandler.getRTCDtlsTransport();\n      if (state === 'failed') {\n        level = dtlsTransport && dtlsTransport.state === 'failed' ? 'error' : 'warning';\n      }\n      _this._publisher.post(level, 'pc-connection-state', state, null, _this);\n    };\n    _this._mediaHandler.onicecandidate = function (candidate) {\n      var payload = new icecandidate_1.IceCandidate(candidate).toPayload();\n      _this._publisher.debug('ice-candidate', 'ice-candidate', payload, _this);\n    };\n    _this._mediaHandler.onselectedcandidatepairchange = function (pair) {\n      var localCandidatePayload = new icecandidate_1.IceCandidate(pair.local).toPayload();\n      var remoteCandidatePayload = new icecandidate_1.IceCandidate(pair.remote, true).toPayload();\n      _this._publisher.debug('ice-candidate', 'selected-ice-candidate-pair', {\n        local_candidate: localCandidatePayload,\n        remote_candidate: remoteCandidatePayload\n      }, _this);\n    };\n    _this._mediaHandler.oniceconnectionstatechange = function (state) {\n      var level = state === 'failed' ? 'error' : 'debug';\n      _this._publisher.post(level, 'ice-connection-state', state, null, _this);\n    };\n    _this._mediaHandler.onicegatheringfailure = function (type) {\n      _this._publisher.warn('ice-gathering-state', type, null, _this);\n      _this._onMediaFailure(Call.MediaFailure.IceGatheringFailed);\n    };\n    _this._mediaHandler.onicegatheringstatechange = function (state) {\n      _this._publisher.debug('ice-gathering-state', state, null, _this);\n    };\n    _this._mediaHandler.onsignalingstatechange = function (state) {\n      _this._publisher.debug('signaling-state', state, null, _this);\n    };\n    _this._mediaHandler.ondisconnected = function (msg) {\n      _this._log.info(msg);\n      _this._publisher.warn('network-quality-warning-raised', 'ice-connectivity-lost', {\n        message: msg\n      }, _this);\n      _this.emit('warning', 'ice-connectivity-lost');\n      _this._onMediaFailure(Call.MediaFailure.ConnectionDisconnected);\n    };\n    _this._mediaHandler.onfailed = function (msg) {\n      _this._onMediaFailure(Call.MediaFailure.ConnectionFailed);\n    };\n    _this._mediaHandler.onconnected = function () {\n      // First time _mediaHandler is connected, but ICE Gathering issued an ICE restart and succeeded.\n      if (_this._status === Call.State.Reconnecting) {\n        _this._onMediaReconnected();\n      }\n    };\n    _this._mediaHandler.onreconnected = function (msg) {\n      _this._log.info(msg);\n      _this._publisher.info('network-quality-warning-cleared', 'ice-connectivity-lost', {\n        message: msg\n      }, _this);\n      _this.emit('warning-cleared', 'ice-connectivity-lost');\n      _this._onMediaReconnected();\n    };\n    _this._mediaHandler.onerror = function (e) {\n      if (e.disconnect === true) {\n        _this._disconnect(e.info && e.info.message);\n      }\n      var error = e.info.twilioError || new errors_1.GeneralErrors.UnknownError(e.info.message);\n      _this._log.error('Received an error from MediaStream:', e);\n      _this.emit('error', error);\n    };\n    _this._mediaHandler.onopen = function () {\n      // NOTE(mroberts): While this may have been happening in previous\n      // versions of Chrome, since Chrome 45 we have seen the\n      // PeerConnection's onsignalingstatechange handler invoked multiple\n      // times in the same signalingState 'stable'. When this happens, we\n      // invoke this onopen function. If we invoke it twice without checking\n      // for _status 'open', we'd accidentally close the PeerConnection.\n      //\n      // See <https://code.google.com/p/webrtc/issues/detail?id=4996>.\n      if (_this._status === Call.State.Open || _this._status === Call.State.Reconnecting) {\n        return;\n      } else if (_this._status === Call.State.Ringing || _this._status === Call.State.Connecting) {\n        _this.mute(false);\n        _this._mediaStatus = Call.State.Open;\n        _this._maybeTransitionToOpen();\n      } else {\n        // call was probably canceled sometime before this\n        _this._mediaHandler.close();\n      }\n    };\n    _this._mediaHandler.onclose = function () {\n      _this._status = Call.State.Closed;\n      if (_this._options.shouldPlayDisconnect && _this._options.shouldPlayDisconnect()\n      // Don't play disconnect sound if this was from a cancel event. i.e. the call\n      // was ignored or hung up even before it was answered.\n      // Similarly, don't play disconnect sound if the call was rejected.\n      && !_this._isCancelled && !_this._isRejected) {\n        _this._soundcache.get(device_1.default.SoundName.Disconnect).play();\n      }\n      monitor.disable();\n      _this._publishMetrics();\n      if (!_this._isCancelled && !_this._isRejected) {\n        // tslint:disable no-console\n        _this.emit('disconnect', _this);\n      }\n    };\n    _this._pstream = config.pstream;\n    _this._pstream.on('ack', _this._onAck);\n    _this._pstream.on('cancel', _this._onCancel);\n    _this._pstream.on('error', _this._onSignalingError);\n    _this._pstream.on('ringing', _this._onRinging);\n    _this._pstream.on('transportClose', _this._onTransportClose);\n    _this._pstream.on('connected', _this._onConnected);\n    _this._pstream.on('message', _this._onMessageReceived);\n    _this.on('error', function (error) {\n      _this._publisher.error('connection', 'error', {\n        code: error.code,\n        message: error.message\n      }, _this);\n      if (_this._pstream && _this._pstream.status === 'disconnected') {\n        _this._cleanupEventListeners();\n      }\n    });\n    _this.on('disconnect', function () {\n      _this._cleanupEventListeners();\n    });\n    return _this;\n  }\n  Object.defineProperty(Call.prototype, \"direction\", {\n    /**\n     * Whether this {@link Call} is incoming or outgoing.\n     */\n    get: function () {\n      return this._direction;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Call.prototype, \"codec\", {\n    /**\n     * Audio codec used for this {@link Call}. Expecting {@link Call.Codec} but\n     * will copy whatever we get from RTC stats.\n     */\n    get: function () {\n      return this._codec;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Set the audio input tracks from a given stream.\n   * @param stream\n   * @private\n   */\n  Call.prototype._setInputTracksFromStream = function (stream) {\n    return this._mediaHandler.setInputTracksFromStream(stream);\n  };\n  /**\n   * Set the audio output sink IDs.\n   * @param sinkIds\n   * @private\n   */\n  Call.prototype._setSinkIds = function (sinkIds) {\n    return this._mediaHandler._setSinkIds(sinkIds);\n  };\n  /**\n   * Accept the incoming {@link Call}.\n   * @param [options]\n   */\n  Call.prototype.accept = function (options) {\n    var _this = this;\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n    options = options || {};\n    var rtcConfiguration = options.rtcConfiguration || this._options.rtcConfiguration;\n    var rtcConstraints = options.rtcConstraints || this._options.rtcConstraints || {};\n    var audioConstraints = rtcConstraints.audio || {\n      audio: true\n    };\n    this._status = Call.State.Connecting;\n    var connect = function () {\n      if (_this._status !== Call.State.Connecting) {\n        // call must have been canceled\n        _this._cleanupEventListeners();\n        _this._mediaHandler.close();\n        return;\n      }\n      var onAnswer = function (pc, reconnectToken) {\n        // Report that the call was answered, and directionality\n        var eventName = _this._direction === Call.CallDirection.Incoming ? 'accepted-by-local' : 'accepted-by-remote';\n        _this._publisher.info('connection', eventName, null, _this);\n        if (typeof reconnectToken === 'string') {\n          _this._signalingReconnectToken = reconnectToken;\n        }\n        // Report the preferred codec and params as they appear in the SDP\n        var _a = sdp_1.getPreferredCodecInfo(_this._mediaHandler.version.getSDP()),\n          codecName = _a.codecName,\n          codecParams = _a.codecParams;\n        _this._publisher.info('settings', 'codec', {\n          codec_params: codecParams,\n          selected_codec: codecName\n        }, _this);\n        // Enable RTC monitoring\n        _this._monitor.enable(pc);\n      };\n      var sinkIds = typeof _this._options.getSinkIds === 'function' && _this._options.getSinkIds();\n      if (Array.isArray(sinkIds)) {\n        _this._mediaHandler._setSinkIds(sinkIds).catch(function () {\n          // (rrowland) We don't want this to throw to console since the customer\n          // can't control this. This will most commonly be rejected on browsers\n          // that don't support setting sink IDs.\n        });\n      }\n      _this._pstream.addListener('hangup', _this._onHangup);\n      if (_this._direction === Call.CallDirection.Incoming) {\n        _this._isAnswered = true;\n        _this._pstream.on('answer', _this._onAnswer);\n        _this._mediaHandler.answerIncomingCall(_this.parameters.CallSid, _this._options.offerSdp, rtcConstraints, rtcConfiguration, onAnswer);\n      } else {\n        var params = Array.from(_this.customParameters.entries()).map(function (pair) {\n          return encodeURIComponent(pair[0]) + \"=\" + encodeURIComponent(pair[1]);\n        }).join('&');\n        _this._pstream.on('answer', _this._onAnswer);\n        _this._mediaHandler.makeOutgoingCall(_this._pstream.token, params, _this.outboundConnectionId, rtcConstraints, rtcConfiguration, onAnswer);\n      }\n    };\n    if (this._options.beforeAccept) {\n      this._options.beforeAccept(this);\n    }\n    var inputStream = typeof this._options.getInputStream === 'function' && this._options.getInputStream();\n    var promise = inputStream ? this._mediaHandler.setInputTracksFromStream(inputStream) : this._mediaHandler.openWithConstraints(audioConstraints);\n    promise.then(function () {\n      _this._publisher.info('get-user-media', 'succeeded', {\n        data: {\n          audioConstraints: audioConstraints\n        }\n      }, _this);\n      connect();\n    }, function (error) {\n      var twilioError;\n      if (error.code === 31208 || ['PermissionDeniedError', 'NotAllowedError'].indexOf(error.name) !== -1) {\n        twilioError = new errors_1.UserMediaErrors.PermissionDeniedError();\n        _this._publisher.error('get-user-media', 'denied', {\n          data: {\n            audioConstraints: audioConstraints,\n            error: error\n          }\n        }, _this);\n      } else {\n        twilioError = new errors_1.UserMediaErrors.AcquisitionFailedError();\n        _this._publisher.error('get-user-media', 'failed', {\n          data: {\n            audioConstraints: audioConstraints,\n            error: error\n          }\n        }, _this);\n      }\n      _this._disconnect();\n      _this.emit('error', twilioError);\n    });\n  };\n  /**\n   * Disconnect from the {@link Call}.\n   */\n  Call.prototype.disconnect = function () {\n    this._disconnect();\n  };\n  /**\n   * Get the local MediaStream, if set.\n   */\n  Call.prototype.getLocalStream = function () {\n    return this._mediaHandler && this._mediaHandler.stream;\n  };\n  /**\n   * Get the remote MediaStream, if set.\n   */\n  Call.prototype.getRemoteStream = function () {\n    return this._mediaHandler && this._mediaHandler._remoteStream;\n  };\n  /**\n   * Ignore the incoming {@link Call}.\n   */\n  Call.prototype.ignore = function () {\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n    this._status = Call.State.Closed;\n    this._mediaHandler.ignore(this.parameters.CallSid);\n    this._publisher.info('connection', 'ignored-by-local', null, this);\n    if (this._onIgnore) {\n      this._onIgnore();\n    }\n  };\n  /**\n   * Check whether call is muted\n   */\n  Call.prototype.isMuted = function () {\n    return this._mediaHandler.isMuted;\n  };\n  /**\n   * Mute incoming audio.\n   * @param shouldMute - Whether the incoming audio should be muted. Defaults to true.\n   */\n  Call.prototype.mute = function (shouldMute) {\n    if (shouldMute === void 0) {\n      shouldMute = true;\n    }\n    var wasMuted = this._mediaHandler.isMuted;\n    this._mediaHandler.mute(shouldMute);\n    var isMuted = this._mediaHandler.isMuted;\n    if (wasMuted !== isMuted) {\n      this._publisher.info('connection', isMuted ? 'muted' : 'unmuted', null, this);\n      this.emit('mute', isMuted, this);\n    }\n  };\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has given call quality feedback. Called without a score, this\n   *   will report that the customer declined to give feedback.\n   * @param score - The end-user's rating of the call; an\n   *   integer 1 through 5. Or undefined if the user declined to give\n   *   feedback.\n   * @param issue - The primary issue the end user\n   *   experienced on the call. Can be: ['one-way-audio', 'choppy-audio',\n   *   'dropped-call', 'audio-latency', 'noisy-call', 'echo']\n   */\n  Call.prototype.postFeedback = function (score, issue) {\n    if (typeof score === 'undefined' || score === null) {\n      return this._postFeedbackDeclined();\n    }\n    if (!Object.values(Call.FeedbackScore).includes(score)) {\n      throw new errors_1.InvalidArgumentError(\"Feedback score must be one of: \" + Object.values(Call.FeedbackScore));\n    }\n    if (typeof issue !== 'undefined' && issue !== null && !Object.values(Call.FeedbackIssue).includes(issue)) {\n      throw new errors_1.InvalidArgumentError(\"Feedback issue must be one of: \" + Object.values(Call.FeedbackIssue));\n    }\n    return this._publisher.info('feedback', 'received', {\n      issue_name: issue,\n      quality_score: score\n    }, this, true);\n  };\n  /**\n   * Reject the incoming {@link Call}.\n   */\n  Call.prototype.reject = function () {\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n    this._isRejected = true;\n    this._pstream.reject(this.parameters.CallSid);\n    this._mediaHandler.reject(this.parameters.CallSid);\n    this._publisher.info('connection', 'rejected-by-local', null, this);\n    this._cleanupEventListeners();\n    this._mediaHandler.close();\n    this._status = Call.State.Closed;\n    this.emit('reject');\n  };\n  /**\n   * Send a string of digits.\n   * @param digits\n   */\n  Call.prototype.sendDigits = function (digits) {\n    if (digits.match(/[^0-9*#w]/)) {\n      throw new errors_1.InvalidArgumentError('Illegal character passed into sendDigits');\n    }\n    var sequence = [];\n    digits.split('').forEach(function (digit) {\n      var dtmf = digit !== 'w' ? \"dtmf\" + digit : '';\n      if (dtmf === 'dtmf*') {\n        dtmf = 'dtmfs';\n      }\n      if (dtmf === 'dtmf#') {\n        dtmf = 'dtmfh';\n      }\n      sequence.push(dtmf);\n    });\n    // Binds soundCache to be used in recursion until all digits have been played.\n    (function playNextDigit(soundCache, dialtonePlayer) {\n      var digit = sequence.shift();\n      if (digit) {\n        if (dialtonePlayer) {\n          dialtonePlayer.play(digit);\n        } else {\n          soundCache.get(digit).play();\n        }\n      }\n      if (sequence.length) {\n        setTimeout(playNextDigit.bind(null, soundCache), 200);\n      }\n    })(this._soundcache, this._options.dialtonePlayer);\n    var dtmfSender = this._mediaHandler.getOrCreateDTMFSender();\n    function insertDTMF(dtmfs) {\n      if (!dtmfs.length) {\n        return;\n      }\n      var dtmf = dtmfs.shift();\n      if (dtmf && dtmf.length) {\n        dtmfSender.insertDTMF(dtmf, DTMF_TONE_DURATION, DTMF_INTER_TONE_GAP);\n      }\n      setTimeout(insertDTMF.bind(null, dtmfs), DTMF_PAUSE_DURATION);\n    }\n    if (dtmfSender) {\n      if (!('canInsertDTMF' in dtmfSender) || dtmfSender.canInsertDTMF) {\n        this._log.info('Sending digits using RTCDTMFSender');\n        // NOTE(mroberts): We can't just map 'w' to ',' since\n        // RTCDTMFSender's pause duration is 2 s and Twilio's is more\n        // like 500 ms. Instead, we will fudge it with setTimeout.\n        insertDTMF(digits.split('w'));\n        return;\n      }\n      this._log.info('RTCDTMFSender cannot insert DTMF');\n    }\n    // send pstream message to send DTMF\n    this._log.info('Sending digits over PStream');\n    if (this._pstream !== null && this._pstream.status !== 'disconnected') {\n      this._pstream.dtmf(this.parameters.CallSid, digits);\n    } else {\n      var error = new errors_1.GeneralErrors.ConnectionError('Could not send DTMF: Signaling channel is disconnected');\n      this.emit('error', error);\n    }\n  };\n  /**\n   * Send a message to Twilio. Your backend application can listen for these\n   * messages to allow communication between your frontend and backend applications.\n   * <br/><br/>This feature is currently in Beta.\n   * @param message - The message object to send.\n   * @returns A voice event sid that uniquely identifies the message that was sent.\n   */\n  Call.prototype.sendMessage = function (message) {\n    var content = message.content,\n      contentType = message.contentType,\n      messageType = message.messageType;\n    if (typeof content === 'undefined' || content === null) {\n      throw new errors_1.InvalidArgumentError('`content` is empty');\n    }\n    if (typeof messageType !== 'string') {\n      throw new errors_1.InvalidArgumentError('`messageType` must be an enumeration value of `Call.MessageType` or ' + 'a string.');\n    }\n    if (messageType.length === 0) {\n      throw new errors_1.InvalidArgumentError('`messageType` must be a non-empty string.');\n    }\n    if (this._pstream === null) {\n      throw new errors_1.InvalidStateError('Could not send CallMessage; Signaling channel is disconnected');\n    }\n    var callSid = this.parameters.CallSid;\n    if (typeof this.parameters.CallSid === 'undefined') {\n      throw new errors_1.InvalidStateError('Could not send CallMessage; Call has no CallSid');\n    }\n    var voiceEventSid = this._voiceEventSidGenerator();\n    this._messages.set(voiceEventSid, {\n      content: content,\n      contentType: contentType,\n      messageType: messageType,\n      voiceEventSid: voiceEventSid\n    });\n    this._pstream.sendMessage(callSid, content, contentType, messageType, voiceEventSid);\n    return voiceEventSid;\n  };\n  /**\n   * Get the current {@link Call} status.\n   */\n  Call.prototype.status = function () {\n    return this._status;\n  };\n  /**\n   * Check the volume passed, emitting a warning if one way audio is detected or cleared.\n   * @param currentVolume - The current volume for this direction\n   * @param streakFieldName - The name of the field on the {@link Call} object that tracks how many times the\n   *   current value has been repeated consecutively.\n   * @param lastValueFieldName - The name of the field on the {@link Call} object that tracks the most recent\n   *   volume for this direction\n   * @param direction - The directionality of this audio track, either 'input' or 'output'\n   * @returns The current streak; how many times in a row the same value has been polled.\n   */\n  Call.prototype._checkVolume = function (currentVolume, currentStreak, lastValue, direction) {\n    var wasWarningRaised = currentStreak >= 10;\n    var newStreak = 0;\n    if (lastValue === currentVolume) {\n      newStreak = currentStreak;\n    }\n    if (newStreak >= 10) {\n      this._emitWarning('audio-level-', \"constant-audio-\" + direction + \"-level\", 10, newStreak, false);\n    } else if (wasWarningRaised) {\n      this._emitWarning('audio-level-', \"constant-audio-\" + direction + \"-level\", 10, newStreak, true);\n    }\n    return newStreak;\n  };\n  /**\n   * Clean up event listeners.\n   */\n  Call.prototype._cleanupEventListeners = function () {\n    var _this = this;\n    var cleanup = function () {\n      if (!_this._pstream) {\n        return;\n      }\n      _this._pstream.removeListener('ack', _this._onAck);\n      _this._pstream.removeListener('answer', _this._onAnswer);\n      _this._pstream.removeListener('cancel', _this._onCancel);\n      _this._pstream.removeListener('error', _this._onSignalingError);\n      _this._pstream.removeListener('hangup', _this._onHangup);\n      _this._pstream.removeListener('ringing', _this._onRinging);\n      _this._pstream.removeListener('transportClose', _this._onTransportClose);\n      _this._pstream.removeListener('connected', _this._onConnected);\n      _this._pstream.removeListener('message', _this._onMessageReceived);\n    };\n    // This is kind of a hack, but it lets us avoid rewriting more code.\n    // Basically, there's a sequencing problem with the way PeerConnection raises\n    // the\n    //\n    //   Cannot establish call. SDK is disconnected\n    //\n    // error in Call#accept. It calls PeerConnection#onerror, which emits\n    // the error event on Call. An error handler on Call then calls\n    // cleanupEventListeners, but then control returns to Call#accept. It's\n    // at this point that we add a listener for the answer event that never gets\n    // removed. setTimeout will allow us to rerun cleanup again, _after_\n    // Call#accept returns.\n    cleanup();\n    setTimeout(cleanup, 0);\n  };\n  /**\n   * Create the payload wrapper for a batch of metrics to be sent to Insights.\n   */\n  Call.prototype._createMetricPayload = function () {\n    var payload = {\n      call_sid: this.parameters.CallSid,\n      dscp: !!this._options.dscp,\n      sdk_version: RELEASE_VERSION\n    };\n    if (this._options.gateway) {\n      payload.gateway = this._options.gateway;\n    }\n    payload.direction = this._direction;\n    return payload;\n  };\n  /**\n   * Disconnect the {@link Call}.\n   * @param message - A message explaining why the {@link Call} is being disconnected.\n   * @param wasRemote - Whether the disconnect was triggered locally or remotely.\n   */\n  Call.prototype._disconnect = function (message, wasRemote) {\n    message = typeof message === 'string' ? message : null;\n    if (this._status !== Call.State.Open && this._status !== Call.State.Connecting && this._status !== Call.State.Reconnecting && this._status !== Call.State.Ringing) {\n      return;\n    }\n    this._log.info('Disconnecting...');\n    // send pstream hangup message\n    if (this._pstream !== null && this._pstream.status !== 'disconnected' && this._shouldSendHangup) {\n      var callsid = this.parameters.CallSid || this.outboundConnectionId;\n      if (callsid) {\n        this._pstream.hangup(callsid, message);\n      }\n    }\n    this._cleanupEventListeners();\n    this._mediaHandler.close();\n    if (!wasRemote) {\n      this._publisher.info('connection', 'disconnected-by-local', null, this);\n    }\n  };\n  /**\n   * Transition to {@link CallStatus.Open} if criteria is met.\n   */\n  Call.prototype._maybeTransitionToOpen = function () {\n    var wasConnected = this._wasConnected;\n    if (this._isAnswered) {\n      this._onSignalingReconnected();\n      this._signalingStatus = Call.State.Open;\n      if (this._mediaHandler && this._mediaHandler.status === 'open') {\n        this._status = Call.State.Open;\n        if (!this._wasConnected) {\n          this._wasConnected = true;\n          this.emit('accept', this);\n        }\n      }\n    }\n  };\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has ignored a request for feedback.\n   */\n  Call.prototype._postFeedbackDeclined = function () {\n    return this._publisher.info('feedback', 'received-none', null, this, true);\n  };\n  /**\n   * Publish the current set of queued metrics samples to Insights.\n   */\n  Call.prototype._publishMetrics = function () {\n    var _this = this;\n    if (this._metricsSamples.length === 0) {\n      return;\n    }\n    this._publisher.postMetrics('quality-metrics-samples', 'metrics-sample', this._metricsSamples.splice(0), this._createMetricPayload(), this).catch(function (e) {\n      _this._log.warn('Unable to post metrics to Insights. Received error:', e);\n    });\n  };\n  /**\n   * Set the CallSid\n   * @param payload\n   */\n  Call.prototype._setCallSid = function (payload) {\n    var callSid = payload.callsid;\n    if (!callSid) {\n      return;\n    }\n    this.parameters.CallSid = callSid;\n    this._mediaHandler.callSid = callSid;\n  };\n  /**\n   * String representation of the {@link Call} class.\n   * @private\n   */\n  Call.toString = function () {\n    return '[Twilio.Call class]';\n  };\n  return Call;\n}(events_1.EventEmitter);\n(function (Call) {\n  /**\n   * Possible states of the {@link Call}.\n   */\n  var State;\n  (function (State) {\n    State[\"Closed\"] = \"closed\";\n    State[\"Connecting\"] = \"connecting\";\n    State[\"Open\"] = \"open\";\n    State[\"Pending\"] = \"pending\";\n    State[\"Reconnecting\"] = \"reconnecting\";\n    State[\"Ringing\"] = \"ringing\";\n  })(State = Call.State || (Call.State = {}));\n  /**\n   * Different issues that may have been experienced during a call, that can be\n   * reported to Twilio Insights via {@link Call}.postFeedback().\n   */\n  var FeedbackIssue;\n  (function (FeedbackIssue) {\n    FeedbackIssue[\"AudioLatency\"] = \"audio-latency\";\n    FeedbackIssue[\"ChoppyAudio\"] = \"choppy-audio\";\n    FeedbackIssue[\"DroppedCall\"] = \"dropped-call\";\n    FeedbackIssue[\"Echo\"] = \"echo\";\n    FeedbackIssue[\"NoisyCall\"] = \"noisy-call\";\n    FeedbackIssue[\"OneWayAudio\"] = \"one-way-audio\";\n  })(FeedbackIssue = Call.FeedbackIssue || (Call.FeedbackIssue = {}));\n  /**\n   * A rating of call quality experienced during a call, to be reported to Twilio Insights\n   * via {@link Call}.postFeedback().\n   */\n  var FeedbackScore;\n  (function (FeedbackScore) {\n    FeedbackScore[FeedbackScore[\"One\"] = 1] = \"One\";\n    FeedbackScore[FeedbackScore[\"Two\"] = 2] = \"Two\";\n    FeedbackScore[FeedbackScore[\"Three\"] = 3] = \"Three\";\n    FeedbackScore[FeedbackScore[\"Four\"] = 4] = \"Four\";\n    FeedbackScore[FeedbackScore[\"Five\"] = 5] = \"Five\";\n  })(FeedbackScore = Call.FeedbackScore || (Call.FeedbackScore = {}));\n  /**\n   * The directionality of the {@link Call}, whether incoming or outgoing.\n   */\n  var CallDirection;\n  (function (CallDirection) {\n    CallDirection[\"Incoming\"] = \"INCOMING\";\n    CallDirection[\"Outgoing\"] = \"OUTGOING\";\n  })(CallDirection = Call.CallDirection || (Call.CallDirection = {}));\n  /**\n   * Valid audio codecs to use for the media connection.\n   */\n  var Codec;\n  (function (Codec) {\n    Codec[\"Opus\"] = \"opus\";\n    Codec[\"PCMU\"] = \"pcmu\";\n  })(Codec = Call.Codec || (Call.Codec = {}));\n  /**\n   * Possible ICE Gathering failures\n   */\n  var IceGatheringFailureReason;\n  (function (IceGatheringFailureReason) {\n    IceGatheringFailureReason[\"None\"] = \"none\";\n    IceGatheringFailureReason[\"Timeout\"] = \"timeout\";\n  })(IceGatheringFailureReason = Call.IceGatheringFailureReason || (Call.IceGatheringFailureReason = {}));\n  /**\n   * Possible media failures\n   */\n  var MediaFailure;\n  (function (MediaFailure) {\n    MediaFailure[\"ConnectionDisconnected\"] = \"ConnectionDisconnected\";\n    MediaFailure[\"ConnectionFailed\"] = \"ConnectionFailed\";\n    MediaFailure[\"IceGatheringFailed\"] = \"IceGatheringFailed\";\n    MediaFailure[\"LowBytes\"] = \"LowBytes\";\n  })(MediaFailure = Call.MediaFailure || (Call.MediaFailure = {}));\n  /**\n   * Known call message types.\n   */\n  var MessageType;\n  (function (MessageType) {\n    /**\n     * Allows for any object types to be defined by the user.\n     * When this value is used in the {@link Call.Message} object,\n     * The {@link Call.Message.content} can be of any type as long as\n     * it matches the MIME type defined in {@link Call.Message.contentType}.\n     */\n    MessageType[\"UserDefinedMessage\"] = \"user-defined-message\";\n  })(MessageType = Call.MessageType || (Call.MessageType = {}));\n})(Call || (Call = {}));\nfunction generateTempCallSid() {\n  return 'TJSxxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    /* tslint:disable:no-bitwise */\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    /* tslint:enable:no-bitwise */\n    return v.toString(16);\n  });\n}\nexports.default = Call;","map":{"version":3,"names":["events_1","require","backoff_1","device_1","errors_1","log_1","rtc_1","icecandidate_1","sdp_1","statsMonitor_1","util_1","uuid_1","RELEASE_VERSION","BACKOFF_CONFIG","factor","jitter","max","min","DTMF_INTER_TONE_GAP","DTMF_PAUSE_DURATION","DTMF_TONE_DURATION","METRICS_BATCH_SIZE","METRICS_DELAY","MEDIA_DISCONNECT_ERROR","disconnect","info","code","message","twilioError","MediaErrors","ConnectionError","MULTIPLE_THRESHOLD_WARNING_NAMES","packetsLostFraction","maxAverage","WARNING_NAMES","audioInputLevel","audioOutputLevel","bytesReceived","bytesSent","mos","rtt","WARNING_PREFIXES","maxDuration","minStandardDeviation","Call","_super","__extends","config","options","_this","call","parameters","_inputVolumeStreak","_isAnswered","_isCancelled","_isRejected","_latestInputVolume","_latestOutputVolume","_log","default","getInstance","_mediaStatus","State","Pending","_messages","Map","_metricsSamples","_options","MediaHandler","PeerConnection","offerSdp","shouldPlayDisconnect","voiceEventSidGenerator","generateVoiceEventSid","_outputVolumeStreak","_shouldSendHangup","_signalingStatus","_soundcache","_status","_wasConnected","toString","_emitWarning","groupPrefix","warningName","threshold","value","wasCleared","warningData","groupSuffix","groupName","isMuted","level","payloadData","Array","values","map","val","Math","round","_publisher","post","data","emitName","emit","_onAck","payload","acktype","callsid","voiceeventsid","CallSid","warn","_onMessageSent","_onAnswer","reconnect","_signalingReconnectToken","Reconnecting","_setCallSid","_maybeTransitionToOpen","_onCancel","_cleanupEventListeners","_mediaHandler","close","Closed","_pstream","removeListener","_onConnected","version","getSDP","_onHangup","status","outboundConnectionId","error","GeneralErrors","_disconnect","_onMediaFailure","type","_a","MediaFailure","ConnectionDisconnected","ConnectionFailed","IceGatheringFailed","LowBytes","isEndOfIceCycle","isChrome","window","navigator","onerror","Date","now","_mediaReconnectStartTime","_mediaReconnectBackoff","backoff","pc","isIceDisconnected","iceConnectionState","hasLowBytesWarning","_monitor","hasActiveWarning","mediaReconnectionError","reset","_onMediaReconnected","Open","_onMessageReceived","content","contenttype","messagetype","contentType","messageType","voiceEventSid","has","get","delete","_onRinging","Connecting","Ringing","hasEarlyMedia","sdp","_onRTCSample","sample","callMetrics","__assign","inputVolume","outputVolume","_codec","codecName","push","length","_publishMetrics","_onSignalingError","_onSignalingReconnected","_onTransportClose","SignalingErrors","_reemitWarning","test","name","warningPrefix","warning","_reemitWarningCleared","_isUnifiedPlanDefault","isUnifiedPlanDefault","soundcache","onIgnore","_onIgnore","twimlParams","customParameters","Object","entries","key","String","assign","callParameters","reconnectToken","_voiceEventSidGenerator","_direction","CallDirection","Incoming","Outgoing","callerInfo","StirStatus","isVerified","on","iceRestart","generateTempCallSid","publisher","preflight","monitor","StatsMonitor","disableWarnings","setTimeout","enableWarnings","audioHelper","pstream","getUserMedia","RTCPeerConnection","codecPreferences","dscp","forceAggressiveIceNomination","isUnifiedPlan","maxAverageBitrate","_checkVolume","onaudio","remoteAudio","onvolume","internalInputVolume","internalOutputVolume","addVolumes","ondtlstransportstatechange","state","onpcconnectionstatechange","dtlsTransport","getRTCDtlsTransport","onicecandidate","candidate","IceCandidate","toPayload","debug","onselectedcandidatepairchange","pair","localCandidatePayload","local","remoteCandidatePayload","remote","local_candidate","remote_candidate","oniceconnectionstatechange","onicegatheringfailure","onicegatheringstatechange","onsignalingstatechange","ondisconnected","msg","onfailed","onconnected","onreconnected","e","UnknownError","onopen","mute","onclose","SoundName","Disconnect","play","disable","defineProperty","prototype","_setInputTracksFromStream","stream","setInputTracksFromStream","_setSinkIds","sinkIds","accept","rtcConfiguration","rtcConstraints","audioConstraints","audio","connect","onAnswer","eventName","getPreferredCodecInfo","codecParams","codec_params","selected_codec","enable","getSinkIds","isArray","catch","addListener","answerIncomingCall","params","from","encodeURIComponent","join","makeOutgoingCall","token","beforeAccept","inputStream","getInputStream","promise","openWithConstraints","then","indexOf","UserMediaErrors","PermissionDeniedError","AcquisitionFailedError","getLocalStream","getRemoteStream","_remoteStream","ignore","shouldMute","wasMuted","postFeedback","score","issue","_postFeedbackDeclined","FeedbackScore","includes","InvalidArgumentError","FeedbackIssue","issue_name","quality_score","reject","sendDigits","digits","match","sequence","split","forEach","digit","dtmf","playNextDigit","soundCache","dialtonePlayer","shift","bind","dtmfSender","getOrCreateDTMFSender","insertDTMF","dtmfs","canInsertDTMF","sendMessage","InvalidStateError","callSid","set","currentVolume","currentStreak","lastValue","direction","wasWarningRaised","newStreak","cleanup","_createMetricPayload","call_sid","sdk_version","gateway","wasRemote","hangup","wasConnected","postMetrics","splice","EventEmitter","Codec","IceGatheringFailureReason","MessageType","replace","c","r","random","v","exports"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/@twilio/voice-sdk/lib/twilio/call.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @publicapi\n * @internal\n */\nimport { EventEmitter } from 'events';\nimport Backoff from './backoff';\nimport Device from './device';\nimport DialtonePlayer from './dialtonePlayer';\nimport {\n  GeneralErrors,\n  InvalidArgumentError,\n  InvalidStateError,\n  MediaErrors,\n  SignalingErrors,\n  TwilioError,\n  UserMediaErrors,\n} from './errors';\nimport Log from './log';\nimport { PeerConnection } from './rtc';\nimport { IceCandidate, RTCIceCandidate } from './rtc/icecandidate';\nimport RTCSample from './rtc/sample';\nimport { getPreferredCodecInfo } from './rtc/sdp';\nimport RTCWarning from './rtc/warning';\nimport StatsMonitor from './statsMonitor';\nimport { isChrome } from './util';\nimport { generateVoiceEventSid } from './uuid';\n\nconst { RELEASE_VERSION } = require('./constants');\n\n// Placeholders until we convert the respective files to TypeScript.\n/**\n * @private\n */\nexport type IAudioHelper = any;\n/**\n * @private\n */\nexport type IPStream = any;\n/**\n * @private\n */\nexport type IPeerConnection = any;\n/**\n * @private\n */\nexport type IPublisher = any;\n/**\n * @private\n */\nexport type ISound = any;\n\nconst BACKOFF_CONFIG = {\n  factor: 1.1,\n  jitter: 0.5,\n  max: 30000,\n  min: 1,\n};\n\nconst DTMF_INTER_TONE_GAP: number = 70;\nconst DTMF_PAUSE_DURATION: number = 500;\nconst DTMF_TONE_DURATION: number = 160;\n\nconst METRICS_BATCH_SIZE: number = 10;\nconst METRICS_DELAY: number = 5000;\n\nconst MEDIA_DISCONNECT_ERROR = {\n  disconnect: true,\n  info: {\n    code: 31003,\n    message: 'Connection with Twilio was interrupted.',\n    twilioError: new MediaErrors.ConnectionError(),\n  },\n};\n\nconst MULTIPLE_THRESHOLD_WARNING_NAMES: Record<string, Record<string, string>> = {\n  // The stat `packetsLostFraction` is monitored by two separate thresholds,\n  // `maxAverage` and `max`. Each threshold emits a different warning name.\n  packetsLostFraction: {\n    max: 'packet-loss',\n    maxAverage: 'packets-lost-fraction',\n  },\n};\n\nconst WARNING_NAMES: Record<string, string> = {\n  audioInputLevel: 'audio-input-level',\n  audioOutputLevel: 'audio-output-level',\n  bytesReceived: 'bytes-received',\n  bytesSent: 'bytes-sent',\n  jitter: 'jitter',\n  mos: 'mos',\n  rtt: 'rtt',\n};\n\nconst WARNING_PREFIXES: Record<string, string> = {\n  max: 'high-',\n  maxAverage: 'high-',\n  maxDuration: 'constant-',\n  min: 'low-',\n  minStandardDeviation: 'constant-',\n};\n\n/**\n * A {@link Call} represents a media and signaling connection to a TwiML application.\n * @publicapi\n */\nclass Call extends EventEmitter {\n  /**\n   * String representation of the {@link Call} class.\n   * @private\n   */\n  static toString = () => '[Twilio.Call class]';\n\n  /**\n   * Returns caller verification information about the caller.\n   * If no caller verification information is available this will return null.\n   */\n  readonly callerInfo: Call.CallerInfo | null;\n\n  /**\n   * The custom parameters sent to (outgoing) or received by (incoming) the TwiML app.\n   */\n  readonly customParameters: Map<string, string>;\n\n  /**\n   * Whether this {@link Call} is incoming or outgoing.\n   */\n  get direction(): Call.CallDirection {\n    return this._direction;\n  }\n\n  /**\n   * Audio codec used for this {@link Call}. Expecting {@link Call.Codec} but\n   * will copy whatever we get from RTC stats.\n   */\n  get codec(): string {\n    return this._codec;\n  }\n\n  /**\n   * The temporary CallSid for this call, if it's outbound.\n   */\n  readonly outboundConnectionId?: string;\n\n  /**\n   * Call parameters received from Twilio for an incoming call.\n   */\n  parameters: Record<string, string> = { };\n\n  /**\n   * Audio codec used for this {@link Call}. Expecting {@link Call.Codec} but\n   * will copy whatever we get from RTC stats.\n   */\n  private _codec: string;\n\n  /**\n   * Whether this {@link Call} is incoming or outgoing.\n   */\n  private readonly _direction: Call.CallDirection;\n\n  /**\n   * The number of times input volume has been the same consecutively.\n   */\n  private _inputVolumeStreak: number = 0;\n\n  /**\n   * Whether the call has been answered.\n   */\n  private _isAnswered: boolean = false;\n\n  /**\n   * Whether the call has been cancelled.\n   */\n  private _isCancelled: boolean = false;\n\n  /**\n   * Whether the call has been rejected\n   */\n  private _isRejected: boolean = false;\n\n  /**\n   * Whether or not the browser uses unified-plan SDP by default.\n   */\n  private readonly _isUnifiedPlanDefault: boolean | undefined;\n\n  /**\n   * The most recent public input volume value. 0 -> 1 representing -100 to -30 dB.\n   */\n  private _latestInputVolume: number = 0;\n\n  /**\n   * The most recent public output volume value. 0 -> 1 representing -100 to -30 dB.\n   */\n  private _latestOutputVolume: number = 0;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = Log.getInstance();\n\n  /**\n   * The MediaHandler (Twilio PeerConnection) this {@link Call} is using for\n   * media signaling.\n   */\n  private _mediaHandler: IPeerConnection;\n\n  /**\n   * An instance of Backoff for media reconnection\n   */\n  private _mediaReconnectBackoff: any;\n\n  /**\n   * Timestamp for the initial media reconnection\n   */\n  private _mediaReconnectStartTime: number;\n\n  /**\n   * State of the {@link Call}'s media.\n   */\n  private _mediaStatus: Call.State = Call.State.Pending;\n\n  /**\n   * A map of messages sent via sendMessage API using voiceEventSid as the key.\n   * The message will be deleted once an 'ack' or an error is received from the server.\n   */\n  private _messages: Map<string, Call.Message> = new Map();\n\n  /**\n   * A batch of metrics samples to send to Insights. Gets cleared after\n   * each send and appended to on each new sample.\n   */\n  private readonly _metricsSamples: Call.CallMetrics[] = [];\n\n  /**\n   * An instance of StatsMonitor.\n   */\n  private readonly _monitor: StatsMonitor;\n\n  /**\n   * Method to be run after {@link Call.ignore} is called.\n   */\n  private _onIgnore: () => void;\n\n  /**\n   * Options passed to this {@link Call}.\n   */\n  private _options: Call.Options = {\n    MediaHandler: PeerConnection,\n    offerSdp: null,\n    shouldPlayDisconnect: () => true,\n    voiceEventSidGenerator: generateVoiceEventSid,\n  };\n\n  /**\n   * The number of times output volume has been the same consecutively.\n   */\n  private _outputVolumeStreak: number = 0;\n\n  /**\n   * The PStream instance to use for Twilio call signaling.\n   */\n  private readonly _pstream: IPStream;\n\n  /**\n   * An instance of EventPublisher.\n   */\n  private readonly _publisher: IPublisher;\n\n  /**\n   * Whether the {@link Call} should send a hangup on disconnect.\n   */\n  private _shouldSendHangup: boolean = true;\n\n  /**\n   * The signaling reconnection token used to re-establish a lost signaling connection.\n   */\n  private _signalingReconnectToken: string | undefined;\n\n  /**\n   * State of the {@link Call}'s signaling.\n   */\n  private _signalingStatus: Call.State = Call.State.Pending;\n\n  /**\n   * A Map of Sounds to play.\n   */\n  private readonly _soundcache: Map<Device.SoundName, ISound> = new Map();\n\n  /**\n   * State of the {@link Call}.\n   */\n  private _status: Call.State = Call.State.Pending;\n\n  /**\n   * Voice event SID generator, creates a unique voice event SID.\n   */\n  private _voiceEventSidGenerator: () => string;\n\n  /**\n   * Whether the {@link Call} has been connected. Used to determine if we are reconnected.\n   */\n  private _wasConnected: boolean = false;\n\n  /**\n   * @constructor\n   * @private\n   * @param config - Mandatory configuration options\n   * @param [options] - Optional settings\n   */\n  constructor(config: Call.Config, options?: Call.Options) {\n    super();\n\n    this._isUnifiedPlanDefault = config.isUnifiedPlanDefault;\n    this._soundcache = config.soundcache;\n\n    if (typeof config.onIgnore === 'function') {\n      this._onIgnore = config.onIgnore;\n    }\n\n    const message = options && options.twimlParams || { };\n    this.customParameters = new Map(\n      Object.entries(message).map(([key, val]: [string, any]): [string, string] => [key, String(val)]));\n\n    Object.assign(this._options, options);\n\n    if (this._options.callParameters) {\n      this.parameters = this._options.callParameters;\n    }\n\n    if (this._options.reconnectToken) {\n      this._signalingReconnectToken = this._options.reconnectToken;\n    }\n\n    this._voiceEventSidGenerator =\n      this._options.voiceEventSidGenerator || generateVoiceEventSid;\n\n    this._direction = this.parameters.CallSid ? Call.CallDirection.Incoming : Call.CallDirection.Outgoing;\n\n    if (this._direction === Call.CallDirection.Incoming && this.parameters) {\n      this.callerInfo = this.parameters.StirStatus\n        ? { isVerified: this.parameters.StirStatus === 'TN-Validation-Passed-A' }\n        : null;\n    } else {\n      this.callerInfo = null;\n    }\n\n    this._mediaReconnectBackoff = new Backoff(BACKOFF_CONFIG);\n    this._mediaReconnectBackoff.on('ready', () => this._mediaHandler.iceRestart());\n\n    // temporary call sid to be used for outgoing calls\n    this.outboundConnectionId = generateTempCallSid();\n\n    const publisher = this._publisher = config.publisher;\n\n    if (this._direction === Call.CallDirection.Incoming) {\n      publisher.info('connection', 'incoming', null, this);\n    } else {\n      publisher.info('connection', 'outgoing', { preflight: this._options.preflight }, this);\n    }\n\n    const monitor = this._monitor = new (this._options.StatsMonitor || StatsMonitor)();\n    monitor.on('sample', this._onRTCSample);\n\n    // First 20 seconds or so are choppy, so let's not bother with these warnings.\n    monitor.disableWarnings();\n    setTimeout(() => monitor.enableWarnings(), METRICS_DELAY);\n\n    monitor.on('warning', (data: RTCWarning, wasCleared?: boolean) => {\n      if (data.name === 'bytesSent' || data.name === 'bytesReceived') {\n        this._onMediaFailure(Call.MediaFailure.LowBytes);\n      }\n      this._reemitWarning(data, wasCleared);\n    });\n    monitor.on('warning-cleared', (data: RTCWarning) => {\n      this._reemitWarningCleared(data);\n    });\n\n    this._mediaHandler = new (this._options.MediaHandler)\n      (config.audioHelper, config.pstream, config.getUserMedia, {\n        RTCPeerConnection: this._options.RTCPeerConnection,\n        codecPreferences: this._options.codecPreferences,\n        dscp: this._options.dscp,\n        forceAggressiveIceNomination: this._options.forceAggressiveIceNomination,\n        isUnifiedPlan: this._isUnifiedPlanDefault,\n        maxAverageBitrate: this._options.maxAverageBitrate,\n        preflight: this._options.preflight,\n      });\n\n    this.on('volume', (inputVolume: number, outputVolume: number): void => {\n      this._inputVolumeStreak = this._checkVolume(\n        inputVolume, this._inputVolumeStreak, this._latestInputVolume, 'input');\n      this._outputVolumeStreak = this._checkVolume(\n        outputVolume, this._outputVolumeStreak, this._latestOutputVolume, 'output');\n      this._latestInputVolume = inputVolume;\n      this._latestOutputVolume = outputVolume;\n    });\n\n    this._mediaHandler.onaudio = (remoteAudio: typeof Audio) => {\n      this._log.info('Remote audio created');\n      this.emit('audio', remoteAudio);\n    };\n\n    this._mediaHandler.onvolume = (inputVolume: number, outputVolume: number,\n                                   internalInputVolume: number, internalOutputVolume: number) => {\n      // (rrowland) These values mock the 0 -> 32767 format used by legacy getStats. We should look into\n      // migrating to a newer standard, either 0.0 -> linear or -127 to 0 in dB, matching the range\n      // chosen below.\n      monitor.addVolumes((internalInputVolume / 255) * 32767, (internalOutputVolume / 255) * 32767);\n\n      // (rrowland) 0.0 -> 1.0 linear\n      this.emit('volume', inputVolume, outputVolume);\n    };\n\n    this._mediaHandler.ondtlstransportstatechange = (state: string): void => {\n      const level = state === 'failed' ? 'error' : 'debug';\n      this._publisher.post(level, 'dtls-transport-state', state, null, this);\n    };\n\n    this._mediaHandler.onpcconnectionstatechange = (state: string): void => {\n      let level = 'debug';\n      const dtlsTransport = this._mediaHandler.getRTCDtlsTransport();\n\n      if (state === 'failed') {\n        level = dtlsTransport && dtlsTransport.state === 'failed' ? 'error' : 'warning';\n      }\n      this._publisher.post(level, 'pc-connection-state', state, null, this);\n    };\n\n    this._mediaHandler.onicecandidate = (candidate: RTCIceCandidate): void => {\n      const payload = new IceCandidate(candidate).toPayload();\n      this._publisher.debug('ice-candidate', 'ice-candidate', payload, this);\n    };\n\n    this._mediaHandler.onselectedcandidatepairchange = (pair: RTCIceCandidatePair): void => {\n      const localCandidatePayload = new IceCandidate(pair.local).toPayload();\n      const remoteCandidatePayload = new IceCandidate(pair.remote, true).toPayload();\n\n      this._publisher.debug('ice-candidate', 'selected-ice-candidate-pair', {\n        local_candidate: localCandidatePayload,\n        remote_candidate: remoteCandidatePayload,\n      }, this);\n    };\n\n    this._mediaHandler.oniceconnectionstatechange = (state: string): void => {\n      const level = state === 'failed' ? 'error' : 'debug';\n      this._publisher.post(level, 'ice-connection-state', state, null, this);\n    };\n\n    this._mediaHandler.onicegatheringfailure = (type: Call.IceGatheringFailureReason): void => {\n      this._publisher.warn('ice-gathering-state', type, null, this);\n      this._onMediaFailure(Call.MediaFailure.IceGatheringFailed);\n    };\n\n    this._mediaHandler.onicegatheringstatechange = (state: string): void => {\n      this._publisher.debug('ice-gathering-state', state, null, this);\n    };\n\n    this._mediaHandler.onsignalingstatechange = (state: string): void => {\n      this._publisher.debug('signaling-state', state, null, this);\n    };\n\n    this._mediaHandler.ondisconnected = (msg: string): void => {\n      this._log.info(msg);\n      this._publisher.warn('network-quality-warning-raised', 'ice-connectivity-lost', {\n        message: msg,\n      }, this);\n      this.emit('warning', 'ice-connectivity-lost');\n\n      this._onMediaFailure(Call.MediaFailure.ConnectionDisconnected);\n    };\n\n    this._mediaHandler.onfailed = (msg: string): void => {\n      this._onMediaFailure(Call.MediaFailure.ConnectionFailed);\n    };\n\n    this._mediaHandler.onconnected = (): void => {\n      // First time _mediaHandler is connected, but ICE Gathering issued an ICE restart and succeeded.\n      if (this._status === Call.State.Reconnecting) {\n        this._onMediaReconnected();\n      }\n    };\n\n    this._mediaHandler.onreconnected = (msg: string): void => {\n      this._log.info(msg);\n      this._publisher.info('network-quality-warning-cleared', 'ice-connectivity-lost', {\n        message: msg,\n      }, this);\n      this.emit('warning-cleared', 'ice-connectivity-lost');\n      this._onMediaReconnected();\n    };\n\n    this._mediaHandler.onerror = (e: any): void => {\n      if (e.disconnect === true) {\n        this._disconnect(e.info && e.info.message);\n      }\n\n      const error = e.info.twilioError || new GeneralErrors.UnknownError(e.info.message);\n      this._log.error('Received an error from MediaStream:', e);\n      this.emit('error', error);\n    };\n\n    this._mediaHandler.onopen = () => {\n      // NOTE(mroberts): While this may have been happening in previous\n      // versions of Chrome, since Chrome 45 we have seen the\n      // PeerConnection's onsignalingstatechange handler invoked multiple\n      // times in the same signalingState 'stable'. When this happens, we\n      // invoke this onopen function. If we invoke it twice without checking\n      // for _status 'open', we'd accidentally close the PeerConnection.\n      //\n      // See <https://code.google.com/p/webrtc/issues/detail?id=4996>.\n      if (this._status === Call.State.Open || this._status === Call.State.Reconnecting) {\n        return;\n      } else if (this._status === Call.State.Ringing || this._status === Call.State.Connecting) {\n        this.mute(false);\n        this._mediaStatus = Call.State.Open;\n        this._maybeTransitionToOpen();\n      } else {\n        // call was probably canceled sometime before this\n        this._mediaHandler.close();\n      }\n    };\n\n    this._mediaHandler.onclose = () => {\n      this._status = Call.State.Closed;\n      if (this._options.shouldPlayDisconnect && this._options.shouldPlayDisconnect()\n        // Don't play disconnect sound if this was from a cancel event. i.e. the call\n        // was ignored or hung up even before it was answered.\n        // Similarly, don't play disconnect sound if the call was rejected.\n        && !this._isCancelled && !this._isRejected) {\n\n        this._soundcache.get(Device.SoundName.Disconnect).play();\n      }\n\n      monitor.disable();\n      this._publishMetrics();\n\n      if (!this._isCancelled && !this._isRejected) {\n        // tslint:disable no-console\n        this.emit('disconnect', this);\n      }\n    };\n\n    this._pstream = config.pstream;\n    this._pstream.on('ack', this._onAck);\n    this._pstream.on('cancel', this._onCancel);\n    this._pstream.on('error', this._onSignalingError);\n    this._pstream.on('ringing', this._onRinging);\n    this._pstream.on('transportClose', this._onTransportClose);\n    this._pstream.on('connected', this._onConnected);\n    this._pstream.on('message', this._onMessageReceived);\n\n    this.on('error', error => {\n      this._publisher.error('connection', 'error', {\n        code: error.code, message: error.message,\n      }, this);\n\n      if (this._pstream && this._pstream.status === 'disconnected') {\n        this._cleanupEventListeners();\n      }\n    });\n\n    this.on('disconnect', () => {\n      this._cleanupEventListeners();\n    });\n  }\n\n  /**\n   * Set the audio input tracks from a given stream.\n   * @param stream\n   * @private\n   */\n  _setInputTracksFromStream(stream: MediaStream | null): Promise<void> {\n    return this._mediaHandler.setInputTracksFromStream(stream);\n  }\n\n  /**\n   * Set the audio output sink IDs.\n   * @param sinkIds\n   * @private\n   */\n  _setSinkIds(sinkIds: string[]): Promise<void> {\n    return this._mediaHandler._setSinkIds(sinkIds);\n  }\n\n  /**\n   * Accept the incoming {@link Call}.\n   * @param [options]\n   */\n  accept(options?: Call.AcceptOptions): void {\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n\n    options = options || { };\n    const rtcConfiguration = options.rtcConfiguration || this._options.rtcConfiguration;\n    const rtcConstraints = options.rtcConstraints || this._options.rtcConstraints || { };\n    const audioConstraints = rtcConstraints.audio || { audio: true };\n\n    this._status = Call.State.Connecting;\n\n    const connect = () => {\n      if (this._status !== Call.State.Connecting) {\n        // call must have been canceled\n        this._cleanupEventListeners();\n        this._mediaHandler.close();\n        return;\n      }\n\n      const onAnswer = (pc: RTCPeerConnection, reconnectToken?: string) => {\n        // Report that the call was answered, and directionality\n        const eventName = this._direction === Call.CallDirection.Incoming\n          ? 'accepted-by-local'\n          : 'accepted-by-remote';\n        this._publisher.info('connection', eventName, null, this);\n\n        if (typeof reconnectToken === 'string') {\n          this._signalingReconnectToken = reconnectToken;\n        }\n\n        // Report the preferred codec and params as they appear in the SDP\n        const { codecName, codecParams } = getPreferredCodecInfo(this._mediaHandler.version.getSDP());\n        this._publisher.info('settings', 'codec', {\n          codec_params: codecParams,\n          selected_codec: codecName,\n        }, this);\n\n        // Enable RTC monitoring\n        this._monitor.enable(pc);\n      };\n\n      const sinkIds = typeof this._options.getSinkIds === 'function' && this._options.getSinkIds();\n      if (Array.isArray(sinkIds)) {\n        this._mediaHandler._setSinkIds(sinkIds).catch(() => {\n          // (rrowland) We don't want this to throw to console since the customer\n          // can't control this. This will most commonly be rejected on browsers\n          // that don't support setting sink IDs.\n        });\n      }\n\n      this._pstream.addListener('hangup', this._onHangup);\n\n      if (this._direction === Call.CallDirection.Incoming) {\n        this._isAnswered = true;\n        this._pstream.on('answer', this._onAnswer);\n        this._mediaHandler.answerIncomingCall(this.parameters.CallSid, this._options.offerSdp,\n          rtcConstraints, rtcConfiguration, onAnswer);\n      } else {\n        const params = Array.from(this.customParameters.entries()).map(pair =>\n         `${encodeURIComponent(pair[0])}=${encodeURIComponent(pair[1])}`).join('&');\n        this._pstream.on('answer', this._onAnswer);\n        this._mediaHandler.makeOutgoingCall(this._pstream.token, params, this.outboundConnectionId,\n          rtcConstraints, rtcConfiguration, onAnswer);\n      }\n    };\n\n    if (this._options.beforeAccept) {\n      this._options.beforeAccept(this);\n    }\n\n    const inputStream = typeof this._options.getInputStream === 'function' && this._options.getInputStream();\n\n    const promise = inputStream\n      ? this._mediaHandler.setInputTracksFromStream(inputStream)\n      : this._mediaHandler.openWithConstraints(audioConstraints);\n\n    promise.then(() => {\n      this._publisher.info('get-user-media', 'succeeded', {\n        data: { audioConstraints },\n      }, this);\n\n      connect();\n    }, (error: Record<string, any>) => {\n      let twilioError;\n\n      if (error.code === 31208\n        || ['PermissionDeniedError', 'NotAllowedError'].indexOf(error.name) !== -1) {\n        twilioError = new UserMediaErrors.PermissionDeniedError();\n        this._publisher.error('get-user-media', 'denied', {\n          data: {\n            audioConstraints,\n            error,\n          },\n        }, this);\n      } else {\n        twilioError = new UserMediaErrors.AcquisitionFailedError();\n\n        this._publisher.error('get-user-media', 'failed', {\n          data: {\n            audioConstraints,\n            error,\n          },\n        }, this);\n      }\n\n      this._disconnect();\n      this.emit('error', twilioError);\n    });\n  }\n\n  /**\n   * Disconnect from the {@link Call}.\n   */\n  disconnect(): void {\n    this._disconnect();\n  }\n\n  /**\n   * Get the local MediaStream, if set.\n   */\n  getLocalStream(): MediaStream | undefined {\n    return this._mediaHandler && this._mediaHandler.stream;\n  }\n\n  /**\n   * Get the remote MediaStream, if set.\n   */\n  getRemoteStream(): MediaStream | undefined {\n    return this._mediaHandler && this._mediaHandler._remoteStream;\n  }\n\n  /**\n   * Ignore the incoming {@link Call}.\n   */\n  ignore(): void {\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n\n    this._status = Call.State.Closed;\n    this._mediaHandler.ignore(this.parameters.CallSid);\n    this._publisher.info('connection', 'ignored-by-local', null, this);\n\n    if (this._onIgnore) {\n      this._onIgnore();\n    }\n  }\n\n  /**\n   * Check whether call is muted\n   */\n  isMuted(): boolean {\n    return this._mediaHandler.isMuted;\n  }\n\n  /**\n   * Mute incoming audio.\n   * @param shouldMute - Whether the incoming audio should be muted. Defaults to true.\n   */\n  mute(shouldMute: boolean = true): void {\n    const wasMuted = this._mediaHandler.isMuted;\n    this._mediaHandler.mute(shouldMute);\n\n    const isMuted = this._mediaHandler.isMuted;\n    if (wasMuted !== isMuted) {\n      this._publisher.info('connection', isMuted ? 'muted' : 'unmuted', null, this);\n      this.emit('mute', isMuted, this);\n    }\n  }\n\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has given call quality feedback. Called without a score, this\n   *   will report that the customer declined to give feedback.\n   * @param score - The end-user's rating of the call; an\n   *   integer 1 through 5. Or undefined if the user declined to give\n   *   feedback.\n   * @param issue - The primary issue the end user\n   *   experienced on the call. Can be: ['one-way-audio', 'choppy-audio',\n   *   'dropped-call', 'audio-latency', 'noisy-call', 'echo']\n   */\n  postFeedback(score?: Call.FeedbackScore, issue?: Call.FeedbackIssue): Promise<void> {\n    if (typeof score === 'undefined' || score === null) {\n      return this._postFeedbackDeclined();\n    }\n\n    if (!Object.values(Call.FeedbackScore).includes(score)) {\n      throw new InvalidArgumentError(`Feedback score must be one of: ${Object.values(Call.FeedbackScore)}`);\n    }\n\n    if (typeof issue !== 'undefined' && issue !== null && !Object.values(Call.FeedbackIssue).includes(issue)) {\n      throw new InvalidArgumentError(`Feedback issue must be one of: ${Object.values(Call.FeedbackIssue)}`);\n    }\n\n    return this._publisher.info('feedback', 'received', {\n      issue_name: issue,\n      quality_score: score,\n    }, this, true);\n  }\n\n  /**\n   * Reject the incoming {@link Call}.\n   */\n  reject(): void {\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n\n    this._isRejected = true;\n    this._pstream.reject(this.parameters.CallSid);\n    this._mediaHandler.reject(this.parameters.CallSid);\n    this._publisher.info('connection', 'rejected-by-local', null, this);\n    this._cleanupEventListeners();\n    this._mediaHandler.close();\n    this._status = Call.State.Closed;\n    this.emit('reject');\n  }\n\n  /**\n   * Send a string of digits.\n   * @param digits\n   */\n  sendDigits(digits: string): void {\n    if (digits.match(/[^0-9*#w]/)) {\n      throw new InvalidArgumentError('Illegal character passed into sendDigits');\n    }\n\n    const sequence: string[] = [];\n    digits.split('').forEach((digit: string) => {\n      let dtmf = (digit !== 'w') ? `dtmf${digit}` : '';\n      if (dtmf === 'dtmf*') { dtmf = 'dtmfs'; }\n      if (dtmf === 'dtmf#') { dtmf = 'dtmfh'; }\n      sequence.push(dtmf);\n    });\n\n    // Binds soundCache to be used in recursion until all digits have been played.\n    (function playNextDigit(soundCache, dialtonePlayer) {\n      const digit: string | undefined = sequence.shift();\n\n      if (digit) {\n        if (dialtonePlayer) {\n          dialtonePlayer.play(digit);\n        } else {\n          soundCache.get(digit as Device.SoundName).play();\n        }\n      }\n\n      if (sequence.length) {\n        setTimeout(playNextDigit.bind(null, soundCache), 200);\n      }\n    })(this._soundcache, this._options.dialtonePlayer);\n\n    const dtmfSender = this._mediaHandler.getOrCreateDTMFSender();\n\n    function insertDTMF(dtmfs: string[]) {\n      if (!dtmfs.length) { return; }\n      const dtmf: string | undefined = dtmfs.shift();\n\n      if (dtmf && dtmf.length) {\n        dtmfSender.insertDTMF(dtmf, DTMF_TONE_DURATION, DTMF_INTER_TONE_GAP);\n      }\n\n      setTimeout(insertDTMF.bind(null, dtmfs), DTMF_PAUSE_DURATION);\n    }\n\n    if (dtmfSender) {\n      if (!('canInsertDTMF' in dtmfSender) || dtmfSender.canInsertDTMF) {\n        this._log.info('Sending digits using RTCDTMFSender');\n        // NOTE(mroberts): We can't just map 'w' to ',' since\n        // RTCDTMFSender's pause duration is 2 s and Twilio's is more\n        // like 500 ms. Instead, we will fudge it with setTimeout.\n        insertDTMF(digits.split('w'));\n        return;\n      }\n\n      this._log.info('RTCDTMFSender cannot insert DTMF');\n    }\n\n    // send pstream message to send DTMF\n    this._log.info('Sending digits over PStream');\n\n    if (this._pstream !== null && this._pstream.status !== 'disconnected') {\n      this._pstream.dtmf(this.parameters.CallSid, digits);\n    } else {\n      const error = new GeneralErrors.ConnectionError('Could not send DTMF: Signaling channel is disconnected');\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Send a message to Twilio. Your backend application can listen for these\n   * messages to allow communication between your frontend and backend applications.\n   * <br/><br/>This feature is currently in Beta.\n   * @param message - The message object to send.\n   * @returns A voice event sid that uniquely identifies the message that was sent.\n   */\n  sendMessage(message: Call.Message): string {\n    const { content, contentType, messageType } = message;\n\n    if (typeof content === 'undefined' || content === null) {\n      throw new InvalidArgumentError('`content` is empty');\n    }\n\n    if (typeof messageType !== 'string') {\n      throw new InvalidArgumentError(\n        '`messageType` must be an enumeration value of `Call.MessageType` or ' +\n        'a string.',\n      );\n    }\n\n    if (messageType.length === 0) {\n      throw new InvalidArgumentError(\n        '`messageType` must be a non-empty string.',\n      );\n    }\n\n    if (this._pstream === null) {\n      throw new InvalidStateError(\n        'Could not send CallMessage; Signaling channel is disconnected',\n      );\n    }\n\n    const callSid = this.parameters.CallSid;\n    if (typeof this.parameters.CallSid === 'undefined') {\n      throw new InvalidStateError(\n        'Could not send CallMessage; Call has no CallSid',\n      );\n    }\n\n    const voiceEventSid = this._voiceEventSidGenerator();\n    this._messages.set(voiceEventSid, { content, contentType, messageType, voiceEventSid });\n    this._pstream.sendMessage(callSid, content, contentType, messageType, voiceEventSid);\n    return voiceEventSid;\n  }\n\n  /**\n   * Get the current {@link Call} status.\n   */\n  status(): Call.State {\n    return this._status;\n  }\n\n  /**\n   * String representation of {@link Call} instance.\n   * @private\n   */\n  toString = () => '[Twilio.Call instance]';\n\n  /**\n   * Check the volume passed, emitting a warning if one way audio is detected or cleared.\n   * @param currentVolume - The current volume for this direction\n   * @param streakFieldName - The name of the field on the {@link Call} object that tracks how many times the\n   *   current value has been repeated consecutively.\n   * @param lastValueFieldName - The name of the field on the {@link Call} object that tracks the most recent\n   *   volume for this direction\n   * @param direction - The directionality of this audio track, either 'input' or 'output'\n   * @returns The current streak; how many times in a row the same value has been polled.\n   */\n  private _checkVolume(currentVolume: number, currentStreak: number,\n                       lastValue: number, direction: 'input'|'output'): number {\n    const wasWarningRaised: boolean = currentStreak >= 10;\n    let newStreak: number = 0;\n\n    if (lastValue === currentVolume) {\n      newStreak = currentStreak;\n    }\n\n    if (newStreak >= 10) {\n      this._emitWarning('audio-level-', `constant-audio-${direction}-level`, 10, newStreak, false);\n    } else if (wasWarningRaised) {\n      this._emitWarning('audio-level-', `constant-audio-${direction}-level`, 10, newStreak, true);\n    }\n\n    return newStreak;\n  }\n\n  /**\n   * Clean up event listeners.\n   */\n  private _cleanupEventListeners(): void {\n    const cleanup = () => {\n      if (!this._pstream) { return; }\n\n      this._pstream.removeListener('ack', this._onAck);\n      this._pstream.removeListener('answer', this._onAnswer);\n      this._pstream.removeListener('cancel', this._onCancel);\n      this._pstream.removeListener('error', this._onSignalingError);\n      this._pstream.removeListener('hangup', this._onHangup);\n      this._pstream.removeListener('ringing', this._onRinging);\n      this._pstream.removeListener('transportClose', this._onTransportClose);\n      this._pstream.removeListener('connected', this._onConnected);\n      this._pstream.removeListener('message', this._onMessageReceived);\n    };\n\n    // This is kind of a hack, but it lets us avoid rewriting more code.\n    // Basically, there's a sequencing problem with the way PeerConnection raises\n    // the\n    //\n    //   Cannot establish call. SDK is disconnected\n    //\n    // error in Call#accept. It calls PeerConnection#onerror, which emits\n    // the error event on Call. An error handler on Call then calls\n    // cleanupEventListeners, but then control returns to Call#accept. It's\n    // at this point that we add a listener for the answer event that never gets\n    // removed. setTimeout will allow us to rerun cleanup again, _after_\n    // Call#accept returns.\n    cleanup();\n    setTimeout(cleanup, 0);\n  }\n\n  /**\n   * Create the payload wrapper for a batch of metrics to be sent to Insights.\n   */\n  private _createMetricPayload(): Partial<Record<string, string|boolean>> {\n    const payload: Partial<Record<string, string|boolean>> = {\n      call_sid: this.parameters.CallSid,\n      dscp: !!this._options.dscp,\n      sdk_version: RELEASE_VERSION,\n    };\n\n    if (this._options.gateway) {\n      payload.gateway = this._options.gateway;\n    }\n\n    payload.direction = this._direction;\n    return payload;\n  }\n\n  /**\n   * Disconnect the {@link Call}.\n   * @param message - A message explaining why the {@link Call} is being disconnected.\n   * @param wasRemote - Whether the disconnect was triggered locally or remotely.\n   */\n  private _disconnect(message?: string | null, wasRemote?: boolean): void {\n    message = typeof message === 'string' ? message : null;\n\n    if (this._status !== Call.State.Open\n        && this._status !== Call.State.Connecting\n        && this._status !== Call.State.Reconnecting\n        && this._status !== Call.State.Ringing) {\n      return;\n    }\n\n    this._log.info('Disconnecting...');\n\n    // send pstream hangup message\n    if (this._pstream !== null && this._pstream.status !== 'disconnected' && this._shouldSendHangup) {\n      const callsid: string | undefined = this.parameters.CallSid || this.outboundConnectionId;\n      if (callsid) {\n        this._pstream.hangup(callsid, message);\n      }\n    }\n\n    this._cleanupEventListeners();\n    this._mediaHandler.close();\n\n    if (!wasRemote) {\n      this._publisher.info('connection', 'disconnected-by-local', null, this);\n    }\n  }\n\n  private _emitWarning = (groupPrefix: string, warningName: string, threshold: number,\n                          value: number|number[], wasCleared?: boolean, warningData?: RTCWarning): void => {\n    const groupSuffix = wasCleared ? '-cleared' : '-raised';\n    const groupName = `${groupPrefix}warning${groupSuffix}`;\n\n    // Ignore constant input if the Call is muted (Expected)\n    if (warningName === 'constant-audio-input-level' && this.isMuted()) {\n      return;\n    }\n\n    let level = wasCleared ? 'info' : 'warning';\n\n    // Avoid throwing false positives as warnings until we refactor volume metrics\n    if (warningName === 'constant-audio-output-level') {\n      level = 'info';\n    }\n\n    const payloadData: Record<string, any> = { threshold };\n\n    if (value) {\n      if (value instanceof Array) {\n        payloadData.values = value.map((val: any) => {\n          if (typeof val === 'number') {\n            return Math.round(val * 100) / 100;\n          }\n\n          return value;\n        });\n      } else {\n        payloadData.value = value;\n      }\n    }\n\n    this._publisher.post(level, groupName, warningName, { data: payloadData }, this);\n\n    if (warningName !== 'constant-audio-output-level') {\n      const emitName = wasCleared ? 'warning-cleared' : 'warning';\n      this.emit(emitName, warningName, warningData && !wasCleared ? warningData : null);\n    }\n  }\n\n  /**\n   * Transition to {@link CallStatus.Open} if criteria is met.\n   */\n  private _maybeTransitionToOpen(): void {\n    const wasConnected = this._wasConnected;\n    if (this._isAnswered) {\n      this._onSignalingReconnected();\n      this._signalingStatus = Call.State.Open;\n      if (this._mediaHandler && this._mediaHandler.status === 'open') {\n        this._status = Call.State.Open;\n        if (!this._wasConnected) {\n          this._wasConnected = true;\n          this.emit('accept', this);\n        }\n      }\n    }\n  }\n\n  /**\n   * Called when the {@link Call} receives an ack from signaling\n   * @param payload\n   */\n  private _onAck = (payload: Record<string, any>): void => {\n    const { acktype, callsid, voiceeventsid } = payload;\n    if (this.parameters.CallSid !== callsid) {\n      this._log.warn(`Received ack from a different callsid: ${callsid}`);\n      return;\n    }\n    if (acktype === 'message') {\n      this._onMessageSent(voiceeventsid);\n    }\n  }\n\n  /**\n   * Called when the {@link Call} is answered.\n   * @param payload\n   */\n  private _onAnswer = (payload: Record<string, any>): void => {\n    if (typeof payload.reconnect === 'string') {\n      this._signalingReconnectToken = payload.reconnect;\n    }\n\n    // answerOnBridge=false will send a 183 which we need to catch in _onRinging when\n    // the enableRingingState flag is disabled. In that case, we will receive a 200 after\n    // the callee accepts the call firing a second `accept` event if we don't\n    // short circuit here.\n    if (this._isAnswered && this._status !== Call.State.Reconnecting) {\n      return;\n    }\n\n    this._setCallSid(payload);\n    this._isAnswered = true;\n    this._maybeTransitionToOpen();\n  }\n\n  /**\n   * Called when the {@link Call} is cancelled.\n   * @param payload\n   */\n  private _onCancel = (payload: Record<string, any>): void => {\n    // (rrowland) Is this check necessary? Verify, and if so move to pstream / VSP module.\n    const callsid = payload.callsid;\n    if (this.parameters.CallSid === callsid) {\n      this._isCancelled = true;\n      this._publisher.info('connection', 'cancel', null, this);\n      this._cleanupEventListeners();\n      this._mediaHandler.close();\n\n      this._status = Call.State.Closed;\n      this.emit('cancel');\n      this._pstream.removeListener('cancel', this._onCancel);\n    }\n  }\n\n  /**\n   * Called when we receive a connected event from pstream.\n   * Re-emits the event.\n   */\n  private _onConnected = (): void => {\n    this._log.info('Received connected from pstream');\n    if (this._signalingReconnectToken) {\n      this._pstream.reconnect(\n        this._mediaHandler.version.getSDP(),\n        this.parameters.CallSid,\n        this._signalingReconnectToken,\n      );\n    }\n  }\n\n  /**\n   * Called when the {@link Call} is hung up.\n   * @param payload\n   */\n  private _onHangup = (payload: Record<string, any>): void => {\n    if (this.status() === Call.State.Closed) {\n      return;\n    }\n\n    /**\n     *  see if callsid passed in message matches either callsid or outbound id\n     *  call should always have either callsid or outbound id\n     *  if no callsid passed hangup anyways\n     */\n    if (payload.callsid && (this.parameters.CallSid || this.outboundConnectionId)) {\n      if (payload.callsid !== this.parameters.CallSid\n          && payload.callsid !== this.outboundConnectionId) {\n        return;\n      }\n    } else if (payload.callsid) {\n      // hangup is for another call\n      return;\n    }\n\n    this._log.info('Received HANGUP from gateway');\n    if (payload.error) {\n      const error = new GeneralErrors.ConnectionError('Error sent from gateway in HANGUP');\n      this._log.error('Received an error from the gateway:', error);\n      this.emit('error', error);\n    }\n    this._shouldSendHangup = false;\n    this._publisher.info('connection', 'disconnected-by-remote', null, this);\n    this._disconnect(null, true);\n    this._cleanupEventListeners();\n  }\n\n  /**\n   * Called when there is a media failure.\n   * Manages all media-related states and takes action base on the states\n   * @param type - Type of media failure\n   */\n  private _onMediaFailure = (type: Call.MediaFailure): void => {\n    const {\n      ConnectionDisconnected, ConnectionFailed, IceGatheringFailed, LowBytes,\n    } = Call.MediaFailure;\n\n    // These types signifies the end of a single ICE cycle\n    const isEndOfIceCycle = type === ConnectionFailed || type === IceGatheringFailed;\n\n    // All browsers except chrome doesn't update pc.iceConnectionState and pc.connectionState\n    // after issuing an ICE Restart, which we use to determine if ICE Restart is complete.\n    // Since we cannot detect if ICE Restart is complete, we will not retry.\n    if (!isChrome(window, window.navigator) && type === ConnectionFailed) {\n      return this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n    }\n\n    // Ignore subsequent requests if ice restart is in progress\n    if (this._mediaStatus === Call.State.Reconnecting) {\n\n      // This is a retry. Previous ICE Restart failed\n      if (isEndOfIceCycle) {\n\n        // We already exceeded max retry time.\n        if (Date.now() - this._mediaReconnectStartTime > BACKOFF_CONFIG.max) {\n          this._log.info('Exceeded max ICE retries');\n          return this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n        }\n\n        // Issue ICE restart with backoff\n        try {\n          this._mediaReconnectBackoff.backoff();\n        } catch (error) {\n          // Catch and ignore 'Backoff in progress.' errors. If a backoff is\n          // ongoing and we try to start another one, there shouldn't be a\n          // problem.\n          if (!(error.message && error.message === 'Backoff in progress.')) {\n            throw error;\n          }\n        }\n      }\n\n      return;\n    }\n\n    const pc = this._mediaHandler.version.pc;\n    const isIceDisconnected = pc && pc.iceConnectionState === 'disconnected';\n    const hasLowBytesWarning = this._monitor.hasActiveWarning('bytesSent', 'min')\n      || this._monitor.hasActiveWarning('bytesReceived', 'min');\n\n    // Only certain conditions can trigger media reconnection\n    if ((type === LowBytes && isIceDisconnected)\n      || (type === ConnectionDisconnected && hasLowBytesWarning)\n      || isEndOfIceCycle) {\n\n      const mediaReconnectionError = new MediaErrors.ConnectionError('Media connection failed.');\n      this._log.warn('ICE Connection disconnected.');\n      this._publisher.warn('connection', 'error', mediaReconnectionError, this);\n      this._publisher.info('connection', 'reconnecting', null, this);\n\n      this._mediaReconnectStartTime = Date.now();\n      this._status = Call.State.Reconnecting;\n      this._mediaStatus = Call.State.Reconnecting;\n      this._mediaReconnectBackoff.reset();\n      this._mediaReconnectBackoff.backoff();\n\n      this.emit('reconnecting', mediaReconnectionError);\n    }\n  }\n\n  /**\n   * Called when media call is restored\n   */\n  private _onMediaReconnected = (): void => {\n    // Only trigger once.\n    // This can trigger on pc.onIceConnectionChange and pc.onConnectionChange.\n    if (this._mediaStatus !== Call.State.Reconnecting) {\n      return;\n    }\n    this._log.info('ICE Connection reestablished.');\n    this._mediaStatus = Call.State.Open;\n\n    if (this._signalingStatus === Call.State.Open) {\n      this._publisher.info('connection', 'reconnected', null, this);\n      this.emit('reconnected');\n      this._status = Call.State.Open;\n    }\n  }\n\n  /**\n   * Raised when a Call receives a message from the backend.\n   * @param payload - A record representing the payload of the message from the\n   * Twilio backend.\n   */\n  private _onMessageReceived = (payload: Record<string, any>): void => {\n    const { callsid, content, contenttype, messagetype, voiceeventsid } = payload;\n\n    if (this.parameters.CallSid !== callsid) {\n      this._log.warn(`Received a message from a different callsid: ${callsid}`);\n      return;\n    }\n\n    this.emit('messageReceived', {\n      content,\n      contentType: contenttype,\n      messageType: messagetype,\n      voiceEventSid: voiceeventsid,\n    });\n  }\n\n  /**\n   * Raised when a Call receives an 'ack' with an 'acktype' of 'message.\n   * This means that the message sent via sendMessage API has been received by the signaling server.\n   * @param voiceEventSid\n   */\n  private _onMessageSent = (voiceEventSid: string): void => {\n    if (!this._messages.has(voiceEventSid)) {\n      this._log.warn(`Received a messageSent with a voiceEventSid that doesn't exists: ${voiceEventSid}`);\n      return;\n    }\n    const message = this._messages.get(voiceEventSid);\n    this._messages.delete(voiceEventSid);\n    this.emit('messageSent', message);\n  }\n\n  /**\n   * When we get a RINGING signal from PStream, update the {@link Call} status.\n   * @param payload\n   */\n  private _onRinging = (payload: Record<string, any>): void => {\n    this._setCallSid(payload);\n\n    // If we're not in 'connecting' or 'ringing' state, this event was received out of order.\n    if (this._status !== Call.State.Connecting && this._status !== Call.State.Ringing) {\n      return;\n    }\n\n    const hasEarlyMedia = !!payload.sdp;\n    this._status = Call.State.Ringing;\n    this._publisher.info('connection', 'outgoing-ringing', { hasEarlyMedia }, this);\n    this.emit('ringing', hasEarlyMedia);\n  }\n\n  /**\n   * Called each time StatsMonitor emits a sample.\n   * Emits stats event and batches the call stats metrics and sends them to Insights.\n   * @param sample\n   */\n  private _onRTCSample = (sample: RTCSample): void => {\n    const callMetrics: Call.CallMetrics = {\n      ...sample,\n      inputVolume: this._latestInputVolume,\n      outputVolume: this._latestOutputVolume,\n    };\n\n    this._codec = callMetrics.codecName;\n\n    this._metricsSamples.push(callMetrics);\n    if (this._metricsSamples.length >= METRICS_BATCH_SIZE) {\n      this._publishMetrics();\n    }\n\n    this.emit('sample', sample);\n  }\n\n  /**\n   * Called when an 'error' event is received from the signaling stream.\n   */\n  private _onSignalingError = (payload: Record<string, any>): void => {\n    const { callsid, voiceeventsid } = payload;\n    if (this.parameters.CallSid !== callsid) {\n      this._log.warn(`Received an error from a different callsid: ${callsid}`);\n      return;\n    }\n    if (voiceeventsid && this._messages.has(voiceeventsid)) {\n      // Do not emit an error here. Device is handling all signaling related errors.\n      this._messages.delete(voiceeventsid);\n      this._log.warn(`Received an error while sending a message.`, payload);\n    }\n   }\n\n  /**\n   * Called when signaling is restored\n   */\n  private _onSignalingReconnected = (): void => {\n    if (this._signalingStatus !== Call.State.Reconnecting) {\n      return;\n    }\n    this._log.info('Signaling Connection reestablished.');\n\n    this._signalingStatus = Call.State.Open;\n\n    if (this._mediaStatus === Call.State.Open) {\n      this._publisher.info('connection', 'reconnected', null, this);\n      this.emit('reconnected');\n      this._status = Call.State.Open;\n    }\n  }\n\n  /**\n   * Called when we receive a transportClose event from pstream.\n   * Re-emits the event.\n   */\n  private _onTransportClose = (): void => {\n    this._log.error('Received transportClose from pstream');\n    this.emit('transportClose');\n    if (this._signalingReconnectToken) {\n      this._status = Call.State.Reconnecting;\n      this._signalingStatus = Call.State.Reconnecting;\n      this.emit('reconnecting', new SignalingErrors.ConnectionDisconnected());\n    } else {\n      this._status = Call.State.Closed;\n      this._signalingStatus = Call.State.Closed;\n    }\n  }\n\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has ignored a request for feedback.\n   */\n  private _postFeedbackDeclined(): Promise<void> {\n    return this._publisher.info('feedback', 'received-none', null, this, true);\n  }\n\n  /**\n   * Publish the current set of queued metrics samples to Insights.\n   */\n  private _publishMetrics(): void {\n    if (this._metricsSamples.length === 0) {\n      return;\n    }\n\n    this._publisher.postMetrics(\n      'quality-metrics-samples', 'metrics-sample', this._metricsSamples.splice(0), this._createMetricPayload(), this,\n    ).catch((e: any) => {\n      this._log.warn('Unable to post metrics to Insights. Received error:', e);\n    });\n  }\n\n  /**\n   * Re-emit an StatsMonitor warning as a {@link Call}.warning or .warning-cleared event.\n   * @param warningData\n   * @param wasCleared - Whether this is a -cleared or -raised event.\n   */\n  private _reemitWarning = (warningData: Record<string, any>, wasCleared?: boolean): void => {\n    const groupPrefix = /^audio/.test(warningData.name) ?\n      'audio-level-' : 'network-quality-';\n\n    const warningPrefix = WARNING_PREFIXES[warningData.threshold.name];\n\n    /**\n     * NOTE: There are two \"packet-loss\" warnings: `high-packet-loss` and\n     * `high-packets-lost-fraction`, so in this case we need to use a different\n     * `WARNING_NAME` mapping.\n     */\n    let warningName: string | undefined;\n    if (warningData.name in MULTIPLE_THRESHOLD_WARNING_NAMES) {\n      warningName = MULTIPLE_THRESHOLD_WARNING_NAMES[warningData.name][warningData.threshold.name];\n    } else if (warningData.name in WARNING_NAMES) {\n      warningName = WARNING_NAMES[warningData.name];\n    }\n\n    const warning: string = warningPrefix + warningName;\n\n    this._emitWarning(groupPrefix, warning, warningData.threshold.value,\n                      warningData.values || warningData.value, wasCleared, warningData);\n  }\n\n  /**\n   * Re-emit an StatsMonitor warning-cleared as a .warning-cleared event.\n   * @param warningData\n   */\n  private _reemitWarningCleared = (warningData: Record<string, any>): void => {\n    this._reemitWarning(warningData, true);\n  }\n\n  /**\n   * Set the CallSid\n   * @param payload\n   */\n  private _setCallSid(payload: Record<string, string>): void {\n    const callSid = payload.callsid;\n    if (!callSid) { return; }\n\n    this.parameters.CallSid = callSid;\n    this._mediaHandler.callSid = callSid;\n  }\n}\n\nnamespace Call {\n  /**\n   * Emitted when the {@link Call} is accepted.\n   * @param call - The {@link Call}.\n   * @example `call.on('accept', call => { })`\n   * @event\n   */\n  declare function acceptEvent(call: Call): void;\n\n  /**\n   * Emitted after the HTMLAudioElement for the remote audio is created.\n   * @param remoteAudio - The HTMLAudioElement.\n   * @example `call.on('audio', handler(remoteAudio))`\n   * @event\n   */\n  declare function audioEvent(remoteAudio: HTMLAudioElement): void;\n\n  /**\n   * Emitted when the {@link Call} is canceled.\n   * @example `call.on('cancel', () => { })`\n   * @event\n   */\n  declare function cancelEvent(): void;\n\n  /**\n   * Emitted when the {@link Call} is disconnected.\n   * @param call - The {@link Call}.\n   * @example `call.on('disconnect', call => { })`\n   * @event\n   */\n  declare function disconnectEvent(call: Call): void;\n\n  /**\n   * Emitted when the {@link Call} receives an error.\n   * @param error\n   * @example `call.on('error', error => { })`\n   * @event\n   */\n  declare function errorEvent(error: TwilioError): void;\n\n  /**\n   * Emitted when a Call receives a message from the backend.\n   * <br/><br/>This feature is currently in Beta.\n   * @param message - A message object representing the payload\n   * that was received from the Twilio backend.\n   * @event\n   */\n  declare function messageReceivedEvent(message: Call.Message): void;\n\n  /**\n   * Emitted after calling the {@link Call.sendMessage} API.\n   * This event indicates that Twilio has received the message.\n   * <br/><br/>This feature is currently in Beta.\n   * @param message - A message object that was sent to the Twilio backend.\n   * @event\n   */\n  declare function messageSentEvent(message: Call.Message): void;\n\n  /**\n   * Emitted when the {@link Call} is muted or unmuted.\n   * @param isMuted - Whether the {@link Call} is muted.\n   * @param call - The {@link Call}.\n   * @example `call.on('mute', (isMuted, call) => { })`\n   * @event\n   */\n  declare function muteEvent(isMuted: boolean, call: Call): void;\n\n  /**\n   * Emitted when the {@link Call} has regained media connectivity.\n   * @example `call.on('reconnected', () => { })`\n   * @event\n   */\n  declare function reconnectedEvent(): void;\n\n  /**\n   * Emitted when the {@link Call} has lost media connectivity and is reconnecting.\n   * @param error - The {@link TwilioError} that caused the media connectivity loss\n   * @example `call.on('reconnecting', error => { })`\n   * @event\n   */\n  declare function reconnectingEvent(error: TwilioError): void;\n\n  /**\n   * Emitted when the {@link Call} is rejected.\n   * @example `call.on('reject', () => { })`\n   * @event\n   */\n  declare function rejectEvent(): void;\n\n  /**\n   * Emitted every 50ms with the current input and output volumes, as a percentage of maximum\n   * volume, between -100dB and -30dB. Represented by a floating point number.\n   * @param inputVolume - A floating point number between 0.0 and 1.0 inclusive.\n   * @param outputVolume - A floating point number between 0.0 and 1.0 inclusive.\n   * @example `call.on('volume', (inputVolume, outputVolume) => { })`\n   * @event\n   */\n  declare function volumeEvent(inputVolume: number, outputVolume: number): void;\n\n  /**\n   * Emitted when the {@link Call} gets a webrtc sample object.\n   * This event is published every second.\n   * @param sample\n   * @example `call.on('sample', sample => { })`\n   * @event\n   */\n  declare function sampleEvent(sample: RTCSample): void;\n\n  /**\n   * Possible states of the {@link Call}.\n   */\n  export enum State {\n    Closed = 'closed',\n    Connecting = 'connecting',\n    Open = 'open',\n    Pending = 'pending',\n    Reconnecting = 'reconnecting',\n    Ringing = 'ringing',\n  }\n\n  /**\n   * Different issues that may have been experienced during a call, that can be\n   * reported to Twilio Insights via {@link Call}.postFeedback().\n   */\n  export enum FeedbackIssue {\n    AudioLatency = 'audio-latency',\n    ChoppyAudio = 'choppy-audio',\n    DroppedCall = 'dropped-call',\n    Echo = 'echo',\n    NoisyCall = 'noisy-call',\n    OneWayAudio = 'one-way-audio',\n  }\n\n  /**\n   * A rating of call quality experienced during a call, to be reported to Twilio Insights\n   * via {@link Call}.postFeedback().\n   */\n  export enum FeedbackScore {\n    One = 1,\n    Two,\n    Three,\n    Four,\n    Five,\n  }\n\n  /**\n   * The directionality of the {@link Call}, whether incoming or outgoing.\n   */\n  export enum CallDirection {\n    Incoming = 'INCOMING',\n    Outgoing = 'OUTGOING',\n  }\n\n  /**\n   * Valid audio codecs to use for the media connection.\n   */\n  export enum Codec {\n    Opus = 'opus',\n    PCMU = 'pcmu',\n  }\n\n  /**\n   * Possible ICE Gathering failures\n   */\n  export enum IceGatheringFailureReason {\n    None = 'none',\n    Timeout = 'timeout',\n  }\n\n  /**\n   * Possible media failures\n   */\n  export enum MediaFailure {\n    ConnectionDisconnected = 'ConnectionDisconnected',\n    ConnectionFailed = 'ConnectionFailed',\n    IceGatheringFailed = 'IceGatheringFailed',\n    LowBytes = 'LowBytes',\n  }\n\n  /**\n   * Known call message types.\n   */\n  export enum MessageType {\n    /**\n     * Allows for any object types to be defined by the user.\n     * When this value is used in the {@link Call.Message} object,\n     * The {@link Call.Message.content} can be of any type as long as\n     * it matches the MIME type defined in {@link Call.Message.contentType}.\n     */\n    UserDefinedMessage = 'user-defined-message',\n  }\n\n  /**\n   * Options to be used to acquire media tracks and connect media.\n   */\n  export interface AcceptOptions {\n    /**\n     * An RTCConfiguration to pass to the RTCPeerConnection constructor.\n     */\n    rtcConfiguration?: RTCConfiguration;\n\n    /**\n     * MediaStreamConstraints to pass to getUserMedia when making or accepting a Call.\n     */\n    rtcConstraints?: MediaStreamConstraints;\n  }\n\n  /**\n   * A CallerInfo provides caller verification information.\n   */\n  export interface CallerInfo {\n    /**\n     * Whether or not the caller's phone number has been verified by\n     * Twilio using SHAKEN/STIR validation. True if the caller has\n     * been validated at level 'A', false if the caller has been\n     * verified at any lower level or has failed validation.\n     */\n    isVerified: boolean;\n  }\n\n  /**\n   * Mandatory config options to be passed to the {@link Call} constructor.\n   * @private\n   */\n  export interface Config {\n    /**\n     * An AudioHelper instance to be used for input/output devices.\n     */\n    audioHelper: IAudioHelper;\n\n    /**\n     * A method to use for getUserMedia.\n     */\n    getUserMedia: (constraints: MediaStreamConstraints) => Promise<MediaStream>;\n\n    /**\n     * Whether or not the browser uses unified-plan SDP by default.\n     */\n    isUnifiedPlanDefault: boolean;\n\n    /**\n     * A function to be called after {@link Call.ignore} is called.\n     */\n    onIgnore: () => void;\n\n    /**\n     * The PStream instance to use for Twilio call signaling.\n     */\n    pstream: IPStream;\n\n    /**\n     * An EventPublisher instance to use for publishing events\n     */\n    publisher: IPublisher;\n\n    /**\n     * A Map of Sounds to play.\n     */\n    soundcache: Map<Device.SoundName, ISound>;\n  }\n\n  /**\n   * A Call Message represents the data that is being transferred between\n   * Twilio and the SDK.\n   */\n  export interface Message {\n    /**\n     * The content of the message which should match the contentType parameter.\n     */\n    content: any;\n\n    /**\n     * The MIME type of the content. The default value is application/json\n     * and is the only contentType that is supported at the moment.\n     */\n    contentType?: string;\n\n    /**\n     * The type of message\n     */\n    messageType: MessageType;\n\n    /**\n     * An autogenerated id that uniquely identifies the instance of this message.\n     * This is not required when sending a message from the SDK as this is autogenerated.\n     * But it will be available after the message is sent, or when a message is received.\n     */\n    voiceEventSid?: string;\n  }\n\n  /**\n   * Options to be passed to the {@link Call} constructor.\n   * @private\n   */\n  export interface Options {\n    /**\n     * A method to call before Call.accept is processed.\n     */\n    beforeAccept?: (call: Call) => void;\n\n    /**\n     * Custom format context parameters associated with this call.\n     */\n    callParameters?: Record<string, string>;\n\n    /**\n     * An ordered array of codec names, from most to least preferred.\n     */\n    codecPreferences?: Codec[];\n\n    /**\n     * A DialTone player, to play mock DTMF sounds.\n     */\n    dialtonePlayer?: DialtonePlayer;\n\n    /**\n     * Whether or not to enable DSCP.\n     */\n    dscp?: boolean;\n\n    /**\n     * Experimental feature.\n     * Force Chrome's ICE agent to use aggressive nomination when selecting a candidate pair.\n     */\n    forceAggressiveIceNomination?: boolean;\n\n    /**\n     * The gateway currently connected to.\n     */\n    gateway?: string;\n\n    /**\n     * A method that returns the current input MediaStream set on {@link Device}.\n     */\n    getInputStream?: () => MediaStream;\n\n    /**\n     * A method that returns the current SinkIDs set on {@link Device}.\n     */\n    getSinkIds?: () => string[];\n\n    /**\n     * The maximum average audio bitrate to use, in bits per second (bps) based on\n     * [RFC-7587 7.1](https://tools.ietf.org/html/rfc7587#section-7.1). By default, the setting\n     * is not used. If you specify 0, then the setting is not used. Any positive integer is allowed,\n     * but values outside the range 6000 to 510000 are ignored and treated as 0. The recommended\n     * bitrate for speech is between 8000 and 40000 bps as noted in\n     * [RFC-7587 3.1.1](https://tools.ietf.org/html/rfc7587#section-3.1.1).\n     */\n    maxAverageBitrate?: number;\n\n    /**\n     * Custom MediaHandler (PeerConnection) constructor.\n     */\n    MediaHandler?: IPeerConnection;\n\n    /**\n     * The offer SDP, if this is an incoming call.\n     */\n    offerSdp?: string | null;\n\n    /**\n     * Whether this is a preflight call or not\n     */\n    preflight?: boolean;\n\n    /**\n     * A reconnect token for the {@link Call}. Passed in for incoming {@link Calls}.\n     */\n    reconnectToken?: string;\n\n    /**\n     * An RTCConfiguration to pass to the RTCPeerConnection constructor.\n     */\n    rtcConfiguration?: RTCConfiguration;\n\n    /**\n     * RTC Constraints to pass to getUserMedia when making or accepting a Call.\n     * The format of this object depends on browser.\n     */\n    rtcConstraints?: MediaStreamConstraints;\n\n    /**\n     * The RTCPeerConnection passed to {@link Device} on setup.\n     */\n    RTCPeerConnection?: any;\n\n    /**\n     * Whether the disconnect sound should be played.\n     */\n    shouldPlayDisconnect?: () => boolean;\n\n    /**\n     * An override for the StatsMonitor dependency.\n     */\n    StatsMonitor?: new () => StatsMonitor;\n\n    /**\n     * TwiML params for the call. May be set for either outgoing or incoming calls.\n     */\n    twimlParams?: Record<string, any>;\n\n    /**\n     * Voice event SID generator.\n     */\n    voiceEventSidGenerator?: () => string;\n  }\n\n  /**\n   * Call metrics published to Insight Metrics.\n   * This include rtc samples and audio information.\n   * @private\n   */\n  export interface CallMetrics extends RTCSample {\n    /**\n     * Percentage of maximum volume, between 0.0 to 1.0, representing -100 to -30 dB.\n     */\n    inputVolume: number;\n\n    /**\n     * Percentage of maximum volume, between 0.0 to 1.0, representing -100 to -30 dB.\n     */\n    outputVolume: number;\n  }\n}\n\nfunction generateTempCallSid() {\n  return 'TJSxxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    /* tslint:disable:no-bitwise */\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    /* tslint:enable:no-bitwise */\n    return v.toString(16);\n  });\n}\n\nexport default Call;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}