{"ast":null,"code":"\"use strict\";\n\n/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar events_1 = require(\"events\");\nvar WebSocket = require(\"ws\");\nvar errors_1 = require(\"./errors\");\nvar log_1 = require(\"./log\");\n// tslint:disable-next-line\nvar Backoff = require('backoff');\nvar CONNECT_SUCCESS_TIMEOUT = 10000;\nvar CONNECT_TIMEOUT = 5000;\nvar HEARTBEAT_TIMEOUT = 15000;\n/**\n * All possible states of WSTransport.\n */\nvar WSTransportState;\n(function (WSTransportState) {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  WSTransportState[\"Connecting\"] = \"connecting\";\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n  WSTransportState[\"Closed\"] = \"closed\";\n  /**\n   * The underlying WebSocket is open and active.\n   */\n  WSTransportState[\"Open\"] = \"open\";\n})(WSTransportState = exports.WSTransportState || (exports.WSTransportState = {}));\n/**\n * WebSocket Transport\n */\nvar WSTransport = /** @class */function (_super) {\n  __extends(WSTransport, _super);\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n  function WSTransport(uris, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = _super.call(this) || this;\n    /**\n     * The current state of the WSTransport.\n     */\n    _this.state = WSTransportState.Closed;\n    /**\n     * An instance of Logger to use.\n     */\n    _this._log = log_1.default.getInstance();\n    /**\n     * Whether we should attempt to fallback if we receive an applicable error\n     * when trying to connect to a signaling endpoint.\n     */\n    _this._shouldFallback = false;\n    /**\n     * The current uri index that the transport is connected to.\n     */\n    _this._uriIndex = 0;\n    /**\n     * Move the uri index to the next index\n     * If the index is at the end, the index goes back to the first one.\n     */\n    _this._moveUriIndex = function () {\n      _this._uriIndex++;\n      if (_this._uriIndex >= _this._uris.length) {\n        _this._uriIndex = 0;\n      }\n    };\n    /**\n     * Called in response to WebSocket#close event.\n     */\n    _this._onSocketClose = function (event) {\n      _this._log.info(\"Received websocket close event code: \" + event.code + \". Reason: \" + event.reason);\n      // 1006: Abnormal close. When the server is unreacheable\n      // 1015: TLS Handshake error\n      if (event.code === 1006 || event.code === 1015) {\n        _this.emit('error', {\n          code: 31005,\n          message: event.reason || 'Websocket connection to Twilio\\'s signaling servers were ' + 'unexpectedly ended. If this is happening consistently, there may ' + 'be an issue resolving the hostname provided. If a region or an ' + 'edge is being specified in Device setup, ensure it is valid.',\n          twilioError: new errors_1.SignalingErrors.ConnectionError()\n        });\n        var wasConnected =\n        // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        _this.state === WSTransportState.Open ||\n        // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        _this._previousState === WSTransportState.Open;\n        // Only fallback if this is not the first error\n        // and if we were not connected previously\n        if (_this._shouldFallback || !wasConnected) {\n          _this._moveUriIndex();\n        }\n        _this._shouldFallback = true;\n      }\n      _this._closeSocket();\n    };\n    /**\n     * Called in response to WebSocket#error event.\n     */\n    _this._onSocketError = function (err) {\n      _this._log.info(\"WebSocket received error: \" + err.message);\n      _this.emit('error', {\n        code: 31000,\n        message: err.message || 'WSTransport socket error',\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n    };\n    /**\n     * Called in response to WebSocket#message event.\n     */\n    _this._onSocketMessage = function (message) {\n      // Clear heartbeat timeout on any incoming message, as they\n      // all indicate an active connection.\n      _this._setHeartbeatTimeout();\n      // Filter and respond to heartbeats\n      if (_this._socket && message.data === '\\n') {\n        _this._socket.send('\\n');\n        return;\n      }\n      _this.emit('message', message);\n    };\n    /**\n     * Called in response to WebSocket#open event.\n     */\n    _this._onSocketOpen = function () {\n      _this._log.info('WebSocket opened successfully.');\n      _this._timeOpened = Date.now();\n      _this._shouldFallback = false;\n      _this._setState(WSTransportState.Open);\n      clearTimeout(_this._connectTimeout);\n      _this._setHeartbeatTimeout();\n      _this.emit('open');\n    };\n    _this._connectTimeoutMs = options.connectTimeoutMs || CONNECT_TIMEOUT;\n    var initialDelay = 100;\n    if (uris && uris.length > 1) {\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      initialDelay = Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000;\n    }\n    var backoffConfig = {\n      factor: 2.0,\n      initialDelay: initialDelay,\n      maxDelay: typeof options.backoffMaxMs === 'number' ? Math.max(options.backoffMaxMs, 3000) : 20000,\n      randomisationFactor: 0.40\n    };\n    _this._log.info('Initializing transport backoff using config: ', backoffConfig);\n    _this._backoff = Backoff.exponential(backoffConfig);\n    _this._uris = uris;\n    _this._WebSocket = options.WebSocket || WebSocket;\n    // Called when a backoff timer is started.\n    _this._backoff.on('backoff', function (_, delay) {\n      if (_this.state === WSTransportState.Closed) {\n        return;\n      }\n      _this._log.info(\"Will attempt to reconnect WebSocket in \" + delay + \"ms\");\n    });\n    // Called when a backoff timer ends. We want to try to reconnect\n    // the WebSocket at this point.\n    _this._backoff.on('ready', function (attempt) {\n      if (_this.state === WSTransportState.Closed) {\n        return;\n      }\n      _this._connect(attempt + 1);\n    });\n    return _this;\n  }\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  WSTransport.prototype.close = function () {\n    this._log.info('WSTransport.close() called...');\n    this._close();\n  };\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n  WSTransport.prototype.open = function () {\n    this._log.info('WSTransport.open() called...');\n    if (this._socket && (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n      return;\n    }\n    this._connect();\n  };\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n  WSTransport.prototype.send = function (message) {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n      this._closeSocket();\n      return false;\n    }\n    return true;\n  };\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  WSTransport.prototype._close = function () {\n    this._setState(WSTransportState.Closed);\n    this._closeSocket();\n  };\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n  WSTransport.prototype._closeSocket = function () {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n    this._log.info('Closing and cleaning up WebSocket...');\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n      return;\n    }\n    this._socket.removeEventListener('close', this._onSocketClose);\n    this._socket.removeEventListener('error', this._onSocketError);\n    this._socket.removeEventListener('message', this._onSocketMessage);\n    this._socket.removeEventListener('open', this._onSocketOpen);\n    if (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    }\n    // Reset backoff counter if connection was open for long enough to be considered successful\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._backoff.reset();\n    }\n    this._backoff.backoff();\n    delete this._socket;\n    this.emit('close');\n  };\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n  WSTransport.prototype._connect = function (retryCount) {\n    var _this = this;\n    if (retryCount) {\n      this._log.info(\"Attempting to reconnect (retry #\" + retryCount + \")...\");\n    } else {\n      this._log.info('Attempting to connect...');\n    }\n    this._closeSocket();\n    this._setState(WSTransportState.Connecting);\n    var socket = null;\n    try {\n      socket = new this._WebSocket(this._uris[this._uriIndex]);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n      this._close();\n      this.emit('error', {\n        code: 31000,\n        message: e.message || \"Could not connect to \" + this._uris[this._uriIndex],\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n      return;\n    }\n    delete this._timeOpened;\n    this._connectTimeout = setTimeout(function () {\n      _this._log.info('WebSocket connection attempt timed out.');\n      _this._moveUriIndex();\n      _this._closeSocket();\n    }, this._connectTimeoutMs);\n    socket.addEventListener('close', this._onSocketClose);\n    socket.addEventListener('error', this._onSocketError);\n    socket.addEventListener('message', this._onSocketMessage);\n    socket.addEventListener('open', this._onSocketOpen);\n    this._socket = socket;\n  };\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n  WSTransport.prototype._setHeartbeatTimeout = function () {\n    var _this = this;\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(function () {\n      _this._log.info(\"No messages received in \" + HEARTBEAT_TIMEOUT / 1000 + \" seconds. Reconnecting...\");\n      _this._shouldFallback = true;\n      _this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  };\n  /**\n   * Set the current and previous state\n   */\n  WSTransport.prototype._setState = function (state) {\n    this._previousState = this.state;\n    this.state = state;\n  };\n  Object.defineProperty(WSTransport.prototype, \"uri\", {\n    /**\n     * The uri the transport is currently connected to\n     */\n    get: function () {\n      return this._uris[this._uriIndex];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return WSTransport;\n}(events_1.EventEmitter);\nexports.default = WSTransport;","map":{"version":3,"names":["events_1","require","WebSocket","errors_1","log_1","Backoff","CONNECT_SUCCESS_TIMEOUT","CONNECT_TIMEOUT","HEARTBEAT_TIMEOUT","WSTransportState","exports","WSTransport","_super","__extends","uris","options","_this","call","state","Closed","_log","default","getInstance","_shouldFallback","_uriIndex","_moveUriIndex","_uris","length","_onSocketClose","event","info","code","reason","emit","message","twilioError","SignalingErrors","ConnectionError","wasConnected","Open","_previousState","_closeSocket","_onSocketError","err","ConnectionDisconnected","_onSocketMessage","_setHeartbeatTimeout","_socket","data","send","_onSocketOpen","_timeOpened","Date","now","_setState","clearTimeout","_connectTimeout","_connectTimeoutMs","connectTimeoutMs","initialDelay","Math","floor","random","backoffConfig","factor","maxDelay","backoffMaxMs","max","randomisationFactor","_backoff","exponential","_WebSocket","on","_","delay","attempt","_connect","prototype","close","_close","open","readyState","CONNECTING","OPEN","e","_heartbeatTimeout","removeEventListener","reset","backoff","retryCount","Connecting","socket","setTimeout","addEventListener","Object","defineProperty","get","EventEmitter"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/twilio-client/lib/twilio/wstransport.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\n\nimport { EventEmitter } from 'events';\nimport * as WebSocket from 'ws';\nimport { SignalingErrors } from './errors';\nimport Log from './log';\n\n// tslint:disable-next-line\nconst Backoff = require('backoff');\n\nconst CONNECT_SUCCESS_TIMEOUT = 10000;\nconst CONNECT_TIMEOUT = 5000;\nconst HEARTBEAT_TIMEOUT = 15000;\n\nexport interface IMessageEvent {\n  data: string;\n  target: WebSocket;\n  type: string;\n}\n\n/**\n * All possible states of WSTransport.\n */\nexport enum WSTransportState {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  Connecting = 'connecting',\n\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n  Closed = 'closed',\n\n  /**\n   * The underlying WebSocket is open and active.\n   */\n  Open = 'open',\n}\n\n/**\n * Options to be passed to the WSTransport constructor.\n */\nexport interface IWSTransportConstructorOptions {\n  /**\n   * Maximum time to wait before attempting to reconnect the signaling websocket.\n   * Default is 20000ms. Minimum is 3000ms.\n   */\n  backoffMaxMs?: number;\n\n  /**\n   * Time in milliseconds before websocket times out when attempting to connect\n   */\n  connectTimeoutMs?: number;\n\n  /**\n   * A WebSocket factory to use instead of WebSocket.\n   */\n  WebSocket?: any;\n}\n\n/**\n * WebSocket Transport\n */\nexport default class WSTransport extends EventEmitter {\n  /**\n   * The current state of the WSTransport.\n   */\n  state: WSTransportState = WSTransportState.Closed;\n\n  /**\n   * The backoff instance used to schedule reconnection attempts.\n   */\n  private readonly _backoff: any;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _connectTimeout?: any;\n\n  /**\n   * Time in milliseconds before websocket times out when attempting to connect\n   */\n  private _connectTimeoutMs?: number;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _heartbeatTimeout?: any;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = Log.getInstance();\n\n  /**\n   * Previous state of the connection\n   */\n  private _previousState: WSTransportState;\n\n  /**\n   * Whether we should attempt to fallback if we receive an applicable error\n   * when trying to connect to a signaling endpoint.\n   */\n  private _shouldFallback: boolean = false;\n\n  /**\n   * The currently connecting or open WebSocket.\n   */\n  private _socket?: WebSocket;\n\n  /**\n   * The time the active connection was opened.\n   */\n  private _timeOpened?: number;\n\n  /**\n   * The current uri index that the transport is connected to.\n   */\n  private _uriIndex: number = 0;\n\n  /**\n   * List of URI of the endpoints to connect to.\n   */\n  private readonly _uris: string[];\n\n  /**\n   * The constructor to use for WebSocket\n   */\n  private readonly _WebSocket: typeof WebSocket;\n\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n  constructor(uris: string[], options: IWSTransportConstructorOptions = { }) {\n    super();\n\n    this._connectTimeoutMs = options.connectTimeoutMs || CONNECT_TIMEOUT;\n\n    let initialDelay = 100;\n    if (uris && uris.length > 1) {\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      initialDelay = Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000;\n    }\n\n    const backoffConfig = {\n      factor: 2.0,\n      initialDelay,\n      maxDelay: typeof options.backoffMaxMs === 'number'\n        ? Math.max(options.backoffMaxMs, 3000)\n        : 20000,\n      randomisationFactor: 0.40,\n    };\n\n    this._log.info('Initializing transport backoff using config: ', backoffConfig);\n    this._backoff = Backoff.exponential(backoffConfig);\n\n    this._uris = uris;\n    this._WebSocket = options.WebSocket || WebSocket;\n\n    // Called when a backoff timer is started.\n    this._backoff.on('backoff', (_: any, delay: number) => {\n      if (this.state === WSTransportState.Closed) { return; }\n      this._log.info(`Will attempt to reconnect WebSocket in ${delay}ms`);\n    });\n\n    // Called when a backoff timer ends. We want to try to reconnect\n    // the WebSocket at this point.\n    this._backoff.on('ready', (attempt: number) => {\n      if (this.state === WSTransportState.Closed) { return; }\n      this._connect(attempt + 1);\n    });\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  close(): void {\n    this._log.info('WSTransport.close() called...');\n    this._close();\n  }\n\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n  open(): void {\n    this._log.info('WSTransport.open() called...');\n\n    if (this._socket &&\n        (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n      return;\n    }\n\n    this._connect();\n  }\n\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n  send(message: string): boolean {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n      this._closeSocket();\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  private _close(): void {\n    this._setState(WSTransportState.Closed);\n    this._closeSocket();\n  }\n\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n  private _closeSocket(): void {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n\n    this._log.info('Closing and cleaning up WebSocket...');\n\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n      return;\n    }\n\n    this._socket.removeEventListener('close', this._onSocketClose as any);\n    this._socket.removeEventListener('error', this._onSocketError as any);\n    this._socket.removeEventListener('message', this._onSocketMessage as any);\n    this._socket.removeEventListener('open', this._onSocketOpen as any);\n\n    if (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    }\n\n    // Reset backoff counter if connection was open for long enough to be considered successful\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._backoff.reset();\n    }\n\n    this._backoff.backoff();\n    delete this._socket;\n\n    this.emit('close');\n  }\n\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n  private _connect(retryCount?: number): void {\n    if (retryCount) {\n      this._log.info(`Attempting to reconnect (retry #${retryCount})...`);\n    } else {\n      this._log.info('Attempting to connect...');\n    }\n\n    this._closeSocket();\n\n    this._setState(WSTransportState.Connecting);\n    let socket = null;\n    try {\n      socket = new this._WebSocket(this._uris[this._uriIndex]);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n      this._close();\n      this.emit('error', {\n        code: 31000,\n        message: e.message || `Could not connect to ${this._uris[this._uriIndex]}`,\n        twilioError: new SignalingErrors.ConnectionDisconnected(),\n      });\n      return;\n    }\n\n    delete this._timeOpened;\n    this._connectTimeout = setTimeout(() => {\n      this._log.info('WebSocket connection attempt timed out.');\n      this._moveUriIndex();\n      this._closeSocket();\n    }, this._connectTimeoutMs);\n\n    socket.addEventListener('close', this._onSocketClose as any);\n    socket.addEventListener('error', this._onSocketError as any);\n    socket.addEventListener('message', this._onSocketMessage as any);\n    socket.addEventListener('open', this._onSocketOpen as any);\n    this._socket = socket;\n  }\n\n  /**\n   * Move the uri index to the next index\n   * If the index is at the end, the index goes back to the first one.\n   */\n  private _moveUriIndex = (): void => {\n    this._uriIndex++;\n    if (this._uriIndex >= this._uris.length) {\n      this._uriIndex = 0;\n    }\n  }\n\n  /**\n   * Called in response to WebSocket#close event.\n   */\n  private _onSocketClose = (event: CloseEvent): void => {\n    this._log.info(`Received websocket close event code: ${event.code}. Reason: ${event.reason}`);\n    // 1006: Abnormal close. When the server is unreacheable\n    // 1015: TLS Handshake error\n    if (event.code === 1006 || event.code === 1015) {\n      this.emit('error', {\n        code: 31005,\n        message: event.reason ||\n          'Websocket connection to Twilio\\'s signaling servers were ' +\n          'unexpectedly ended. If this is happening consistently, there may ' +\n          'be an issue resolving the hostname provided. If a region or an ' +\n          'edge is being specified in Device setup, ensure it is valid.',\n        twilioError: new SignalingErrors.ConnectionError(),\n      });\n\n      const wasConnected = (\n        // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        this.state === WSTransportState.Open ||\n\n        // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        this._previousState === WSTransportState.Open\n      );\n\n      // Only fallback if this is not the first error\n      // and if we were not connected previously\n      if (this._shouldFallback || !wasConnected) {\n        this._moveUriIndex();\n      }\n\n      this._shouldFallback = true;\n    }\n    this._closeSocket();\n  }\n\n  /**\n   * Called in response to WebSocket#error event.\n   */\n  private _onSocketError = (err: Error): void => {\n    this._log.info(`WebSocket received error: ${err.message}`);\n    this.emit('error', {\n      code: 31000,\n      message: err.message || 'WSTransport socket error',\n      twilioError: new SignalingErrors.ConnectionDisconnected(),\n    });\n  }\n\n  /**\n   * Called in response to WebSocket#message event.\n   */\n  private _onSocketMessage = (message: IMessageEvent): void => {\n    // Clear heartbeat timeout on any incoming message, as they\n    // all indicate an active connection.\n    this._setHeartbeatTimeout();\n\n    // Filter and respond to heartbeats\n    if (this._socket && message.data === '\\n') {\n      this._socket.send('\\n');\n      return;\n    }\n\n    this.emit('message', message);\n  }\n\n  /**\n   * Called in response to WebSocket#open event.\n   */\n  private _onSocketOpen = (): void => {\n    this._log.info('WebSocket opened successfully.');\n    this._timeOpened = Date.now();\n    this._shouldFallback = false;\n    this._setState(WSTransportState.Open);\n    clearTimeout(this._connectTimeout);\n\n    this._setHeartbeatTimeout();\n    this.emit('open');\n  }\n\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n  private _setHeartbeatTimeout(): void {\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(() => {\n      this._log.info(`No messages received in ${HEARTBEAT_TIMEOUT / 1000} seconds. Reconnecting...`);\n      this._shouldFallback = true;\n      this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  }\n\n  /**\n   * Set the current and previous state\n   */\n  private _setState(state: WSTransportState): void {\n    this._previousState = this.state;\n    this.state = state;\n  }\n\n  /**\n   * The uri the transport is currently connected to\n   */\n  get uri(): string {\n    return this._uris[this._uriIndex];\n  }\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,IAAAA,QAAA,GAAAC,OAAA;AACA,IAAAC,SAAA,GAAAD,OAAA;AACA,IAAAE,QAAA,GAAAF,OAAA;AACA,IAAAG,KAAA,GAAAH,OAAA;AAEA;AACA,IAAMI,OAAO,GAAGJ,OAAO,CAAC,SAAS,CAAC;AAElC,IAAMK,uBAAuB,GAAG,KAAK;AACrC,IAAMC,eAAe,GAAG,IAAI;AAC5B,IAAMC,iBAAiB,GAAG,KAAK;AAQ/B;;;AAGA,IAAYC,gBAeX;AAfD,WAAYA,gBAAgB;EAC1B;;;EAGAA,gBAAA,6BAAyB;EAEzB;;;EAGAA,gBAAA,qBAAiB;EAEjB;;;EAGAA,gBAAA,iBAAa;AACf,CAAC,EAfWA,gBAAgB,GAAhBC,OAAA,CAAAD,gBAAgB,KAAhBC,OAAA,CAAAD,gBAAgB;AAsC5B;;;AAGA,IAAAE,WAAA,0BAAAC,MAAA;EAAyCC,SAAA,CAAAF,WAAA,EAAAC,MAAA;EA2EvC;;;;;EAKA,SAAAD,YAAYG,IAAc,EAAEC,OAA6C;IAA7C,IAAAA,OAAA;MAAAA,OAAA,KAA6C;IAAA;IAAzE,IAAAC,KAAA,GACEJ,MAAA,CAAAK,IAAA,MAAO;IAhFT;;;IAGAD,KAAA,CAAAE,KAAK,GAAqBT,gBAAgB,CAACU,MAAM;IA8BjD;;;IAGQH,KAAA,CAAAI,IAAI,GAAQhB,KAAA,CAAAiB,OAAG,CAACC,WAAW,EAAE;IAOrC;;;;IAIQN,KAAA,CAAAO,eAAe,GAAY,KAAK;IAYxC;;;IAGQP,KAAA,CAAAQ,SAAS,GAAW,CAAC;IA+L7B;;;;IAIQR,KAAA,CAAAS,aAAa,GAAG;MACtBT,KAAI,CAACQ,SAAS,EAAE;MAChB,IAAIR,KAAI,CAACQ,SAAS,IAAIR,KAAI,CAACU,KAAK,CAACC,MAAM,EAAE;QACvCX,KAAI,CAACQ,SAAS,GAAG,CAAC;;IAEtB,CAAC;IAED;;;IAGQR,KAAA,CAAAY,cAAc,GAAG,UAACC,KAAiB;MACzCb,KAAI,CAACI,IAAI,CAACU,IAAI,CAAC,0CAAwCD,KAAK,CAACE,IAAI,kBAAaF,KAAK,CAACG,MAAQ,CAAC;MAC7F;MACA;MACA,IAAIH,KAAK,CAACE,IAAI,KAAK,IAAI,IAAIF,KAAK,CAACE,IAAI,KAAK,IAAI,EAAE;QAC9Cf,KAAI,CAACiB,IAAI,CAAC,OAAO,EAAE;UACjBF,IAAI,EAAE,KAAK;UACXG,OAAO,EAAEL,KAAK,CAACG,MAAM,IACnB,2DAA2D,GAC3D,mEAAmE,GACnE,iEAAiE,GACjE,8DAA8D;UAChEG,WAAW,EAAE,IAAIhC,QAAA,CAAAiC,eAAe,CAACC,eAAe;SACjD,CAAC;QAEF,IAAMC,YAAY;QAChB;QACA;QACA;QACAtB,KAAI,CAACE,KAAK,KAAKT,gBAAgB,CAAC8B,IAAI;QAEpC;QACA;QACA;QACAvB,KAAI,CAACwB,cAAc,KAAK/B,gBAAgB,CAAC8B,IAC1C;QAED;QACA;QACA,IAAIvB,KAAI,CAACO,eAAe,IAAI,CAACe,YAAY,EAAE;UACzCtB,KAAI,CAACS,aAAa,EAAE;;QAGtBT,KAAI,CAACO,eAAe,GAAG,IAAI;;MAE7BP,KAAI,CAACyB,YAAY,EAAE;IACrB,CAAC;IAED;;;IAGQzB,KAAA,CAAA0B,cAAc,GAAG,UAACC,GAAU;MAClC3B,KAAI,CAACI,IAAI,CAACU,IAAI,CAAC,+BAA6Ba,GAAG,CAACT,OAAS,CAAC;MAC1DlB,KAAI,CAACiB,IAAI,CAAC,OAAO,EAAE;QACjBF,IAAI,EAAE,KAAK;QACXG,OAAO,EAAES,GAAG,CAACT,OAAO,IAAI,0BAA0B;QAClDC,WAAW,EAAE,IAAIhC,QAAA,CAAAiC,eAAe,CAACQ,sBAAsB;OACxD,CAAC;IACJ,CAAC;IAED;;;IAGQ5B,KAAA,CAAA6B,gBAAgB,GAAG,UAACX,OAAsB;MAChD;MACA;MACAlB,KAAI,CAAC8B,oBAAoB,EAAE;MAE3B;MACA,IAAI9B,KAAI,CAAC+B,OAAO,IAAIb,OAAO,CAACc,IAAI,KAAK,IAAI,EAAE;QACzChC,KAAI,CAAC+B,OAAO,CAACE,IAAI,CAAC,IAAI,CAAC;QACvB;;MAGFjC,KAAI,CAACiB,IAAI,CAAC,SAAS,EAAEC,OAAO,CAAC;IAC/B,CAAC;IAED;;;IAGQlB,KAAA,CAAAkC,aAAa,GAAG;MACtBlC,KAAI,CAACI,IAAI,CAACU,IAAI,CAAC,gCAAgC,CAAC;MAChDd,KAAI,CAACmC,WAAW,GAAGC,IAAI,CAACC,GAAG,EAAE;MAC7BrC,KAAI,CAACO,eAAe,GAAG,KAAK;MAC5BP,KAAI,CAACsC,SAAS,CAAC7C,gBAAgB,CAAC8B,IAAI,CAAC;MACrCgB,YAAY,CAACvC,KAAI,CAACwC,eAAe,CAAC;MAElCxC,KAAI,CAAC8B,oBAAoB,EAAE;MAC3B9B,KAAI,CAACiB,IAAI,CAAC,MAAM,CAAC;IACnB,CAAC;IAxQCjB,KAAI,CAACyC,iBAAiB,GAAG1C,OAAO,CAAC2C,gBAAgB,IAAInD,eAAe;IAEpE,IAAIoD,YAAY,GAAG,GAAG;IACtB,IAAI7C,IAAI,IAAIA,IAAI,CAACa,MAAM,GAAG,CAAC,EAAE;MAC3B;MACA;MACAgC,YAAY,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,IAAI,IAAI,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI;;IAGrE,IAAMC,aAAa,GAAG;MACpBC,MAAM,EAAE,GAAG;MACXL,YAAY,EAAAA,YAAA;MACZM,QAAQ,EAAE,OAAOlD,OAAO,CAACmD,YAAY,KAAK,QAAQ,GAC9CN,IAAI,CAACO,GAAG,CAACpD,OAAO,CAACmD,YAAY,EAAE,IAAI,CAAC,GACpC,KAAK;MACTE,mBAAmB,EAAE;KACtB;IAEDpD,KAAI,CAACI,IAAI,CAACU,IAAI,CAAC,+CAA+C,EAAEiC,aAAa,CAAC;IAC9E/C,KAAI,CAACqD,QAAQ,GAAGhE,OAAO,CAACiE,WAAW,CAACP,aAAa,CAAC;IAElD/C,KAAI,CAACU,KAAK,GAAGZ,IAAI;IACjBE,KAAI,CAACuD,UAAU,GAAGxD,OAAO,CAACb,SAAS,IAAIA,SAAS;IAEhD;IACAc,KAAI,CAACqD,QAAQ,CAACG,EAAE,CAAC,SAAS,EAAE,UAACC,CAAM,EAAEC,KAAa;MAChD,IAAI1D,KAAI,CAACE,KAAK,KAAKT,gBAAgB,CAACU,MAAM,EAAE;QAAE;;MAC9CH,KAAI,CAACI,IAAI,CAACU,IAAI,CAAC,4CAA0C4C,KAAK,OAAI,CAAC;IACrE,CAAC,CAAC;IAEF;IACA;IACA1D,KAAI,CAACqD,QAAQ,CAACG,EAAE,CAAC,OAAO,EAAE,UAACG,OAAe;MACxC,IAAI3D,KAAI,CAACE,KAAK,KAAKT,gBAAgB,CAACU,MAAM,EAAE;QAAE;;MAC9CH,KAAI,CAAC4D,QAAQ,CAACD,OAAO,GAAG,CAAC,CAAC;IAC5B,CAAC,CAAC;;EACJ;EAEA;;;EAGAhE,WAAA,CAAAkE,SAAA,CAAAC,KAAK,GAAL;IACE,IAAI,CAAC1D,IAAI,CAACU,IAAI,CAAC,+BAA+B,CAAC;IAC/C,IAAI,CAACiD,MAAM,EAAE;EACf,CAAC;EAED;;;EAGApE,WAAA,CAAAkE,SAAA,CAAAG,IAAI,GAAJ;IACE,IAAI,CAAC5D,IAAI,CAACU,IAAI,CAAC,8BAA8B,CAAC;IAE9C,IAAI,IAAI,CAACiB,OAAO,KACX,IAAI,CAACA,OAAO,CAACkC,UAAU,KAAK/E,SAAS,CAACgF,UAAU,IACjD,IAAI,CAACnC,OAAO,CAACkC,UAAU,KAAK/E,SAAS,CAACiF,IAAI,CAAC,EAAE;MAC/C,IAAI,CAAC/D,IAAI,CAACU,IAAI,CAAC,yBAAyB,CAAC;MACzC;;IAGF,IAAI,CAAC8C,QAAQ,EAAE;EACjB,CAAC;EAED;;;;;EAKAjE,WAAA,CAAAkE,SAAA,CAAA5B,IAAI,GAAJ,UAAKf,OAAe;IAClB;IACA,IAAI,CAAC,IAAI,CAACa,OAAO,IAAI,IAAI,CAACA,OAAO,CAACkC,UAAU,KAAK/E,SAAS,CAACiF,IAAI,EAAE;MAC/D,OAAO,KAAK;;IAGd,IAAI;MACF,IAAI,CAACpC,OAAO,CAACE,IAAI,CAACf,OAAO,CAAC;KAC3B,CAAC,OAAOkD,CAAC,EAAE;MACV;MACA,IAAI,CAAChE,IAAI,CAACU,IAAI,CAAC,8BAA8B,EAAEsD,CAAC,CAAClD,OAAO,CAAC;MACzD,IAAI,CAACO,YAAY,EAAE;MACnB,OAAO,KAAK;;IAGd,OAAO,IAAI;EACb,CAAC;EAED;;;EAGQ9B,WAAA,CAAAkE,SAAA,CAAAE,MAAM,GAAd;IACE,IAAI,CAACzB,SAAS,CAAC7C,gBAAgB,CAACU,MAAM,CAAC;IACvC,IAAI,CAACsB,YAAY,EAAE;EACrB,CAAC;EAED;;;EAGQ9B,WAAA,CAAAkE,SAAA,CAAApC,YAAY,GAApB;IACEc,YAAY,CAAC,IAAI,CAACC,eAAe,CAAC;IAClCD,YAAY,CAAC,IAAI,CAAC8B,iBAAiB,CAAC;IAEpC,IAAI,CAACjE,IAAI,CAACU,IAAI,CAAC,sCAAsC,CAAC;IAEtD,IAAI,CAAC,IAAI,CAACiB,OAAO,EAAE;MACjB,IAAI,CAAC3B,IAAI,CAACU,IAAI,CAAC,2BAA2B,CAAC;MAC3C;;IAGF,IAAI,CAACiB,OAAO,CAACuC,mBAAmB,CAAC,OAAO,EAAE,IAAI,CAAC1D,cAAqB,CAAC;IACrE,IAAI,CAACmB,OAAO,CAACuC,mBAAmB,CAAC,OAAO,EAAE,IAAI,CAAC5C,cAAqB,CAAC;IACrE,IAAI,CAACK,OAAO,CAACuC,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAACzC,gBAAuB,CAAC;IACzE,IAAI,CAACE,OAAO,CAACuC,mBAAmB,CAAC,MAAM,EAAE,IAAI,CAACpC,aAAoB,CAAC;IAEnE,IAAI,IAAI,CAACH,OAAO,CAACkC,UAAU,KAAK/E,SAAS,CAACgF,UAAU,IAChD,IAAI,CAACnC,OAAO,CAACkC,UAAU,KAAK/E,SAAS,CAACiF,IAAI,EAAE;MAC9C,IAAI,CAACpC,OAAO,CAAC+B,KAAK,EAAE;;IAGtB;IACA,IAAI,IAAI,CAAC3B,WAAW,IAAIC,IAAI,CAACC,GAAG,EAAE,GAAG,IAAI,CAACF,WAAW,GAAG7C,uBAAuB,EAAE;MAC/E,IAAI,CAAC+D,QAAQ,CAACkB,KAAK,EAAE;;IAGvB,IAAI,CAAClB,QAAQ,CAACmB,OAAO,EAAE;IACvB,OAAO,IAAI,CAACzC,OAAO;IAEnB,IAAI,CAACd,IAAI,CAAC,OAAO,CAAC;EACpB,CAAC;EAED;;;;;EAKQtB,WAAA,CAAAkE,SAAA,CAAAD,QAAQ,GAAhB,UAAiBa,UAAmB;IAApC,IAAAzE,KAAA;IACE,IAAIyE,UAAU,EAAE;MACd,IAAI,CAACrE,IAAI,CAACU,IAAI,CAAC,qCAAmC2D,UAAU,SAAM,CAAC;KACpE,MAAM;MACL,IAAI,CAACrE,IAAI,CAACU,IAAI,CAAC,0BAA0B,CAAC;;IAG5C,IAAI,CAACW,YAAY,EAAE;IAEnB,IAAI,CAACa,SAAS,CAAC7C,gBAAgB,CAACiF,UAAU,CAAC;IAC3C,IAAIC,MAAM,GAAG,IAAI;IACjB,IAAI;MACFA,MAAM,GAAG,IAAI,IAAI,CAACpB,UAAU,CAAC,IAAI,CAAC7C,KAAK,CAAC,IAAI,CAACF,SAAS,CAAC,CAAC;KACzD,CAAC,OAAO4D,CAAC,EAAE;MACV,IAAI,CAAChE,IAAI,CAACU,IAAI,CAAC,gCAAgC,EAAEsD,CAAC,CAAClD,OAAO,CAAC;MAC3D,IAAI,CAAC6C,MAAM,EAAE;MACb,IAAI,CAAC9C,IAAI,CAAC,OAAO,EAAE;QACjBF,IAAI,EAAE,KAAK;QACXG,OAAO,EAAEkD,CAAC,CAAClD,OAAO,IAAI,0BAAwB,IAAI,CAACR,KAAK,CAAC,IAAI,CAACF,SAAS,CAAG;QAC1EW,WAAW,EAAE,IAAIhC,QAAA,CAAAiC,eAAe,CAACQ,sBAAsB;OACxD,CAAC;MACF;;IAGF,OAAO,IAAI,CAACO,WAAW;IACvB,IAAI,CAACK,eAAe,GAAGoC,UAAU,CAAC;MAChC5E,KAAI,CAACI,IAAI,CAACU,IAAI,CAAC,yCAAyC,CAAC;MACzDd,KAAI,CAACS,aAAa,EAAE;MACpBT,KAAI,CAACyB,YAAY,EAAE;IACrB,CAAC,EAAE,IAAI,CAACgB,iBAAiB,CAAC;IAE1BkC,MAAM,CAACE,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAACjE,cAAqB,CAAC;IAC5D+D,MAAM,CAACE,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAACnD,cAAqB,CAAC;IAC5DiD,MAAM,CAACE,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAAChD,gBAAuB,CAAC;IAChE8C,MAAM,CAACE,gBAAgB,CAAC,MAAM,EAAE,IAAI,CAAC3C,aAAoB,CAAC;IAC1D,IAAI,CAACH,OAAO,GAAG4C,MAAM;EACvB,CAAC;EAiGD;;;;EAIQhF,WAAA,CAAAkE,SAAA,CAAA/B,oBAAoB,GAA5B;IAAA,IAAA9B,KAAA;IACEuC,YAAY,CAAC,IAAI,CAAC8B,iBAAiB,CAAC;IACpC,IAAI,CAACA,iBAAiB,GAAGO,UAAU,CAAC;MAClC5E,KAAI,CAACI,IAAI,CAACU,IAAI,CAAC,6BAA2BtB,iBAAiB,GAAG,IAAI,8BAA2B,CAAC;MAC9FQ,KAAI,CAACO,eAAe,GAAG,IAAI;MAC3BP,KAAI,CAACyB,YAAY,EAAE;IACrB,CAAC,EAAEjC,iBAAiB,CAAC;EACvB,CAAC;EAED;;;EAGQG,WAAA,CAAAkE,SAAA,CAAAvB,SAAS,GAAjB,UAAkBpC,KAAuB;IACvC,IAAI,CAACsB,cAAc,GAAG,IAAI,CAACtB,KAAK;IAChC,IAAI,CAACA,KAAK,GAAGA,KAAK;EACpB,CAAC;EAKD4E,MAAA,CAAAC,cAAA,CAAIpF,WAAA,CAAAkE,SAAA,OAAG;IAHP;;;SAGA,SAAAmB,CAAA;MACE,OAAO,IAAI,CAACtE,KAAK,CAAC,IAAI,CAACF,SAAS,CAAC;IACnC,CAAC;;;;EACH,OAAAb,WAAC;AAAD,CAAC,CAxXwCX,QAAA,CAAAiG,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}