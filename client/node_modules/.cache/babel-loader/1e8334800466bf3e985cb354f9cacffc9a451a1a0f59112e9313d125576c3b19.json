{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n// @ts-nocheck\nvar errors_1 = require(\"../errors\");\nvar log_1 = require(\"../log\");\nvar util = require(\"../util\");\nvar rtcpc_1 = require(\"./rtcpc\");\nvar sdp_1 = require(\"./sdp\");\nvar ICE_GATHERING_TIMEOUT = 15000;\nvar ICE_GATHERING_FAIL_NONE = 'none';\nvar ICE_GATHERING_FAIL_TIMEOUT = 'timeout';\nvar INITIAL_ICE_CONNECTION_STATE = 'new';\nvar VOLUME_INTERVAL_MS = 50;\n/**\n * @typedef {Object} PeerConnection\n * @param audioHelper\n * @param pstream\n * @param options\n * @return {PeerConnection}\n * @constructor\n */\nfunction PeerConnection(audioHelper, pstream, getUserMedia, options) {\n  if (!audioHelper || !pstream || !getUserMedia) {\n    throw new errors_1.InvalidArgumentError('Audiohelper, pstream and getUserMedia are required arguments');\n  }\n  if (!(this instanceof PeerConnection)) {\n    return new PeerConnection(audioHelper, pstream, getUserMedia, options);\n  }\n  this._log = log_1.default.getInstance();\n  function noop() {\n    this._log.warn('Unexpected noop call in peerconnection');\n  }\n  this.onaudio = noop;\n  this.onopen = noop;\n  this.onerror = noop;\n  this.onclose = noop;\n  this.ondisconnected = noop;\n  this.onfailed = noop;\n  this.onconnected = noop;\n  this.onreconnected = noop;\n  this.onsignalingstatechange = noop;\n  this.ondtlstransportstatechange = noop;\n  this.onicegatheringfailure = noop;\n  this.onicegatheringstatechange = noop;\n  this.oniceconnectionstatechange = noop;\n  this.onpcconnectionstatechange = noop;\n  this.onicecandidate = noop;\n  this.onselectedcandidatepairchange = noop;\n  this.onvolume = noop;\n  this.version = null;\n  this.pstream = pstream;\n  this.stream = null;\n  this.sinkIds = new Set(['default']);\n  this.outputs = new Map();\n  this.status = 'connecting';\n  this.callSid = null;\n  this.isMuted = false;\n  this.getUserMedia = getUserMedia;\n  var AudioContext = typeof window !== 'undefined' && (window.AudioContext || window.webkitAudioContext);\n  this._isSinkSupported = !!AudioContext && typeof HTMLAudioElement !== 'undefined' && HTMLAudioElement.prototype.setSinkId;\n  // NOTE(mmalavalli): Since each Connection creates its own AudioContext,\n  // after 6 instances an exception is thrown. Refer https://www.w3.org/2011/audio/track/issues/3.\n  // In order to get around it, we are re-using the Device's AudioContext.\n  this._audioContext = AudioContext && audioHelper._audioContext;\n  this._hasIceCandidates = false;\n  this._hasIceGatheringFailures = false;\n  this._iceGatheringTimeoutId = null;\n  this._masterAudio = null;\n  this._masterAudioDeviceId = null;\n  this._mediaStreamSource = null;\n  this._dtmfSender = null;\n  this._dtmfSenderUnsupported = false;\n  this._callEvents = [];\n  this._nextTimeToPublish = Date.now();\n  this._onAnswerOrRinging = noop;\n  this._onHangup = noop;\n  this._remoteStream = null;\n  this._shouldManageStream = true;\n  this._iceState = INITIAL_ICE_CONNECTION_STATE;\n  this._isUnifiedPlan = options.isUnifiedPlan;\n  this.options = options = options || {};\n  this.navigator = options.navigator || (typeof navigator !== 'undefined' ? navigator : null);\n  this.util = options.util || util;\n  this.codecPreferences = options.codecPreferences;\n  return this;\n}\nPeerConnection.prototype.uri = function () {\n  return this._uri;\n};\n/**\n * Open the underlying RTCPeerConnection with a MediaStream obtained by\n *   passed constraints. The resulting MediaStream is created internally\n *   and will therefore be managed and destroyed internally.\n * @param {MediaStreamConstraints} constraints\n */\nPeerConnection.prototype.openWithConstraints = function (constraints) {\n  return this.getUserMedia({\n    audio: constraints\n  }).then(this._setInputTracksFromStream.bind(this, false));\n};\n/**\n * Replace the existing input audio tracks with the audio tracks from the\n *   passed input audio stream. We re-use the existing stream because\n *   the AnalyzerNode is bound to the stream.\n * @param {MediaStream} stream\n */\nPeerConnection.prototype.setInputTracksFromStream = function (stream) {\n  var self = this;\n  return this._setInputTracksFromStream(true, stream).then(function () {\n    self._shouldManageStream = false;\n  });\n};\nPeerConnection.prototype._createAnalyser = function (audioContext, options) {\n  options = Object.assign({\n    fftSize: 32,\n    smoothingTimeConstant: 0.3\n  }, options);\n  var analyser = audioContext.createAnalyser();\n  // tslint:disable-next-line\n  for (var field in options) {\n    analyser[field] = options[field];\n  }\n  return analyser;\n};\nPeerConnection.prototype._setVolumeHandler = function (handler) {\n  this.onvolume = handler;\n};\nPeerConnection.prototype._startPollingVolume = function () {\n  if (!this._audioContext || !this.stream || !this._remoteStream) {\n    return;\n  }\n  var audioContext = this._audioContext;\n  var inputAnalyser = this._inputAnalyser = this._createAnalyser(audioContext);\n  var inputBufferLength = inputAnalyser.frequencyBinCount;\n  var inputDataArray = new Uint8Array(inputBufferLength);\n  this._inputAnalyser2 = this._createAnalyser(audioContext, {\n    maxDecibels: 0,\n    minDecibels: -127,\n    smoothingTimeConstant: 0\n  });\n  var outputAnalyser = this._outputAnalyser = this._createAnalyser(audioContext);\n  var outputBufferLength = outputAnalyser.frequencyBinCount;\n  var outputDataArray = new Uint8Array(outputBufferLength);\n  this._outputAnalyser2 = this._createAnalyser(audioContext, {\n    maxDecibels: 0,\n    minDecibels: -127,\n    smoothingTimeConstant: 0\n  });\n  this._updateInputStreamSource(this.stream);\n  this._updateOutputStreamSource(this._remoteStream);\n  var self = this;\n  setTimeout(function emitVolume() {\n    if (!self._audioContext) {\n      return;\n    } else if (self.status === 'closed') {\n      self._inputAnalyser.disconnect();\n      self._outputAnalyser.disconnect();\n      self._inputAnalyser2.disconnect();\n      self._outputAnalyser2.disconnect();\n      return;\n    }\n    self._inputAnalyser.getByteFrequencyData(inputDataArray);\n    var inputVolume = self.util.average(inputDataArray);\n    self._inputAnalyser2.getByteFrequencyData(inputDataArray);\n    var inputVolume2 = self.util.average(inputDataArray);\n    self._outputAnalyser.getByteFrequencyData(outputDataArray);\n    var outputVolume = self.util.average(outputDataArray);\n    self._outputAnalyser2.getByteFrequencyData(outputDataArray);\n    var outputVolume2 = self.util.average(outputDataArray);\n    self.onvolume(inputVolume / 255, outputVolume / 255, inputVolume2, outputVolume2);\n    setTimeout(emitVolume, VOLUME_INTERVAL_MS);\n  }, VOLUME_INTERVAL_MS);\n};\nPeerConnection.prototype._stopStream = function _stopStream(stream) {\n  // We shouldn't stop the tracks if they were not created inside\n  //   this PeerConnection.\n  if (!this._shouldManageStream) {\n    return;\n  }\n  if (typeof MediaStreamTrack.prototype.stop === 'function') {\n    var audioTracks = typeof stream.getAudioTracks === 'function' ? stream.getAudioTracks() : stream.audioTracks;\n    audioTracks.forEach(function (track) {\n      track.stop();\n    });\n  } else {\n    // NOTE(mroberts): This is just a fallback to any ancient browsers that may\n    // not implement MediaStreamTrack.stop.\n    stream.stop();\n  }\n};\n/**\n * Update the stream source with the new input audio stream.\n * @param {MediaStream} stream\n * @private\n */\nPeerConnection.prototype._updateInputStreamSource = function (stream) {\n  if (this._inputStreamSource) {\n    this._inputStreamSource.disconnect();\n  }\n  try {\n    this._inputStreamSource = this._audioContext.createMediaStreamSource(stream);\n    this._inputStreamSource.connect(this._inputAnalyser);\n    this._inputStreamSource.connect(this._inputAnalyser2);\n  } catch (ex) {\n    this._log.warn('Unable to update input MediaStreamSource', ex);\n    this._inputStreamSource = null;\n  }\n};\n/**\n * Update the stream source with the new ouput audio stream.\n * @param {MediaStream} stream\n * @private\n */\nPeerConnection.prototype._updateOutputStreamSource = function (stream) {\n  if (this._outputStreamSource) {\n    this._outputStreamSource.disconnect();\n  }\n  try {\n    this._outputStreamSource = this._audioContext.createMediaStreamSource(stream);\n    this._outputStreamSource.connect(this._outputAnalyser);\n    this._outputStreamSource.connect(this._outputAnalyser2);\n  } catch (ex) {\n    this._log.warn('Unable to update output MediaStreamSource', ex);\n    this._outputStreamSource = null;\n  }\n};\n/**\n * Replace the tracks of the current stream with new tracks. We do this rather than replacing the\n *   whole stream because AnalyzerNodes are bound to a stream.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksFromStream = function (shouldClone, newStream) {\n  return this._isUnifiedPlan ? this._setInputTracksForUnifiedPlan(shouldClone, newStream) : this._setInputTracksForPlanB(shouldClone, newStream);\n};\n/**\n * Replace the tracks of the current stream with new tracks using the 'plan-b' method.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksForPlanB = function (shouldClone, newStream) {\n  var _this = this;\n  if (!newStream) {\n    return Promise.reject(new errors_1.InvalidArgumentError('Can not set input stream to null while in a call'));\n  }\n  if (!newStream.getAudioTracks().length) {\n    return Promise.reject(new errors_1.InvalidArgumentError('Supplied input stream has no audio tracks'));\n  }\n  var localStream = this.stream;\n  if (!localStream) {\n    // We can't use MediaStream.clone() here because it stopped copying over tracks\n    //   as of Chrome 61. https://bugs.chromium.org/p/chromium/issues/detail?id=770908\n    this.stream = shouldClone ? cloneStream(newStream) : newStream;\n  } else {\n    this._stopStream(localStream);\n    removeStream(this.version.pc, localStream);\n    localStream.getAudioTracks().forEach(localStream.removeTrack, localStream);\n    newStream.getAudioTracks().forEach(localStream.addTrack, localStream);\n    addStream(this.version.pc, newStream);\n    this._updateInputStreamSource(this.stream);\n  }\n  // Apply mute settings to new input track\n  this.mute(this.isMuted);\n  if (!this.version) {\n    return Promise.resolve(this.stream);\n  }\n  return new Promise(function (resolve, reject) {\n    _this.version.createOffer(_this.options.maxAverageBitrate, _this.codecPreferences, {\n      audio: true\n    }, function () {\n      _this.version.processAnswer(_this.codecPreferences, _this._answerSdp, function () {\n        resolve(_this.stream);\n      }, reject);\n    }, reject);\n  });\n};\n/**\n * Replace the tracks of the current stream with new tracks using the 'unified-plan' method.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksForUnifiedPlan = function (shouldClone, newStream) {\n  var _this = this;\n  if (!newStream) {\n    return Promise.reject(new errors_1.InvalidArgumentError('Can not set input stream to null while in a call'));\n  }\n  if (!newStream.getAudioTracks().length) {\n    return Promise.reject(new errors_1.InvalidArgumentError('Supplied input stream has no audio tracks'));\n  }\n  var localStream = this.stream;\n  var getStreamPromise = function () {\n    // Apply mute settings to new input track\n    _this.mute(_this.isMuted);\n    return Promise.resolve(_this.stream);\n  };\n  if (!localStream) {\n    // We can't use MediaStream.clone() here because it stopped copying over tracks\n    //   as of Chrome 61. https://bugs.chromium.org/p/chromium/issues/detail?id=770908\n    this.stream = shouldClone ? cloneStream(newStream) : newStream;\n  } else {\n    // If the call was started with gUM, and we are now replacing that track with an\n    // external stream's tracks, we should stop the old managed track.\n    if (this._shouldManageStream) {\n      this._stopStream(localStream);\n    }\n    if (!this._sender) {\n      this._sender = this.version.pc.getSenders()[0];\n    }\n    return this._sender.replaceTrack(newStream.getAudioTracks()[0]).then(function () {\n      _this._updateInputStreamSource(newStream);\n      return getStreamPromise();\n    });\n  }\n  return getStreamPromise();\n};\nPeerConnection.prototype._onInputDevicesChanged = function () {\n  if (!this.stream) {\n    return;\n  }\n  // If all of our active tracks are ended, then our active input was lost\n  var activeInputWasLost = this.stream.getAudioTracks().every(function (track) {\n    return track.readyState === 'ended';\n  });\n  // We only want to act if we manage the stream in PeerConnection (It was created\n  // here, rather than passed in.)\n  if (activeInputWasLost && this._shouldManageStream) {\n    this.openWithConstraints(true);\n  }\n};\nPeerConnection.prototype._onIceGatheringFailure = function (type) {\n  this._hasIceGatheringFailures = true;\n  this.onicegatheringfailure(type);\n};\nPeerConnection.prototype._onMediaConnectionStateChange = function (newState) {\n  var previousState = this._iceState;\n  if (previousState === newState || newState !== 'connected' && newState !== 'disconnected' && newState !== 'failed') {\n    return;\n  }\n  this._iceState = newState;\n  var message;\n  switch (newState) {\n    case 'connected':\n      if (previousState === 'disconnected' || previousState === 'failed') {\n        message = 'ICE liveliness check succeeded. Connection with Twilio restored';\n        this._log.info(message);\n        this.onreconnected(message);\n      } else {\n        message = 'Media connection established.';\n        this._log.info(message);\n        this.onconnected(message);\n      }\n      this._stopIceGatheringTimeout();\n      this._hasIceGatheringFailures = false;\n      break;\n    case 'disconnected':\n      message = 'ICE liveliness check failed. May be having trouble connecting to Twilio';\n      this._log.info(message);\n      this.ondisconnected(message);\n      break;\n    case 'failed':\n      message = 'Connection with Twilio was interrupted.';\n      this._log.info(message);\n      this.onfailed(message);\n      break;\n  }\n};\nPeerConnection.prototype._setSinkIds = function (sinkIds) {\n  if (!this._isSinkSupported) {\n    return Promise.reject(new errors_1.NotSupportedError('Audio output selection is not supported by this browser'));\n  }\n  this.sinkIds = new Set(sinkIds.forEach ? sinkIds : [sinkIds]);\n  return this.version ? this._updateAudioOutputs() : Promise.resolve();\n};\n/**\n * Start timeout for ICE Gathering\n */\nPeerConnection.prototype._startIceGatheringTimeout = function startIceGatheringTimeout() {\n  var _this = this;\n  this._stopIceGatheringTimeout();\n  this._iceGatheringTimeoutId = setTimeout(function () {\n    _this._onIceGatheringFailure(ICE_GATHERING_FAIL_TIMEOUT);\n  }, ICE_GATHERING_TIMEOUT);\n};\n/**\n * Stop timeout for ICE Gathering\n */\nPeerConnection.prototype._stopIceGatheringTimeout = function stopIceGatheringTimeout() {\n  clearInterval(this._iceGatheringTimeoutId);\n};\nPeerConnection.prototype._updateAudioOutputs = function updateAudioOutputs() {\n  var addedOutputIds = Array.from(this.sinkIds).filter(function (id) {\n    return !this.outputs.has(id);\n  }, this);\n  var removedOutputIds = Array.from(this.outputs.keys()).filter(function (id) {\n    return !this.sinkIds.has(id);\n  }, this);\n  var self = this;\n  var createOutputPromises = addedOutputIds.map(this._createAudioOutput, this);\n  return Promise.all(createOutputPromises).then(function () {\n    return Promise.all(removedOutputIds.map(self._removeAudioOutput, self));\n  });\n};\nPeerConnection.prototype._createAudio = function createAudio(arr) {\n  var audio = new Audio(arr);\n  this.onaudio(audio);\n  return audio;\n};\nPeerConnection.prototype._createAudioOutput = function createAudioOutput(id) {\n  var dest = null;\n  if (this._mediaStreamSource) {\n    dest = this._audioContext.createMediaStreamDestination();\n    this._mediaStreamSource.connect(dest);\n  }\n  var audio = this._createAudio();\n  setAudioSource(audio, dest && dest.stream ? dest.stream : this.pcStream);\n  var self = this;\n  return audio.setSinkId(id).then(function () {\n    return audio.play();\n  }).then(function () {\n    self.outputs.set(id, {\n      audio: audio,\n      dest: dest\n    });\n  });\n};\nPeerConnection.prototype._removeAudioOutputs = function removeAudioOutputs() {\n  if (this._masterAudio && typeof this._masterAudioDeviceId !== 'undefined') {\n    this._disableOutput(this, this._masterAudioDeviceId);\n    this.outputs.delete(this._masterAudioDeviceId);\n    this._masterAudioDeviceId = null;\n    // Release the audio resources before deleting the audio\n    if (!this._masterAudio.paused) {\n      this._masterAudio.pause();\n    }\n    if (typeof this._masterAudio.srcObject !== 'undefined') {\n      this._masterAudio.srcObject = null;\n    } else {\n      this._masterAudio.src = '';\n    }\n    this._masterAudio = null;\n  }\n  return Array.from(this.outputs.keys()).map(this._removeAudioOutput, this);\n};\nPeerConnection.prototype._disableOutput = function disableOutput(pc, id) {\n  var output = pc.outputs.get(id);\n  if (!output) {\n    return;\n  }\n  if (output.audio) {\n    output.audio.pause();\n    output.audio.src = '';\n  }\n  if (output.dest) {\n    output.dest.disconnect();\n  }\n};\n/**\n * Disable a non-master output, and update the master output to assume its state. This\n *   is called when the device ID assigned to the master output has been removed from\n *   active devices. We can not simply remove the master audio output, so we must\n *   instead reassign it.\n * @private\n * @param {PeerConnection} pc\n * @param {string} masterId - The current device ID assigned to the master audio element.\n */\nPeerConnection.prototype._reassignMasterOutput = function reassignMasterOutput(pc, masterId) {\n  var masterOutput = pc.outputs.get(masterId);\n  pc.outputs.delete(masterId);\n  var self = this;\n  var idToReplace = Array.from(pc.outputs.keys())[0] || 'default';\n  return masterOutput.audio.setSinkId(idToReplace).then(function () {\n    self._disableOutput(pc, idToReplace);\n    pc.outputs.set(idToReplace, masterOutput);\n    pc._masterAudioDeviceId = idToReplace;\n  }).catch(function rollback() {\n    pc.outputs.set(masterId, masterOutput);\n    self._log.info('Could not reassign master output. Attempted to roll back.');\n  });\n};\nPeerConnection.prototype._removeAudioOutput = function removeAudioOutput(id) {\n  if (this._masterAudioDeviceId === id) {\n    return this._reassignMasterOutput(this, id);\n  }\n  this._disableOutput(this, id);\n  this.outputs.delete(id);\n  return Promise.resolve();\n};\n/**\n * Use an AudioContext to potentially split our audio output stream to multiple\n *   audio devices. This is only available to browsers with AudioContext and\n *   HTMLAudioElement.setSinkId() available. We save the source stream in\n *   _masterAudio, and use it for one of the active audio devices. We keep\n *   track of its ID because we must replace it if we lose its initial device.\n */\nPeerConnection.prototype._onAddTrack = function onAddTrack(pc, stream) {\n  var audio = pc._masterAudio = this._createAudio();\n  setAudioSource(audio, stream);\n  audio.play();\n  // Assign the initial master audio element to a random active output device\n  var deviceId = Array.from(pc.outputs.keys())[0] || 'default';\n  pc._masterAudioDeviceId = deviceId;\n  pc.outputs.set(deviceId, {\n    audio: audio\n  });\n  try {\n    pc._mediaStreamSource = pc._audioContext.createMediaStreamSource(stream);\n  } catch (ex) {\n    this._log.warn('Unable to create a MediaStreamSource from onAddTrack', ex);\n    this._mediaStreamSource = null;\n  }\n  pc.pcStream = stream;\n  pc._updateAudioOutputs();\n};\n/**\n * Use a single audio element to play the audio output stream. This does not\n *   support multiple output devices, and is a fallback for when AudioContext\n *   and/or HTMLAudioElement.setSinkId() is not available to the client.\n */\nPeerConnection.prototype._fallbackOnAddTrack = function fallbackOnAddTrack(pc, stream) {\n  var audio = document && document.createElement('audio');\n  audio.autoplay = true;\n  if (!setAudioSource(audio, stream)) {\n    pc._log.info('Error attaching stream to element.');\n  }\n  pc.outputs.set('default', {\n    audio: audio\n  });\n};\nPeerConnection.prototype._setEncodingParameters = function (enableDscp) {\n  if (!enableDscp || !this._sender || typeof this._sender.getParameters !== 'function' || typeof this._sender.setParameters !== 'function') {\n    return;\n  }\n  var params = this._sender.getParameters();\n  if (!params.priority && !(params.encodings && params.encodings.length)) {\n    return;\n  }\n  // This is how MDN's RTPSenderParameters defines priority\n  params.priority = 'high';\n  // And this is how it's currently implemented in Chrome M72+\n  if (params.encodings && params.encodings.length) {\n    params.encodings.forEach(function (encoding) {\n      encoding.priority = 'high';\n      encoding.networkPriority = 'high';\n    });\n  }\n  this._sender.setParameters(params);\n};\nPeerConnection.prototype._setupPeerConnection = function (rtcConstraints, rtcConfiguration) {\n  var _this = this;\n  var self = this;\n  var version = new (this.options.rtcpcFactory || rtcpc_1.default)({\n    RTCPeerConnection: this.options.RTCPeerConnection\n  });\n  version.create(rtcConstraints, rtcConfiguration);\n  addStream(version.pc, this.stream);\n  var eventName = 'ontrack' in version.pc ? 'ontrack' : 'onaddstream';\n  version.pc[eventName] = function (event) {\n    var stream = self._remoteStream = event.stream || event.streams[0];\n    if (typeof version.pc.getSenders === 'function') {\n      _this._sender = version.pc.getSenders()[0];\n    }\n    if (self._isSinkSupported) {\n      self._onAddTrack(self, stream);\n    } else {\n      self._fallbackOnAddTrack(self, stream);\n    }\n    self._startPollingVolume();\n  };\n  return version;\n};\nPeerConnection.prototype._maybeSetIceAggressiveNomination = function (sdp) {\n  return this.options.forceAggressiveIceNomination ? sdp_1.setIceAggressiveNomination(sdp) : sdp;\n};\nPeerConnection.prototype._setupChannel = function () {\n  var _this = this;\n  var pc = this.version.pc;\n  // Chrome 25 supports onopen\n  this.version.pc.onopen = function () {\n    _this.status = 'open';\n    _this.onopen();\n  };\n  // Chrome 26 doesn't support onopen so must detect state change\n  this.version.pc.onstatechange = function () {\n    if (_this.version.pc && _this.version.pc.readyState === 'stable') {\n      _this.status = 'open';\n      _this.onopen();\n    }\n  };\n  // Chrome 27 changed onstatechange to onsignalingstatechange\n  this.version.pc.onsignalingstatechange = function () {\n    var state = pc.signalingState;\n    _this._log.info(\"signalingState is \\\"\" + state + \"\\\"\");\n    if (_this.version.pc && _this.version.pc.signalingState === 'stable') {\n      _this.status = 'open';\n      _this.onopen();\n    }\n    _this.onsignalingstatechange(pc.signalingState);\n  };\n  // Chrome 72+\n  pc.onconnectionstatechange = function (event) {\n    var state = pc.connectionState;\n    if (!state && event && event.target) {\n      // VDI environment\n      var targetPc = event.target;\n      state = targetPc.connectionState || targetPc.connectionState_;\n      _this._log.info(\"pc.connectionState not detected. Using target PC. State=\" + state);\n    }\n    if (!state) {\n      _this._log.warn(\"onconnectionstatechange detected but state is \\\"\" + state + \"\\\"\");\n    } else {\n      _this._log.info(\"pc.connectionState is \\\"\" + state + \"\\\"\");\n    }\n    _this.onpcconnectionstatechange(state);\n    _this._onMediaConnectionStateChange(state);\n  };\n  pc.onicecandidate = function (event) {\n    var candidate = event.candidate;\n    if (candidate) {\n      _this._hasIceCandidates = true;\n      _this.onicecandidate(candidate);\n      _this._setupRTCIceTransportListener();\n    }\n    _this._log.info(\"ICE Candidate: \" + JSON.stringify(candidate));\n  };\n  pc.onicegatheringstatechange = function () {\n    var state = pc.iceGatheringState;\n    if (state === 'gathering') {\n      _this._startIceGatheringTimeout();\n    } else if (state === 'complete') {\n      _this._stopIceGatheringTimeout();\n      // Fail if no candidates found\n      if (!_this._hasIceCandidates) {\n        _this._onIceGatheringFailure(ICE_GATHERING_FAIL_NONE);\n      }\n      // There was a failure mid-gathering phase. We want to start our timer and issue\n      // an ice restart if we don't get connected after our timeout\n      if (_this._hasIceCandidates && _this._hasIceGatheringFailures) {\n        _this._startIceGatheringTimeout();\n      }\n    }\n    _this._log.info(\"pc.iceGatheringState is \\\"\" + pc.iceGatheringState + \"\\\"\");\n    _this.onicegatheringstatechange(state);\n  };\n  pc.oniceconnectionstatechange = function () {\n    _this._log.info(\"pc.iceConnectionState is \\\"\" + pc.iceConnectionState + \"\\\"\");\n    _this.oniceconnectionstatechange(pc.iceConnectionState);\n    _this._onMediaConnectionStateChange(pc.iceConnectionState);\n  };\n};\nPeerConnection.prototype._initializeMediaStream = function (rtcConstraints, rtcConfiguration) {\n  // if mediastream already open then do nothing\n  if (this.status === 'open') {\n    return false;\n  }\n  if (this.pstream.status === 'disconnected') {\n    this.onerror({\n      info: {\n        code: 31000,\n        message: 'Cannot establish connection. Client is disconnected',\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      }\n    });\n    this.close();\n    return false;\n  }\n  this.version = this._setupPeerConnection(rtcConstraints, rtcConfiguration);\n  this._setupChannel();\n  return true;\n};\n/**\n * Remove reconnection-related listeners\n * @private\n */\nPeerConnection.prototype._removeReconnectionListeners = function () {\n  if (this.pstream) {\n    this.pstream.removeListener('answer', this._onAnswerOrRinging);\n    this.pstream.removeListener('hangup', this._onHangup);\n  }\n};\n/**\n * Setup a listener for RTCDtlsTransport to capture state changes events\n * @private\n */\nPeerConnection.prototype._setupRTCDtlsTransportListener = function () {\n  var _this = this;\n  var dtlsTransport = this.getRTCDtlsTransport();\n  if (!dtlsTransport || dtlsTransport.onstatechange) {\n    return;\n  }\n  var handler = function () {\n    _this._log.info(\"dtlsTransportState is \\\"\" + dtlsTransport.state + \"\\\"\");\n    _this.ondtlstransportstatechange(dtlsTransport.state);\n  };\n  // Publish initial state\n  handler();\n  dtlsTransport.onstatechange = handler;\n};\n/**\n * Setup a listener for RTCIceTransport to capture selected candidate pair changes\n * @private\n */\nPeerConnection.prototype._setupRTCIceTransportListener = function () {\n  var _this = this;\n  var iceTransport = this._getRTCIceTransport();\n  if (!iceTransport || iceTransport.onselectedcandidatepairchange) {\n    return;\n  }\n  iceTransport.onselectedcandidatepairchange = function () {\n    return _this.onselectedcandidatepairchange(iceTransport.getSelectedCandidatePair());\n  };\n};\n/**\n * Restarts ICE for the current connection\n * ICE Restart failures are ignored. Retries are managed in Connection\n * @private\n */\nPeerConnection.prototype.iceRestart = function () {\n  var _this = this;\n  this._log.info('Attempting to restart ICE...');\n  this._hasIceCandidates = false;\n  this.version.createOffer(this.options.maxAverageBitrate, this.codecPreferences, {\n    iceRestart: true\n  }).then(function () {\n    _this._removeReconnectionListeners();\n    _this._onAnswerOrRinging = function (payload) {\n      _this._removeReconnectionListeners();\n      if (!payload.sdp || _this.version.pc.signalingState !== 'have-local-offer') {\n        var message = 'Invalid state or param during ICE Restart:' + (\"hasSdp:\" + !!payload.sdp + \", signalingState:\" + _this.version.pc.signalingState);\n        _this._log.info(message);\n        return;\n      }\n      var sdp = _this._maybeSetIceAggressiveNomination(payload.sdp);\n      _this._answerSdp = sdp;\n      if (_this.status !== 'closed') {\n        _this.version.processAnswer(_this.codecPreferences, sdp, null, function (err) {\n          var message = err && err.message ? err.message : err;\n          _this._log.info(\"Failed to process answer during ICE Restart. Error: \" + message);\n        });\n      }\n    };\n    _this._onHangup = function () {\n      _this._log.info('Received hangup during ICE Restart');\n      _this._removeReconnectionListeners();\n    };\n    _this.pstream.on('answer', _this._onAnswerOrRinging);\n    _this.pstream.on('hangup', _this._onHangup);\n    _this.pstream.reinvite(_this.version.getSDP(), _this.callSid);\n  }).catch(function (err) {\n    var message = err && err.message ? err.message : err;\n    _this._log.info(\"Failed to createOffer during ICE Restart. Error: \" + message);\n    // CreateOffer failures doesn't transition ice state to failed\n    // We need trigger it so it can be picked up by retries\n    _this.onfailed(message);\n  });\n};\nPeerConnection.prototype.makeOutgoingCall = function (token, params, callsid, rtcConstraints, rtcConfiguration, onMediaStarted) {\n  var _this = this;\n  if (!this._initializeMediaStream(rtcConstraints, rtcConfiguration)) {\n    return;\n  }\n  var self = this;\n  this.callSid = callsid;\n  function onAnswerSuccess() {\n    if (self.options) {\n      self._setEncodingParameters(self.options.dscp);\n    }\n    onMediaStarted(self.version.pc);\n  }\n  function onAnswerError(err) {\n    var errMsg = err.message || err;\n    self.onerror({\n      info: {\n        code: 31000,\n        message: \"Error processing answer: \" + errMsg,\n        twilioError: new errors_1.MediaErrors.ClientRemoteDescFailed()\n      }\n    });\n  }\n  this._onAnswerOrRinging = function (payload) {\n    if (!payload.sdp) {\n      return;\n    }\n    var sdp = _this._maybeSetIceAggressiveNomination(payload.sdp);\n    self._answerSdp = sdp;\n    if (self.status !== 'closed') {\n      self.version.processAnswer(_this.codecPreferences, sdp, onAnswerSuccess, onAnswerError);\n    }\n    self.pstream.removeListener('answer', self._onAnswerOrRinging);\n    self.pstream.removeListener('ringing', self._onAnswerOrRinging);\n  };\n  this.pstream.on('answer', this._onAnswerOrRinging);\n  this.pstream.on('ringing', this._onAnswerOrRinging);\n  function onOfferSuccess() {\n    if (self.status !== 'closed') {\n      self.pstream.invite(self.version.getSDP(), self.callSid, self.options.preflight, params);\n      self._setupRTCDtlsTransportListener();\n    }\n  }\n  function onOfferError(err) {\n    var errMsg = err.message || err;\n    self.onerror({\n      info: {\n        code: 31000,\n        message: \"Error creating the offer: \" + errMsg,\n        twilioError: new errors_1.MediaErrors.ClientLocalDescFailed()\n      }\n    });\n  }\n  this.version.createOffer(this.options.maxAverageBitrate, this.codecPreferences, {\n    audio: true\n  }, onOfferSuccess, onOfferError);\n};\nPeerConnection.prototype.answerIncomingCall = function (callSid, sdp, rtcConstraints, rtcConfiguration, onMediaStarted) {\n  if (!this._initializeMediaStream(rtcConstraints, rtcConfiguration)) {\n    return;\n  }\n  sdp = this._maybeSetIceAggressiveNomination(sdp);\n  this._answerSdp = sdp.replace(/^a=setup:actpass$/gm, 'a=setup:passive');\n  this.callSid = callSid;\n  var self = this;\n  function onAnswerSuccess() {\n    if (self.status !== 'closed') {\n      self.pstream.answer(self.version.getSDP(), callSid);\n      if (self.options) {\n        self._setEncodingParameters(self.options.dscp);\n      }\n      onMediaStarted(self.version.pc);\n      self._setupRTCDtlsTransportListener();\n    }\n  }\n  function onAnswerError(err) {\n    var errMsg = err.message || err;\n    self.onerror({\n      info: {\n        code: 31000,\n        message: \"Error creating the answer: \" + errMsg,\n        twilioError: new errors_1.MediaErrors.ClientRemoteDescFailed()\n      }\n    });\n  }\n  this.version.processSDP(this.options.maxAverageBitrate, this.codecPreferences, sdp, {\n    audio: true\n  }, onAnswerSuccess, onAnswerError);\n};\nPeerConnection.prototype.close = function () {\n  if (this.version && this.version.pc) {\n    if (this.version.pc.signalingState !== 'closed') {\n      this.version.pc.close();\n    }\n    this.version.pc = null;\n  }\n  if (this.stream) {\n    this.mute(false);\n    this._stopStream(this.stream);\n  }\n  this.stream = null;\n  this._removeReconnectionListeners();\n  this._stopIceGatheringTimeout();\n  Promise.all(this._removeAudioOutputs()).catch(function () {\n    // We don't need to alert about failures here.\n  });\n  if (this._mediaStreamSource) {\n    this._mediaStreamSource.disconnect();\n  }\n  if (this._inputAnalyser) {\n    this._inputAnalyser.disconnect();\n  }\n  if (this._outputAnalyser) {\n    this._outputAnalyser.disconnect();\n  }\n  if (this._inputAnalyser2) {\n    this._inputAnalyser2.disconnect();\n  }\n  if (this._outputAnalyser2) {\n    this._outputAnalyser2.disconnect();\n  }\n  this.status = 'closed';\n  this.onclose();\n};\nPeerConnection.prototype.reject = function (callSid) {\n  this.callSid = callSid;\n};\nPeerConnection.prototype.ignore = function (callSid) {\n  this.callSid = callSid;\n};\n/**\n * Mute or unmute input audio. If the stream is not yet present, the setting\n *   is saved and applied to future streams/tracks.\n * @params {boolean} shouldMute - Whether the input audio should\n *   be muted or unmuted.\n */\nPeerConnection.prototype.mute = function (shouldMute) {\n  this.isMuted = shouldMute;\n  if (!this.stream) {\n    return;\n  }\n  if (this._sender && this._sender.track) {\n    this._sender.track.enabled = !shouldMute;\n  } else {\n    var audioTracks = typeof this.stream.getAudioTracks === 'function' ? this.stream.getAudioTracks() : this.stream.audioTracks;\n    audioTracks.forEach(function (track) {\n      track.enabled = !shouldMute;\n    });\n  }\n};\n/**\n * Get or create an RTCDTMFSender for the first local audio MediaStreamTrack\n * we can get from the RTCPeerConnection. Return null if unsupported.\n * @instance\n * @returns ?RTCDTMFSender\n */\nPeerConnection.prototype.getOrCreateDTMFSender = function getOrCreateDTMFSender() {\n  if (this._dtmfSender || this._dtmfSenderUnsupported) {\n    return this._dtmfSender || null;\n  }\n  var self = this;\n  var pc = this.version.pc;\n  if (!pc) {\n    this._log.info('No RTCPeerConnection available to call createDTMFSender on');\n    return null;\n  }\n  if (typeof pc.getSenders === 'function' && (typeof RTCDTMFSender === 'function' || typeof RTCDtmfSender === 'function')) {\n    var chosenSender = pc.getSenders().find(function (sender) {\n      return sender.dtmf;\n    });\n    if (chosenSender) {\n      this._log.info('Using RTCRtpSender#dtmf');\n      this._dtmfSender = chosenSender.dtmf;\n      return this._dtmfSender;\n    }\n  }\n  if (typeof pc.createDTMFSender === 'function' && typeof pc.getLocalStreams === 'function') {\n    var track = pc.getLocalStreams().map(function (stream) {\n      var tracks = self._getAudioTracks(stream);\n      return tracks && tracks[0];\n    })[0];\n    if (!track) {\n      this._log.info('No local audio MediaStreamTrack available on the RTCPeerConnection to pass to createDTMFSender');\n      return null;\n    }\n    this._log.info('Creating RTCDTMFSender');\n    this._dtmfSender = pc.createDTMFSender(track);\n    return this._dtmfSender;\n  }\n  this._log.info('RTCPeerConnection does not support RTCDTMFSender');\n  this._dtmfSenderUnsupported = true;\n  return null;\n};\n/**\n * Get the RTCDtlTransport object from the PeerConnection\n * @returns RTCDtlTransport\n */\nPeerConnection.prototype.getRTCDtlsTransport = function getRTCDtlsTransport() {\n  var sender = this.version && this.version.pc && typeof this.version.pc.getSenders === 'function' && this.version.pc.getSenders()[0];\n  return sender && sender.transport || null;\n};\nPeerConnection.prototype._canStopMediaStreamTrack = function () {\n  return typeof MediaStreamTrack.prototype.stop === 'function';\n};\nPeerConnection.prototype._getAudioTracks = function (stream) {\n  return typeof stream.getAudioTracks === 'function' ? stream.getAudioTracks() : stream.audioTracks;\n};\n/**\n * Get the RTCIceTransport object from the PeerConnection\n * @returns RTCIceTransport\n */\nPeerConnection.prototype._getRTCIceTransport = function _getRTCIceTransport() {\n  var dtlsTransport = this.getRTCDtlsTransport();\n  return dtlsTransport && dtlsTransport.iceTransport || null;\n};\n// Is PeerConnection.protocol used outside of our SDK? We should remove this if not.\nPeerConnection.protocol = function () {\n  return rtcpc_1.default.test() ? new rtcpc_1.default() : null;\n}();\nfunction addStream(pc, stream) {\n  if (typeof pc.addTrack === 'function') {\n    stream.getAudioTracks().forEach(function (track) {\n      // The second parameters, stream, should not be necessary per the latest editor's\n      //   draft, but FF requires it. https://bugzilla.mozilla.org/show_bug.cgi?id=1231414\n      pc.addTrack(track, stream);\n    });\n  } else {\n    pc.addStream(stream);\n  }\n}\nfunction cloneStream(oldStream) {\n  var newStream = typeof MediaStream !== 'undefined' ? new MediaStream() : new webkitMediaStream();\n  oldStream.getAudioTracks().forEach(newStream.addTrack, newStream);\n  return newStream;\n}\nfunction removeStream(pc, stream) {\n  if (typeof pc.removeTrack === 'function') {\n    pc.getSenders().forEach(function (sender) {\n      pc.removeTrack(sender);\n    });\n  } else {\n    pc.removeStream(stream);\n  }\n}\n/**\n * Set the source of an HTMLAudioElement to the specified MediaStream\n * @param {HTMLAudioElement} audio\n * @param {MediaStream} stream\n * @returns {boolean} Whether the audio source was set successfully\n */\nfunction setAudioSource(audio, stream) {\n  if (typeof audio.srcObject !== 'undefined') {\n    audio.srcObject = stream;\n  } else if (typeof audio.mozSrcObject !== 'undefined') {\n    audio.mozSrcObject = stream;\n  } else if (typeof audio.src !== 'undefined') {\n    var _window = audio.options.window || window;\n    audio.src = (_window.URL || _window.webkitURL).createObjectURL(stream);\n  } else {\n    return false;\n  }\n  return true;\n}\nPeerConnection.enabled = rtcpc_1.default.test();\nexports.default = PeerConnection;","map":{"version":3,"names":["errors_1","require","log_1","util","rtcpc_1","sdp_1","ICE_GATHERING_TIMEOUT","ICE_GATHERING_FAIL_NONE","ICE_GATHERING_FAIL_TIMEOUT","INITIAL_ICE_CONNECTION_STATE","VOLUME_INTERVAL_MS","PeerConnection","audioHelper","pstream","getUserMedia","options","InvalidArgumentError","_log","default","getInstance","noop","warn","onaudio","onopen","onerror","onclose","ondisconnected","onfailed","onconnected","onreconnected","onsignalingstatechange","ondtlstransportstatechange","onicegatheringfailure","onicegatheringstatechange","oniceconnectionstatechange","onpcconnectionstatechange","onicecandidate","onselectedcandidatepairchange","onvolume","version","stream","sinkIds","Set","outputs","Map","status","callSid","isMuted","AudioContext","window","webkitAudioContext","_isSinkSupported","HTMLAudioElement","prototype","setSinkId","_audioContext","_hasIceCandidates","_hasIceGatheringFailures","_iceGatheringTimeoutId","_masterAudio","_masterAudioDeviceId","_mediaStreamSource","_dtmfSender","_dtmfSenderUnsupported","_callEvents","_nextTimeToPublish","Date","now","_onAnswerOrRinging","_onHangup","_remoteStream","_shouldManageStream","_iceState","_isUnifiedPlan","isUnifiedPlan","navigator","codecPreferences","uri","_uri","openWithConstraints","constraints","audio","then","_setInputTracksFromStream","bind","setInputTracksFromStream","self","_createAnalyser","audioContext","Object","assign","fftSize","smoothingTimeConstant","analyser","createAnalyser","field","_setVolumeHandler","handler","_startPollingVolume","inputAnalyser","_inputAnalyser","inputBufferLength","frequencyBinCount","inputDataArray","Uint8Array","_inputAnalyser2","maxDecibels","minDecibels","outputAnalyser","_outputAnalyser","outputBufferLength","outputDataArray","_outputAnalyser2","_updateInputStreamSource","_updateOutputStreamSource","setTimeout","emitVolume","disconnect","getByteFrequencyData","inputVolume","average","inputVolume2","outputVolume","outputVolume2","_stopStream","MediaStreamTrack","stop","audioTracks","getAudioTracks","forEach","track","_inputStreamSource","createMediaStreamSource","connect","ex","_outputStreamSource","shouldClone","newStream","_setInputTracksForUnifiedPlan","_setInputTracksForPlanB","_this","Promise","reject","length","localStream","cloneStream","removeStream","pc","removeTrack","addTrack","addStream","mute","resolve","createOffer","maxAverageBitrate","processAnswer","_answerSdp","getStreamPromise","_sender","getSenders","replaceTrack","_onInputDevicesChanged","activeInputWasLost","every","readyState","_onIceGatheringFailure","type","_onMediaConnectionStateChange","newState","previousState","message","info","_stopIceGatheringTimeout","_setSinkIds","NotSupportedError","_updateAudioOutputs","_startIceGatheringTimeout","startIceGatheringTimeout","stopIceGatheringTimeout","clearInterval","updateAudioOutputs","addedOutputIds","Array","from","filter","id","has","removedOutputIds","keys","createOutputPromises","map","_createAudioOutput","all","_removeAudioOutput","_createAudio","createAudio","arr","Audio","createAudioOutput","dest","createMediaStreamDestination","setAudioSource","pcStream","play","set","_removeAudioOutputs","removeAudioOutputs","_disableOutput","delete","paused","pause","srcObject","src","disableOutput","output","get","_reassignMasterOutput","reassignMasterOutput","masterId","masterOutput","idToReplace","catch","rollback","removeAudioOutput","_onAddTrack","onAddTrack","deviceId","_fallbackOnAddTrack","fallbackOnAddTrack","document","createElement","autoplay","_setEncodingParameters","enableDscp","getParameters","setParameters","params","priority","encodings","encoding","networkPriority","_setupPeerConnection","rtcConstraints","rtcConfiguration","rtcpcFactory","RTCPeerConnection","create","eventName","event","streams","_maybeSetIceAggressiveNomination","sdp","forceAggressiveIceNomination","setIceAggressiveNomination","_setupChannel","onstatechange","state","signalingState","onconnectionstatechange","connectionState","target","targetPc","connectionState_","candidate","_setupRTCIceTransportListener","JSON","stringify","iceGatheringState","iceConnectionState","_initializeMediaStream","code","twilioError","SignalingErrors","ConnectionDisconnected","close","_removeReconnectionListeners","removeListener","_setupRTCDtlsTransportListener","dtlsTransport","getRTCDtlsTransport","iceTransport","_getRTCIceTransport","getSelectedCandidatePair","iceRestart","payload","err","on","reinvite","getSDP","makeOutgoingCall","token","callsid","onMediaStarted","onAnswerSuccess","dscp","onAnswerError","errMsg","MediaErrors","ClientRemoteDescFailed","onOfferSuccess","invite","preflight","onOfferError","ClientLocalDescFailed","answerIncomingCall","replace","answer","processSDP","ignore","shouldMute","enabled","getOrCreateDTMFSender","RTCDTMFSender","RTCDtmfSender","chosenSender","find","sender","dtmf","createDTMFSender","getLocalStreams","tracks","_getAudioTracks","transport","_canStopMediaStreamTrack","protocol","test","oldStream","MediaStream","webkitMediaStream","mozSrcObject","_window","URL","webkitURL","createObjectURL","exports"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/@twilio/voice-sdk/lib/twilio/rtc/peerconnection.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n// @ts-nocheck\nimport {\n  InvalidArgumentError,\n  MediaErrors,\n  NotSupportedError,\n  SignalingErrors,\n} from '../errors';\nimport Log from '../log';\nimport * as util from '../util';\nimport RTCPC from './rtcpc';\nimport { setIceAggressiveNomination } from './sdp';\n\nconst ICE_GATHERING_TIMEOUT = 15000;\nconst ICE_GATHERING_FAIL_NONE = 'none';\nconst ICE_GATHERING_FAIL_TIMEOUT = 'timeout';\nconst INITIAL_ICE_CONNECTION_STATE = 'new';\nconst VOLUME_INTERVAL_MS = 50;\n\n/**\n * @typedef {Object} PeerConnection\n * @param audioHelper\n * @param pstream\n * @param options\n * @return {PeerConnection}\n * @constructor\n */\nfunction PeerConnection(audioHelper, pstream, getUserMedia, options) {\n  if (!audioHelper || !pstream || !getUserMedia) {\n    throw new InvalidArgumentError('Audiohelper, pstream and getUserMedia are required arguments');\n  }\n\n  if (!(this instanceof PeerConnection)) {\n    return new PeerConnection(audioHelper, pstream, getUserMedia, options);\n  }\n\n  this._log = Log.getInstance();\n\n  function noop() {\n    this._log.warn('Unexpected noop call in peerconnection');\n  }\n  this.onaudio = noop;\n  this.onopen = noop;\n  this.onerror = noop;\n  this.onclose = noop;\n  this.ondisconnected = noop;\n  this.onfailed = noop;\n  this.onconnected = noop;\n  this.onreconnected = noop;\n  this.onsignalingstatechange = noop;\n  this.ondtlstransportstatechange = noop;\n  this.onicegatheringfailure = noop;\n  this.onicegatheringstatechange = noop;\n  this.oniceconnectionstatechange = noop;\n  this.onpcconnectionstatechange = noop;\n  this.onicecandidate = noop;\n  this.onselectedcandidatepairchange = noop;\n  this.onvolume = noop;\n  this.version = null;\n  this.pstream = pstream;\n  this.stream = null;\n  this.sinkIds = new Set(['default']);\n  this.outputs = new Map();\n  this.status = 'connecting';\n  this.callSid = null;\n  this.isMuted = false;\n  this.getUserMedia = getUserMedia;\n\n  const AudioContext = typeof window !== 'undefined'\n    && (window.AudioContext || window.webkitAudioContext);\n  this._isSinkSupported = !!AudioContext &&\n    typeof HTMLAudioElement !== 'undefined' && HTMLAudioElement.prototype.setSinkId;\n  // NOTE(mmalavalli): Since each Connection creates its own AudioContext,\n  // after 6 instances an exception is thrown. Refer https://www.w3.org/2011/audio/track/issues/3.\n  // In order to get around it, we are re-using the Device's AudioContext.\n  this._audioContext = AudioContext && audioHelper._audioContext;\n  this._hasIceCandidates = false;\n  this._hasIceGatheringFailures = false;\n  this._iceGatheringTimeoutId = null;\n  this._masterAudio = null;\n  this._masterAudioDeviceId = null;\n  this._mediaStreamSource = null;\n  this._dtmfSender = null;\n  this._dtmfSenderUnsupported = false;\n  this._callEvents = [];\n  this._nextTimeToPublish = Date.now();\n  this._onAnswerOrRinging = noop;\n  this._onHangup = noop;\n  this._remoteStream = null;\n  this._shouldManageStream = true;\n  this._iceState = INITIAL_ICE_CONNECTION_STATE;\n  this._isUnifiedPlan = options.isUnifiedPlan;\n\n  this.options = options = options || {};\n  this.navigator = options.navigator\n    || (typeof navigator !== 'undefined' ? navigator : null);\n  this.util = options.util || util;\n  this.codecPreferences = options.codecPreferences;\n\n  return this;\n}\n\nPeerConnection.prototype.uri = function() {\n  return this._uri;\n};\n\n/**\n * Open the underlying RTCPeerConnection with a MediaStream obtained by\n *   passed constraints. The resulting MediaStream is created internally\n *   and will therefore be managed and destroyed internally.\n * @param {MediaStreamConstraints} constraints\n */\nPeerConnection.prototype.openWithConstraints = function(constraints) {\n  return this.getUserMedia({ audio: constraints })\n    .then(this._setInputTracksFromStream.bind(this, false));\n};\n\n/**\n * Replace the existing input audio tracks with the audio tracks from the\n *   passed input audio stream. We re-use the existing stream because\n *   the AnalyzerNode is bound to the stream.\n * @param {MediaStream} stream\n */\nPeerConnection.prototype.setInputTracksFromStream = function(stream) {\n  const self = this;\n  return this._setInputTracksFromStream(true, stream).then(() => {\n    self._shouldManageStream = false;\n  });\n};\n\nPeerConnection.prototype._createAnalyser = (audioContext, options) => {\n  options = Object.assign({\n    fftSize: 32,\n    smoothingTimeConstant: 0.3,\n  }, options);\n\n  const analyser = audioContext.createAnalyser();\n  // tslint:disable-next-line\n  for (const field in options) {\n    analyser[field] = options[field];\n  }\n\n  return analyser;\n};\n\nPeerConnection.prototype._setVolumeHandler = function(handler) {\n  this.onvolume = handler;\n};\nPeerConnection.prototype._startPollingVolume = function() {\n  if (!this._audioContext || !this.stream || !this._remoteStream) {\n    return;\n  }\n\n  const audioContext = this._audioContext;\n\n  const inputAnalyser = this._inputAnalyser = this._createAnalyser(audioContext);\n  const inputBufferLength = inputAnalyser.frequencyBinCount;\n  const inputDataArray = new Uint8Array(inputBufferLength);\n  this._inputAnalyser2 = this._createAnalyser(audioContext, {\n    maxDecibels: 0,\n    minDecibels: -127,\n    smoothingTimeConstant: 0,\n  });\n\n  const outputAnalyser = this._outputAnalyser = this._createAnalyser(audioContext);\n  const outputBufferLength = outputAnalyser.frequencyBinCount;\n  const outputDataArray = new Uint8Array(outputBufferLength);\n  this._outputAnalyser2 = this._createAnalyser(audioContext, {\n    maxDecibels: 0,\n    minDecibels: -127,\n    smoothingTimeConstant: 0,\n  });\n\n  this._updateInputStreamSource(this.stream);\n  this._updateOutputStreamSource(this._remoteStream);\n\n  const self = this;\n  setTimeout(function emitVolume() {\n    if (!self._audioContext) {\n      return;\n    } else if (self.status === 'closed') {\n      self._inputAnalyser.disconnect();\n      self._outputAnalyser.disconnect();\n      self._inputAnalyser2.disconnect();\n      self._outputAnalyser2.disconnect();\n      return;\n    }\n\n    self._inputAnalyser.getByteFrequencyData(inputDataArray);\n    const inputVolume = self.util.average(inputDataArray);\n\n    self._inputAnalyser2.getByteFrequencyData(inputDataArray);\n    const inputVolume2 = self.util.average(inputDataArray);\n\n    self._outputAnalyser.getByteFrequencyData(outputDataArray);\n    const outputVolume = self.util.average(outputDataArray);\n\n    self._outputAnalyser2.getByteFrequencyData(outputDataArray);\n    const outputVolume2 = self.util.average(outputDataArray);\n    self.onvolume(inputVolume / 255, outputVolume / 255, inputVolume2, outputVolume2);\n\n    setTimeout(emitVolume, VOLUME_INTERVAL_MS);\n  }, VOLUME_INTERVAL_MS);\n};\n\nPeerConnection.prototype._stopStream = function _stopStream(stream) {\n  // We shouldn't stop the tracks if they were not created inside\n  //   this PeerConnection.\n  if (!this._shouldManageStream) {\n    return;\n  }\n\n  if (typeof MediaStreamTrack.prototype.stop === 'function') {\n    const audioTracks = typeof stream.getAudioTracks === 'function'\n      ? stream.getAudioTracks() : stream.audioTracks;\n    audioTracks.forEach(track => {\n      track.stop();\n    });\n  } else {\n    // NOTE(mroberts): This is just a fallback to any ancient browsers that may\n    // not implement MediaStreamTrack.stop.\n    stream.stop();\n  }\n};\n\n/**\n * Update the stream source with the new input audio stream.\n * @param {MediaStream} stream\n * @private\n */\nPeerConnection.prototype._updateInputStreamSource = function(stream) {\n  if (this._inputStreamSource) {\n    this._inputStreamSource.disconnect();\n  }\n\n  try {\n    this._inputStreamSource = this._audioContext.createMediaStreamSource(stream);\n    this._inputStreamSource.connect(this._inputAnalyser);\n    this._inputStreamSource.connect(this._inputAnalyser2);\n  } catch (ex) {\n    this._log.warn('Unable to update input MediaStreamSource', ex);\n    this._inputStreamSource = null;\n  }\n};\n\n/**\n * Update the stream source with the new ouput audio stream.\n * @param {MediaStream} stream\n * @private\n */\nPeerConnection.prototype._updateOutputStreamSource = function(stream) {\n  if (this._outputStreamSource) {\n    this._outputStreamSource.disconnect();\n  }\n\n  try {\n    this._outputStreamSource = this._audioContext.createMediaStreamSource(stream);\n    this._outputStreamSource.connect(this._outputAnalyser);\n    this._outputStreamSource.connect(this._outputAnalyser2);\n  } catch (ex) {\n    this._log.warn('Unable to update output MediaStreamSource', ex);\n    this._outputStreamSource = null;\n  }\n};\n\n/**\n * Replace the tracks of the current stream with new tracks. We do this rather than replacing the\n *   whole stream because AnalyzerNodes are bound to a stream.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksFromStream = function(shouldClone, newStream) {\n  return this._isUnifiedPlan\n    ? this._setInputTracksForUnifiedPlan(shouldClone, newStream)\n    : this._setInputTracksForPlanB(shouldClone, newStream);\n};\n\n/**\n * Replace the tracks of the current stream with new tracks using the 'plan-b' method.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksForPlanB = function(shouldClone, newStream) {\n  if (!newStream) {\n    return Promise.reject(new InvalidArgumentError('Can not set input stream to null while in a call'));\n  }\n\n  if (!newStream.getAudioTracks().length) {\n    return Promise.reject(new InvalidArgumentError('Supplied input stream has no audio tracks'));\n  }\n\n  const localStream = this.stream;\n\n  if (!localStream) {\n    // We can't use MediaStream.clone() here because it stopped copying over tracks\n    //   as of Chrome 61. https://bugs.chromium.org/p/chromium/issues/detail?id=770908\n    this.stream = shouldClone ? cloneStream(newStream) : newStream;\n  } else {\n    this._stopStream(localStream);\n\n    removeStream(this.version.pc, localStream);\n    localStream.getAudioTracks().forEach(localStream.removeTrack, localStream);\n    newStream.getAudioTracks().forEach(localStream.addTrack, localStream);\n    addStream(this.version.pc, newStream);\n\n    this._updateInputStreamSource(this.stream);\n  }\n\n  // Apply mute settings to new input track\n  this.mute(this.isMuted);\n\n  if (!this.version) {\n    return Promise.resolve(this.stream);\n  }\n\n  return new Promise((resolve, reject) => {\n    this.version.createOffer(this.options.maxAverageBitrate, this.codecPreferences, { audio: true }, () => {\n      this.version.processAnswer(this.codecPreferences, this._answerSdp, () => {\n        resolve(this.stream);\n      }, reject);\n    }, reject);\n  });\n};\n\n/**\n * Replace the tracks of the current stream with new tracks using the 'unified-plan' method.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksForUnifiedPlan = function(shouldClone, newStream) {\n  if (!newStream) {\n    return Promise.reject(new InvalidArgumentError('Can not set input stream to null while in a call'));\n  }\n\n  if (!newStream.getAudioTracks().length) {\n    return Promise.reject(new InvalidArgumentError('Supplied input stream has no audio tracks'));\n  }\n\n  const localStream = this.stream;\n  const getStreamPromise = () => {\n    // Apply mute settings to new input track\n    this.mute(this.isMuted);\n    return Promise.resolve(this.stream);\n  };\n\n  if (!localStream) {\n    // We can't use MediaStream.clone() here because it stopped copying over tracks\n    //   as of Chrome 61. https://bugs.chromium.org/p/chromium/issues/detail?id=770908\n    this.stream = shouldClone ? cloneStream(newStream) : newStream;\n  } else {\n    // If the call was started with gUM, and we are now replacing that track with an\n    // external stream's tracks, we should stop the old managed track.\n    if (this._shouldManageStream) {\n      this._stopStream(localStream);\n    }\n\n    if (!this._sender) {\n      this._sender = this.version.pc.getSenders()[0];\n    }\n\n    return this._sender.replaceTrack(newStream.getAudioTracks()[0]).then(() => {\n      this._updateInputStreamSource(newStream);\n      return getStreamPromise();\n    });\n  }\n\n  return getStreamPromise();\n};\n\nPeerConnection.prototype._onInputDevicesChanged = function() {\n  if (!this.stream) { return; }\n\n  // If all of our active tracks are ended, then our active input was lost\n  const activeInputWasLost = this.stream.getAudioTracks().every(track => track.readyState === 'ended');\n\n  // We only want to act if we manage the stream in PeerConnection (It was created\n  // here, rather than passed in.)\n  if (activeInputWasLost && this._shouldManageStream) {\n    this.openWithConstraints(true);\n  }\n};\n\nPeerConnection.prototype._onIceGatheringFailure = function(type) {\n  this._hasIceGatheringFailures = true;\n  this.onicegatheringfailure(type);\n};\n\nPeerConnection.prototype._onMediaConnectionStateChange = function(newState) {\n  const previousState = this._iceState;\n\n  if (previousState === newState\n    || (newState !== 'connected'\n    && newState !== 'disconnected'\n    && newState !== 'failed')) {\n    return;\n  }\n  this._iceState = newState;\n\n  let message;\n  switch (newState) {\n    case 'connected':\n      if (previousState === 'disconnected' || previousState === 'failed') {\n        message = 'ICE liveliness check succeeded. Connection with Twilio restored';\n        this._log.info(message);\n        this.onreconnected(message);\n      } else {\n        message = 'Media connection established.';\n        this._log.info(message);\n        this.onconnected(message);\n      }\n      this._stopIceGatheringTimeout();\n      this._hasIceGatheringFailures = false;\n      break;\n    case 'disconnected':\n      message = 'ICE liveliness check failed. May be having trouble connecting to Twilio';\n      this._log.info(message);\n      this.ondisconnected(message);\n      break;\n    case 'failed':\n      message = 'Connection with Twilio was interrupted.';\n      this._log.info(message);\n      this.onfailed(message);\n      break;\n  }\n};\n\nPeerConnection.prototype._setSinkIds = function(sinkIds) {\n  if (!this._isSinkSupported) {\n    return Promise.reject(new NotSupportedError('Audio output selection is not supported by this browser'));\n  }\n\n  this.sinkIds = new Set(sinkIds.forEach ? sinkIds : [sinkIds]);\n  return this.version\n    ? this._updateAudioOutputs()\n    : Promise.resolve();\n};\n\n/**\n * Start timeout for ICE Gathering\n */\nPeerConnection.prototype._startIceGatheringTimeout = function startIceGatheringTimeout() {\n  this._stopIceGatheringTimeout();\n  this._iceGatheringTimeoutId = setTimeout(() => {\n    this._onIceGatheringFailure(ICE_GATHERING_FAIL_TIMEOUT);\n  }, ICE_GATHERING_TIMEOUT);\n};\n\n/**\n * Stop timeout for ICE Gathering\n */\nPeerConnection.prototype._stopIceGatheringTimeout = function stopIceGatheringTimeout() {\n  clearInterval(this._iceGatheringTimeoutId);\n};\n\nPeerConnection.prototype._updateAudioOutputs = function updateAudioOutputs() {\n  const addedOutputIds = Array.from(this.sinkIds).filter(function(id) {\n    return !this.outputs.has(id);\n  }, this);\n\n  const removedOutputIds = Array.from(this.outputs.keys()).filter(function(id) {\n    return !this.sinkIds.has(id);\n  }, this);\n\n  const self = this;\n  const createOutputPromises = addedOutputIds.map(this._createAudioOutput, this);\n  return Promise.all(createOutputPromises).then(() => Promise.all(removedOutputIds.map(self._removeAudioOutput, self)));\n};\n\nPeerConnection.prototype._createAudio = function createAudio(arr) {\n  const audio = new Audio(arr);\n  this.onaudio(audio);\n  return audio;\n};\n\nPeerConnection.prototype._createAudioOutput = function createAudioOutput(id) {\n  let dest = null;\n  if (this._mediaStreamSource) {\n    dest = this._audioContext.createMediaStreamDestination();\n    this._mediaStreamSource.connect(dest);\n  }\n\n  const audio = this._createAudio();\n  setAudioSource(audio, dest && dest.stream ? dest.stream : this.pcStream);\n\n  const self = this;\n  return audio.setSinkId(id).then(() => audio.play()).then(() => {\n    self.outputs.set(id, {\n      audio,\n      dest,\n    });\n  });\n};\n\nPeerConnection.prototype._removeAudioOutputs = function removeAudioOutputs() {\n  if (this._masterAudio && typeof this._masterAudioDeviceId !== 'undefined') {\n    this._disableOutput(this, this._masterAudioDeviceId);\n    this.outputs.delete(this._masterAudioDeviceId);\n    this._masterAudioDeviceId = null;\n\n    // Release the audio resources before deleting the audio\n    if (!this._masterAudio.paused) {\n      this._masterAudio.pause();\n    }\n    if (typeof this._masterAudio.srcObject !== 'undefined') {\n      this._masterAudio.srcObject = null;\n    } else {\n      this._masterAudio.src = '';\n    }\n    this._masterAudio = null;\n  }\n\n  return Array.from(this.outputs.keys()).map(this._removeAudioOutput, this);\n};\n\nPeerConnection.prototype._disableOutput = function disableOutput(pc, id) {\n  const output = pc.outputs.get(id);\n  if (!output) { return; }\n\n  if (output.audio) {\n    output.audio.pause();\n    output.audio.src = '';\n  }\n\n  if (output.dest) {\n    output.dest.disconnect();\n  }\n};\n\n/**\n * Disable a non-master output, and update the master output to assume its state. This\n *   is called when the device ID assigned to the master output has been removed from\n *   active devices. We can not simply remove the master audio output, so we must\n *   instead reassign it.\n * @private\n * @param {PeerConnection} pc\n * @param {string} masterId - The current device ID assigned to the master audio element.\n */\nPeerConnection.prototype._reassignMasterOutput = function reassignMasterOutput(pc, masterId) {\n  const masterOutput = pc.outputs.get(masterId);\n  pc.outputs.delete(masterId);\n\n  const self = this;\n  const idToReplace = Array.from(pc.outputs.keys())[0] || 'default';\n  return masterOutput.audio.setSinkId(idToReplace).then(() => {\n    self._disableOutput(pc, idToReplace);\n\n    pc.outputs.set(idToReplace, masterOutput);\n    pc._masterAudioDeviceId = idToReplace;\n  }).catch(function rollback() {\n    pc.outputs.set(masterId, masterOutput);\n    self._log.info('Could not reassign master output. Attempted to roll back.');\n  });\n};\n\nPeerConnection.prototype._removeAudioOutput = function removeAudioOutput(id) {\n  if (this._masterAudioDeviceId === id) {\n    return this._reassignMasterOutput(this, id);\n  }\n\n  this._disableOutput(this, id);\n  this.outputs.delete(id);\n\n  return Promise.resolve();\n};\n\n/**\n * Use an AudioContext to potentially split our audio output stream to multiple\n *   audio devices. This is only available to browsers with AudioContext and\n *   HTMLAudioElement.setSinkId() available. We save the source stream in\n *   _masterAudio, and use it for one of the active audio devices. We keep\n *   track of its ID because we must replace it if we lose its initial device.\n */\nPeerConnection.prototype._onAddTrack = function onAddTrack(pc, stream) {\n  const audio = pc._masterAudio = this._createAudio();\n  setAudioSource(audio, stream);\n  audio.play();\n\n  // Assign the initial master audio element to a random active output device\n  const deviceId = Array.from(pc.outputs.keys())[0] || 'default';\n  pc._masterAudioDeviceId = deviceId;\n  pc.outputs.set(deviceId, { audio });\n\n  try {\n    pc._mediaStreamSource = pc._audioContext.createMediaStreamSource(stream);\n  } catch (ex) {\n    this._log.warn('Unable to create a MediaStreamSource from onAddTrack', ex);\n    this._mediaStreamSource = null;\n  }\n\n  pc.pcStream = stream;\n  pc._updateAudioOutputs();\n};\n\n/**\n * Use a single audio element to play the audio output stream. This does not\n *   support multiple output devices, and is a fallback for when AudioContext\n *   and/or HTMLAudioElement.setSinkId() is not available to the client.\n */\nPeerConnection.prototype._fallbackOnAddTrack = function fallbackOnAddTrack(pc, stream) {\n  const audio = document && document.createElement('audio');\n  audio.autoplay = true;\n\n  if (!setAudioSource(audio, stream)) {\n    pc._log.info('Error attaching stream to element.');\n  }\n\n  pc.outputs.set('default', { audio });\n};\n\nPeerConnection.prototype._setEncodingParameters = function(enableDscp) {\n  if (!enableDscp\n      || !this._sender\n      || typeof this._sender.getParameters !== 'function'\n      || typeof this._sender.setParameters !== 'function') {\n    return;\n  }\n\n  const params = this._sender.getParameters();\n  if (!params.priority && !(params.encodings && params.encodings.length)) {\n    return;\n  }\n\n  // This is how MDN's RTPSenderParameters defines priority\n  params.priority = 'high';\n\n  // And this is how it's currently implemented in Chrome M72+\n  if (params.encodings && params.encodings.length) {\n    params.encodings.forEach(encoding => {\n      encoding.priority = 'high';\n      encoding.networkPriority = 'high';\n    });\n  }\n\n  this._sender.setParameters(params);\n};\n\nPeerConnection.prototype._setupPeerConnection = function(rtcConstraints, rtcConfiguration) {\n  const self = this;\n  const version = new (this.options.rtcpcFactory || RTCPC)({ RTCPeerConnection: this.options.RTCPeerConnection });\n  version.create(rtcConstraints, rtcConfiguration);\n  addStream(version.pc, this.stream);\n\n  const eventName = 'ontrack' in version.pc\n    ? 'ontrack' : 'onaddstream';\n\n  version.pc[eventName] = event => {\n    const stream = self._remoteStream = event.stream || event.streams[0];\n\n    if (typeof version.pc.getSenders === 'function') {\n      this._sender = version.pc.getSenders()[0];\n    }\n\n    if (self._isSinkSupported) {\n      self._onAddTrack(self, stream);\n    } else {\n      self._fallbackOnAddTrack(self, stream);\n    }\n\n    self._startPollingVolume();\n  };\n  return version;\n};\n\nPeerConnection.prototype._maybeSetIceAggressiveNomination = function(sdp) {\n  return this.options.forceAggressiveIceNomination ? setIceAggressiveNomination(sdp) : sdp;\n};\n\nPeerConnection.prototype._setupChannel = function() {\n  const pc = this.version.pc;\n\n  // Chrome 25 supports onopen\n  this.version.pc.onopen = () => {\n    this.status = 'open';\n    this.onopen();\n  };\n\n  // Chrome 26 doesn't support onopen so must detect state change\n  this.version.pc.onstatechange = () => {\n    if (this.version.pc && this.version.pc.readyState === 'stable') {\n      this.status = 'open';\n      this.onopen();\n    }\n  };\n\n  // Chrome 27 changed onstatechange to onsignalingstatechange\n  this.version.pc.onsignalingstatechange = () => {\n    const state = pc.signalingState;\n    this._log.info(`signalingState is \"${state}\"`);\n\n    if (this.version.pc && this.version.pc.signalingState === 'stable') {\n      this.status = 'open';\n      this.onopen();\n    }\n\n    this.onsignalingstatechange(pc.signalingState);\n  };\n\n  // Chrome 72+\n  pc.onconnectionstatechange = event => {\n    let state = pc.connectionState;\n    if (!state && event && event.target) {\n      // VDI environment\n      const targetPc = event.target;\n      state = targetPc.connectionState || targetPc.connectionState_;\n      this._log.info(`pc.connectionState not detected. Using target PC. State=${state}`);\n    }\n    if (!state) {\n      this._log.warn(`onconnectionstatechange detected but state is \"${state}\"`);\n    } else {\n      this._log.info(`pc.connectionState is \"${state}\"`);\n    }\n    this.onpcconnectionstatechange(state);\n    this._onMediaConnectionStateChange(state);\n  };\n\n  pc.onicecandidate =  event => {\n    const { candidate } = event;\n    if (candidate) {\n      this._hasIceCandidates = true;\n      this.onicecandidate(candidate);\n      this._setupRTCIceTransportListener();\n    }\n\n    this._log.info(`ICE Candidate: ${JSON.stringify(candidate)}`);\n  };\n\n  pc.onicegatheringstatechange = () => {\n    const state = pc.iceGatheringState;\n    if (state === 'gathering') {\n      this._startIceGatheringTimeout();\n\n    } else if (state === 'complete') {\n      this._stopIceGatheringTimeout();\n\n      // Fail if no candidates found\n      if (!this._hasIceCandidates) {\n        this._onIceGatheringFailure(ICE_GATHERING_FAIL_NONE);\n      }\n\n      // There was a failure mid-gathering phase. We want to start our timer and issue\n      // an ice restart if we don't get connected after our timeout\n      if (this._hasIceCandidates && this._hasIceGatheringFailures) {\n        this._startIceGatheringTimeout();\n      }\n    }\n\n    this._log.info(`pc.iceGatheringState is \"${pc.iceGatheringState}\"`);\n    this.onicegatheringstatechange(state);\n  };\n\n  pc.oniceconnectionstatechange = () => {\n    this._log.info(`pc.iceConnectionState is \"${pc.iceConnectionState}\"`);\n    this.oniceconnectionstatechange(pc.iceConnectionState);\n    this._onMediaConnectionStateChange(pc.iceConnectionState);\n  };\n};\nPeerConnection.prototype._initializeMediaStream = function(rtcConstraints, rtcConfiguration) {\n  // if mediastream already open then do nothing\n  if (this.status === 'open') {\n    return false;\n  }\n  if (this.pstream.status === 'disconnected') {\n    this.onerror({ info: {\n      code: 31000,\n      message: 'Cannot establish connection. Client is disconnected',\n      twilioError: new SignalingErrors.ConnectionDisconnected(),\n    } });\n    this.close();\n    return false;\n  }\n  this.version = this._setupPeerConnection(rtcConstraints, rtcConfiguration);\n  this._setupChannel();\n  return true;\n};\n\n/**\n * Remove reconnection-related listeners\n * @private\n */\nPeerConnection.prototype._removeReconnectionListeners = function() {\n  if (this.pstream) {\n    this.pstream.removeListener('answer', this._onAnswerOrRinging);\n    this.pstream.removeListener('hangup', this._onHangup);\n  }\n};\n\n/**\n * Setup a listener for RTCDtlsTransport to capture state changes events\n * @private\n */\nPeerConnection.prototype._setupRTCDtlsTransportListener = function() {\n  const dtlsTransport = this.getRTCDtlsTransport();\n\n  if (!dtlsTransport || dtlsTransport.onstatechange) {\n    return;\n  }\n\n  const handler = () => {\n    this._log.info(`dtlsTransportState is \"${dtlsTransport.state}\"`);\n    this.ondtlstransportstatechange(dtlsTransport.state);\n  };\n\n  // Publish initial state\n  handler();\n  dtlsTransport.onstatechange = handler;\n};\n\n/**\n * Setup a listener for RTCIceTransport to capture selected candidate pair changes\n * @private\n */\nPeerConnection.prototype._setupRTCIceTransportListener = function() {\n  const iceTransport = this._getRTCIceTransport();\n\n  if (!iceTransport || iceTransport.onselectedcandidatepairchange) {\n    return;\n  }\n\n  iceTransport.onselectedcandidatepairchange = () =>\n    this.onselectedcandidatepairchange(iceTransport.getSelectedCandidatePair());\n};\n\n/**\n * Restarts ICE for the current connection\n * ICE Restart failures are ignored. Retries are managed in Connection\n * @private\n */\nPeerConnection.prototype.iceRestart = function() {\n  this._log.info('Attempting to restart ICE...');\n  this._hasIceCandidates = false;\n  this.version.createOffer(this.options.maxAverageBitrate, this.codecPreferences, { iceRestart: true }).then(() => {\n    this._removeReconnectionListeners();\n\n    this._onAnswerOrRinging = payload => {\n      this._removeReconnectionListeners();\n\n      if (!payload.sdp || this.version.pc.signalingState !== 'have-local-offer') {\n        const message = 'Invalid state or param during ICE Restart:'\n          + `hasSdp:${!!payload.sdp}, signalingState:${this.version.pc.signalingState}`;\n        this._log.info(message);\n        return;\n      }\n\n      const sdp = this._maybeSetIceAggressiveNomination(payload.sdp);\n      this._answerSdp = sdp;\n      if (this.status !== 'closed') {\n        this.version.processAnswer(this.codecPreferences, sdp, null, err => {\n          const message = err && err.message ? err.message : err;\n          this._log.info(`Failed to process answer during ICE Restart. Error: ${message}`);\n        });\n      }\n    };\n\n    this._onHangup = () => {\n      this._log.info('Received hangup during ICE Restart');\n      this._removeReconnectionListeners();\n    };\n\n    this.pstream.on('answer', this._onAnswerOrRinging);\n    this.pstream.on('hangup', this._onHangup);\n    this.pstream.reinvite(this.version.getSDP(), this.callSid);\n\n  }).catch((err) => {\n    const message = err && err.message ? err.message : err;\n    this._log.info(`Failed to createOffer during ICE Restart. Error: ${message}`);\n    // CreateOffer failures doesn't transition ice state to failed\n    // We need trigger it so it can be picked up by retries\n    this.onfailed(message);\n  });\n};\n\nPeerConnection.prototype.makeOutgoingCall = function(token, params, callsid, rtcConstraints, rtcConfiguration, onMediaStarted) {\n  if (!this._initializeMediaStream(rtcConstraints, rtcConfiguration)) {\n    return;\n  }\n\n  const self = this;\n  this.callSid = callsid;\n  function onAnswerSuccess() {\n    if (self.options) {\n      self._setEncodingParameters(self.options.dscp);\n    }\n    onMediaStarted(self.version.pc);\n  }\n  function onAnswerError(err) {\n    const errMsg = err.message || err;\n    self.onerror({ info: {\n      code: 31000,\n      message: `Error processing answer: ${errMsg}`,\n      twilioError: new MediaErrors.ClientRemoteDescFailed(),\n    } });\n  }\n  this._onAnswerOrRinging = payload => {\n    if (!payload.sdp) { return; }\n\n    const sdp = this._maybeSetIceAggressiveNomination(payload.sdp);\n    self._answerSdp = sdp;\n    if (self.status !== 'closed') {\n      self.version.processAnswer(this.codecPreferences, sdp, onAnswerSuccess, onAnswerError);\n    }\n    self.pstream.removeListener('answer', self._onAnswerOrRinging);\n    self.pstream.removeListener('ringing', self._onAnswerOrRinging);\n  };\n  this.pstream.on('answer', this._onAnswerOrRinging);\n  this.pstream.on('ringing', this._onAnswerOrRinging);\n\n  function onOfferSuccess() {\n    if (self.status !== 'closed') {\n      self.pstream.invite(self.version.getSDP(), self.callSid, self.options.preflight, params);\n      self._setupRTCDtlsTransportListener();\n    }\n  }\n\n  function onOfferError(err) {\n    const errMsg = err.message || err;\n    self.onerror({ info: {\n      code: 31000,\n      message: `Error creating the offer: ${errMsg}`,\n      twilioError: new MediaErrors.ClientLocalDescFailed(),\n    } });\n  }\n\n  this.version.createOffer(this.options.maxAverageBitrate, this.codecPreferences, { audio: true }, onOfferSuccess, onOfferError);\n};\nPeerConnection.prototype.answerIncomingCall = function(callSid, sdp, rtcConstraints, rtcConfiguration, onMediaStarted) {\n  if (!this._initializeMediaStream(rtcConstraints, rtcConfiguration)) {\n    return;\n  }\n  sdp = this._maybeSetIceAggressiveNomination(sdp);\n  this._answerSdp = sdp.replace(/^a=setup:actpass$/gm, 'a=setup:passive');\n  this.callSid = callSid;\n  const self = this;\n  function onAnswerSuccess() {\n    if (self.status !== 'closed') {\n      self.pstream.answer(self.version.getSDP(), callSid);\n      if (self.options) {\n        self._setEncodingParameters(self.options.dscp);\n      }\n      onMediaStarted(self.version.pc);\n      self._setupRTCDtlsTransportListener();\n    }\n  }\n  function onAnswerError(err) {\n    const errMsg = err.message || err;\n    self.onerror({ info: {\n      code: 31000,\n      message: `Error creating the answer: ${errMsg}`,\n      twilioError: new MediaErrors.ClientRemoteDescFailed(),\n    } });\n  }\n  this.version.processSDP(this.options.maxAverageBitrate, this.codecPreferences, sdp, { audio: true }, onAnswerSuccess, onAnswerError);\n};\nPeerConnection.prototype.close = function() {\n  if (this.version && this.version.pc) {\n    if (this.version.pc.signalingState !== 'closed') {\n      this.version.pc.close();\n    }\n\n    this.version.pc = null;\n  }\n  if (this.stream) {\n    this.mute(false);\n    this._stopStream(this.stream);\n  }\n  this.stream = null;\n  this._removeReconnectionListeners();\n  this._stopIceGatheringTimeout();\n\n  Promise.all(this._removeAudioOutputs()).catch(() => {\n    // We don't need to alert about failures here.\n  });\n  if (this._mediaStreamSource) {\n    this._mediaStreamSource.disconnect();\n  }\n  if (this._inputAnalyser) {\n    this._inputAnalyser.disconnect();\n  }\n  if (this._outputAnalyser) {\n    this._outputAnalyser.disconnect();\n  }\n  if (this._inputAnalyser2) {\n    this._inputAnalyser2.disconnect();\n  }\n  if (this._outputAnalyser2) {\n    this._outputAnalyser2.disconnect();\n  }\n  this.status = 'closed';\n  this.onclose();\n};\nPeerConnection.prototype.reject = function(callSid) {\n  this.callSid = callSid;\n};\nPeerConnection.prototype.ignore = function(callSid) {\n  this.callSid = callSid;\n};\n/**\n * Mute or unmute input audio. If the stream is not yet present, the setting\n *   is saved and applied to future streams/tracks.\n * @params {boolean} shouldMute - Whether the input audio should\n *   be muted or unmuted.\n */\nPeerConnection.prototype.mute = function(shouldMute) {\n  this.isMuted = shouldMute;\n  if (!this.stream) { return; }\n\n  if (this._sender && this._sender.track) {\n    this._sender.track.enabled = !shouldMute;\n  } else {\n    const audioTracks = typeof this.stream.getAudioTracks === 'function'\n      ? this.stream.getAudioTracks()\n      : this.stream.audioTracks;\n\n    audioTracks.forEach(track => {\n      track.enabled = !shouldMute;\n    });\n  }\n};\n/**\n * Get or create an RTCDTMFSender for the first local audio MediaStreamTrack\n * we can get from the RTCPeerConnection. Return null if unsupported.\n * @instance\n * @returns ?RTCDTMFSender\n */\nPeerConnection.prototype.getOrCreateDTMFSender = function getOrCreateDTMFSender() {\n  if (this._dtmfSender || this._dtmfSenderUnsupported) {\n    return this._dtmfSender || null;\n  }\n\n  const self = this;\n  const pc = this.version.pc;\n  if (!pc) {\n    this._log.info('No RTCPeerConnection available to call createDTMFSender on');\n    return null;\n  }\n\n  if (typeof pc.getSenders === 'function' && (typeof RTCDTMFSender === 'function' || typeof RTCDtmfSender === 'function')) {\n    const chosenSender = pc.getSenders().find(sender => sender.dtmf);\n    if (chosenSender) {\n      this._log.info('Using RTCRtpSender#dtmf');\n      this._dtmfSender = chosenSender.dtmf;\n      return this._dtmfSender;\n    }\n  }\n\n  if (typeof pc.createDTMFSender === 'function' && typeof pc.getLocalStreams === 'function') {\n    const track = pc.getLocalStreams().map(stream => {\n      const tracks = self._getAudioTracks(stream);\n      return tracks && tracks[0];\n    })[0];\n\n    if (!track) {\n      this._log.info('No local audio MediaStreamTrack available on the RTCPeerConnection to pass to createDTMFSender');\n      return null;\n    }\n\n    this._log.info('Creating RTCDTMFSender');\n    this._dtmfSender = pc.createDTMFSender(track);\n    return this._dtmfSender;\n  }\n\n  this._log.info('RTCPeerConnection does not support RTCDTMFSender');\n  this._dtmfSenderUnsupported = true;\n  return null;\n};\n\n/**\n * Get the RTCDtlTransport object from the PeerConnection\n * @returns RTCDtlTransport\n */\nPeerConnection.prototype.getRTCDtlsTransport = function getRTCDtlsTransport() {\n  const sender = this.version && this.version.pc\n    && typeof this.version.pc.getSenders === 'function'\n    && this.version.pc.getSenders()[0];\n  return sender && sender.transport || null;\n};\n\nPeerConnection.prototype._canStopMediaStreamTrack = () => typeof MediaStreamTrack.prototype.stop === 'function';\n\nPeerConnection.prototype._getAudioTracks = stream => typeof stream.getAudioTracks === 'function' ?\n  stream.getAudioTracks() : stream.audioTracks;\n\n/**\n * Get the RTCIceTransport object from the PeerConnection\n * @returns RTCIceTransport\n */\nPeerConnection.prototype._getRTCIceTransport = function _getRTCIceTransport() {\n  const dtlsTransport = this.getRTCDtlsTransport();\n  return dtlsTransport && dtlsTransport.iceTransport || null;\n};\n\n// Is PeerConnection.protocol used outside of our SDK? We should remove this if not.\nPeerConnection.protocol = ((() => RTCPC.test() ? new RTCPC() : null))();\n\nfunction addStream(pc, stream) {\n  if (typeof pc.addTrack === 'function') {\n    stream.getAudioTracks().forEach(track => {\n      // The second parameters, stream, should not be necessary per the latest editor's\n      //   draft, but FF requires it. https://bugzilla.mozilla.org/show_bug.cgi?id=1231414\n      pc.addTrack(track, stream);\n    });\n  } else {\n    pc.addStream(stream);\n  }\n}\n\nfunction cloneStream(oldStream) {\n  const newStream = typeof MediaStream !== 'undefined'\n    ? new MediaStream()\n    : new webkitMediaStream();\n\n  oldStream.getAudioTracks().forEach(newStream.addTrack, newStream);\n  return newStream;\n}\n\nfunction removeStream(pc, stream) {\n  if (typeof pc.removeTrack === 'function') {\n    pc.getSenders().forEach(sender => { pc.removeTrack(sender); });\n  } else {\n    pc.removeStream(stream);\n  }\n}\n\n/**\n * Set the source of an HTMLAudioElement to the specified MediaStream\n * @param {HTMLAudioElement} audio\n * @param {MediaStream} stream\n * @returns {boolean} Whether the audio source was set successfully\n */\nfunction setAudioSource(audio, stream) {\n  if (typeof audio.srcObject !== 'undefined') {\n    audio.srcObject = stream;\n  } else if (typeof audio.mozSrcObject !== 'undefined') {\n    audio.mozSrcObject = stream;\n  } else if (typeof audio.src !== 'undefined') {\n    const _window = audio.options.window || window;\n    audio.src = (_window.URL || _window.webkitURL).createObjectURL(stream);\n  } else {\n    return false;\n  }\n\n  return true;\n}\n\nPeerConnection.enabled = RTCPC.test();\n\nexport default PeerConnection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}