{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\nvar util = require('../util');\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\nvar defaultOpusId = 111;\nvar BITRATE_MAX = 510000;\nvar BITRATE_MIN = 6000;\nfunction getPreferredCodecInfo(sdp) {\n  var _ref = /a=rtpmap:(\\d+) (\\S+)/m.exec(sdp) || [null, '', ''],\n    _ref2 = _slicedToArray(_ref, 3),\n    codecId = _ref2[1],\n    codecName = _ref2[2];\n  var regex = new RegExp('a=fmtp:' + codecId + ' (\\\\S+)', 'm');\n  var _ref3 = regex.exec(sdp) || [null, ''],\n    _ref4 = _slicedToArray(_ref3, 2),\n    codecParams = _ref4[1];\n  return {\n    codecName: codecName,\n    codecParams: codecParams\n  };\n}\nfunction setIceAggressiveNomination(sdp) {\n  // This only works on Chrome. We don't want any side effects on other browsers\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1024096\n  // https://issues.corp.twilio.com/browse/CLIENT-6911\n  if (!util.isChrome(window, window.navigator)) {\n    return sdp;\n  }\n  return sdp.split('\\n').filter(function (line) {\n    return line.indexOf('a=ice-lite') === -1;\n  }).join('\\n');\n}\nfunction setMaxAverageBitrate(sdp, maxAverageBitrate) {\n  if (typeof maxAverageBitrate !== 'number' || maxAverageBitrate < BITRATE_MIN || maxAverageBitrate > BITRATE_MAX) {\n    return sdp;\n  }\n  var matches = /a=rtpmap:(\\d+) opus/m.exec(sdp);\n  var opusId = matches && matches.length ? matches[1] : defaultOpusId;\n  var regex = new RegExp('a=fmtp:' + opusId);\n  var lines = sdp.split('\\n').map(function (line) {\n    return regex.test(line) ? line + (';maxaveragebitrate=' + maxAverageBitrate) : line;\n  });\n  return lines.join('\\n');\n}\n\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @returns {string} Updated SDP string\n */\nfunction setCodecPreferences(sdp, preferredCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\n\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return 'm=' + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp('m=' + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp('a=' + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<Codec>} preferredCodecs - Preferred Codec Names\n * @returns {Array<PT>} Reordered Payload Types\n */\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (codecName) {\n    return codecName.toLowerCase();\n  });\n  var preferredPayloadTypes = util.flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n  var remainingCodecs = util.difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = util.flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp('a=rtpmap:' + pt + ' ([^/]+)');\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0];\n\n  // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the PayloadTypes.\n  var matches = mLine.match(/([0-9]+)/g);\n\n  // This should not happen, but in case there are no PayloadTypes in\n  // the m= line, return an empty array.\n  if (!matches) {\n    return [];\n  }\n\n  // Since only the PayloadTypes are needed, we discard the <port>.\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}\nmodule.exports = {\n  getPreferredCodecInfo: getPreferredCodecInfo,\n  setCodecPreferences: setCodecPreferences,\n  setIceAggressiveNomination: setIceAggressiveNomination,\n  setMaxAverageBitrate: setMaxAverageBitrate\n};","map":{"version":3,"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","util","require","ptToFixedBitrateAudioCodecName","defaultOpusId","BITRATE_MAX","BITRATE_MIN","getPreferredCodecInfo","sdp","_ref","exec","_ref2","codecId","codecName","regex","RegExp","_ref3","_ref4","codecParams","setIceAggressiveNomination","isChrome","window","navigator","split","filter","line","indexOf","join","setMaxAverageBitrate","maxAverageBitrate","matches","opusId","lines","map","test","setCodecPreferences","preferredCodecs","mediaSections","getMediaSections","session","concat","section","kind","match","codecMap","createCodecMapForMediaSection","payloadTypes","getReorderedPayloadTypes","newSection","setPayloadTypesInMediaSection","pcmaPayloadTypes","get","pcmuPayloadTypes","fixedBitratePayloadTypes","Set","has","replace","direction","slice","mediaSection","kindPattern","directionPattern","from","createPtToCodecName","reduce","pair","pt","pts","set","Map","toLowerCase","preferredPayloadTypes","flatMap","remainingCodecs","difference","keys","remainingPayloadTypes","mLine","otherLines","getPayloadTypesInMediaSection","ptToCodecName","rtpmapPattern","parseInt","module","exports"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/twilio-client/es5/twilio/rtc/sdp.js"],"sourcesContent":["'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar util = require('../util');\n\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\n\nvar defaultOpusId = 111;\nvar BITRATE_MAX = 510000;\nvar BITRATE_MIN = 6000;\n\nfunction getPreferredCodecInfo(sdp) {\n  var _ref = /a=rtpmap:(\\d+) (\\S+)/m.exec(sdp) || [null, '', ''],\n      _ref2 = _slicedToArray(_ref, 3),\n      codecId = _ref2[1],\n      codecName = _ref2[2];\n\n  var regex = new RegExp('a=fmtp:' + codecId + ' (\\\\S+)', 'm');\n\n  var _ref3 = regex.exec(sdp) || [null, ''],\n      _ref4 = _slicedToArray(_ref3, 2),\n      codecParams = _ref4[1];\n\n  return { codecName: codecName, codecParams: codecParams };\n}\n\nfunction setIceAggressiveNomination(sdp) {\n  // This only works on Chrome. We don't want any side effects on other browsers\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1024096\n  // https://issues.corp.twilio.com/browse/CLIENT-6911\n  if (!util.isChrome(window, window.navigator)) {\n    return sdp;\n  }\n\n  return sdp.split('\\n').filter(function (line) {\n    return line.indexOf('a=ice-lite') === -1;\n  }).join('\\n');\n}\n\nfunction setMaxAverageBitrate(sdp, maxAverageBitrate) {\n  if (typeof maxAverageBitrate !== 'number' || maxAverageBitrate < BITRATE_MIN || maxAverageBitrate > BITRATE_MAX) {\n    return sdp;\n  }\n\n  var matches = /a=rtpmap:(\\d+) opus/m.exec(sdp);\n  var opusId = matches && matches.length ? matches[1] : defaultOpusId;\n  var regex = new RegExp('a=fmtp:' + opusId);\n  var lines = sdp.split('\\n').map(function (line) {\n    return regex.test(line) ? line + (';maxaveragebitrate=' + maxAverageBitrate) : line;\n  });\n\n  return lines.join('\\n');\n}\n\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @returns {string} Updated SDP string\n */\nfunction setCodecPreferences(sdp, preferredCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\n\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return 'm=' + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp('m=' + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp('a=' + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<Codec>} preferredCodecs - Preferred Codec Names\n * @returns {Array<PT>} Reordered Payload Types\n */\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (codecName) {\n    return codecName.toLowerCase();\n  });\n\n  var preferredPayloadTypes = util.flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n\n  var remainingCodecs = util.difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = util.flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp('a=rtpmap:' + pt + ' ([^/]+)');\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0];\n\n  // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the PayloadTypes.\n  var matches = mLine.match(/([0-9]+)/g);\n\n  // This should not happen, but in case there are no PayloadTypes in\n  // the m= line, return an empty array.\n  if (!matches) {\n    return [];\n  }\n\n  // Since only the PayloadTypes are needed, we discard the <port>.\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}\n\nmodule.exports = {\n  getPreferredCodecInfo: getPreferredCodecInfo,\n  setCodecPreferences: setCodecPreferences,\n  setIceAggressiveNomination: setIceAggressiveNomination,\n  setMaxAverageBitrate: setMaxAverageBitrate\n};"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,cAAc,GAAG,YAAY;EAAE,SAASC,aAAaA,CAACC,GAAG,EAAEC,CAAC,EAAE;IAAE,IAAIC,IAAI,GAAG,EAAE;IAAE,IAAIC,EAAE,GAAG,IAAI;IAAE,IAAIC,EAAE,GAAG,KAAK;IAAE,IAAIC,EAAE,GAAGC,SAAS;IAAE,IAAI;MAAE,KAAK,IAAIC,EAAE,GAAGP,GAAG,CAACQ,MAAM,CAACC,QAAQ,CAAC,CAAC,CAAC,EAAEC,EAAE,EAAE,EAAEP,EAAE,GAAG,CAACO,EAAE,GAAGH,EAAE,CAACI,IAAI,CAAC,CAAC,EAAEC,IAAI,CAAC,EAAET,EAAE,GAAG,IAAI,EAAE;QAAED,IAAI,CAACW,IAAI,CAACH,EAAE,CAACI,KAAK,CAAC;QAAE,IAAIb,CAAC,IAAIC,IAAI,CAACa,MAAM,KAAKd,CAAC,EAAE;MAAO;IAAE,CAAC,CAAC,OAAOe,GAAG,EAAE;MAAEZ,EAAE,GAAG,IAAI;MAAEC,EAAE,GAAGW,GAAG;IAAE,CAAC,SAAS;MAAE,IAAI;QAAE,IAAI,CAACb,EAAE,IAAII,EAAE,CAAC,QAAQ,CAAC,EAAEA,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;MAAE,CAAC,SAAS;QAAE,IAAIH,EAAE,EAAE,MAAMC,EAAE;MAAE;IAAE;IAAE,OAAOH,IAAI;EAAE;EAAE,OAAO,UAAUF,GAAG,EAAEC,CAAC,EAAE;IAAE,IAAIgB,KAAK,CAACC,OAAO,CAAClB,GAAG,CAAC,EAAE;MAAE,OAAOA,GAAG;IAAE,CAAC,MAAM,IAAIQ,MAAM,CAACC,QAAQ,IAAIU,MAAM,CAACnB,GAAG,CAAC,EAAE;MAAE,OAAOD,aAAa,CAACC,GAAG,EAAEC,CAAC,CAAC;IAAE,CAAC,MAAM;MAAE,MAAM,IAAImB,SAAS,CAAC,sDAAsD,CAAC;IAAE;EAAE,CAAC;AAAE,CAAC,CAAC,CAAC;AAEvpB,IAAIC,IAAI,GAAGC,OAAO,CAAC,SAAS,CAAC;AAE7B,IAAIC,8BAA8B,GAAG;EACnC,CAAC,EAAE,MAAM;EACT,CAAC,EAAE;AACL,CAAC;AAED,IAAIC,aAAa,GAAG,GAAG;AACvB,IAAIC,WAAW,GAAG,MAAM;AACxB,IAAIC,WAAW,GAAG,IAAI;AAEtB,SAASC,qBAAqBA,CAACC,GAAG,EAAE;EAClC,IAAIC,IAAI,GAAG,uBAAuB,CAACC,IAAI,CAACF,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,EAAE,CAAC;IAC1DG,KAAK,GAAGjC,cAAc,CAAC+B,IAAI,EAAE,CAAC,CAAC;IAC/BG,OAAO,GAAGD,KAAK,CAAC,CAAC,CAAC;IAClBE,SAAS,GAAGF,KAAK,CAAC,CAAC,CAAC;EAExB,IAAIG,KAAK,GAAG,IAAIC,MAAM,CAAC,SAAS,GAAGH,OAAO,GAAG,SAAS,EAAE,GAAG,CAAC;EAE5D,IAAII,KAAK,GAAGF,KAAK,CAACJ,IAAI,CAACF,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC;IACrCS,KAAK,GAAGvC,cAAc,CAACsC,KAAK,EAAE,CAAC,CAAC;IAChCE,WAAW,GAAGD,KAAK,CAAC,CAAC,CAAC;EAE1B,OAAO;IAAEJ,SAAS,EAAEA,SAAS;IAAEK,WAAW,EAAEA;EAAY,CAAC;AAC3D;AAEA,SAASC,0BAA0BA,CAACX,GAAG,EAAE;EACvC;EACA;EACA;EACA,IAAI,CAACP,IAAI,CAACmB,QAAQ,CAACC,MAAM,EAAEA,MAAM,CAACC,SAAS,CAAC,EAAE;IAC5C,OAAOd,GAAG;EACZ;EAEA,OAAOA,GAAG,CAACe,KAAK,CAAC,IAAI,CAAC,CAACC,MAAM,CAAC,UAAUC,IAAI,EAAE;IAC5C,OAAOA,IAAI,CAACC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;EAC1C,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;AACf;AAEA,SAASC,oBAAoBA,CAACpB,GAAG,EAAEqB,iBAAiB,EAAE;EACpD,IAAI,OAAOA,iBAAiB,KAAK,QAAQ,IAAIA,iBAAiB,GAAGvB,WAAW,IAAIuB,iBAAiB,GAAGxB,WAAW,EAAE;IAC/G,OAAOG,GAAG;EACZ;EAEA,IAAIsB,OAAO,GAAG,sBAAsB,CAACpB,IAAI,CAACF,GAAG,CAAC;EAC9C,IAAIuB,MAAM,GAAGD,OAAO,IAAIA,OAAO,CAACnC,MAAM,GAAGmC,OAAO,CAAC,CAAC,CAAC,GAAG1B,aAAa;EACnE,IAAIU,KAAK,GAAG,IAAIC,MAAM,CAAC,SAAS,GAAGgB,MAAM,CAAC;EAC1C,IAAIC,KAAK,GAAGxB,GAAG,CAACe,KAAK,CAAC,IAAI,CAAC,CAACU,GAAG,CAAC,UAAUR,IAAI,EAAE;IAC9C,OAAOX,KAAK,CAACoB,IAAI,CAACT,IAAI,CAAC,GAAGA,IAAI,IAAI,qBAAqB,GAAGI,iBAAiB,CAAC,GAAGJ,IAAI;EACrF,CAAC,CAAC;EAEF,OAAOO,KAAK,CAACL,IAAI,CAAC,IAAI,CAAC;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASQ,mBAAmBA,CAAC3B,GAAG,EAAE4B,eAAe,EAAE;EACjD,IAAIC,aAAa,GAAGC,gBAAgB,CAAC9B,GAAG,CAAC;EACzC,IAAI+B,OAAO,GAAG/B,GAAG,CAACe,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;EACpC,OAAO,CAACgB,OAAO,CAAC,CAACC,MAAM,CAACH,aAAa,CAACJ,GAAG,CAAC,UAAUQ,OAAO,EAAE;IAC3D;IACA,IAAI,CAAC,kBAAkB,CAACP,IAAI,CAACO,OAAO,CAAC,EAAE;MACrC,OAAOA,OAAO;IAChB;IACA,IAAIC,IAAI,GAAGD,OAAO,CAACE,KAAK,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC;IAC/C,IAAIC,QAAQ,GAAGC,6BAA6B,CAACJ,OAAO,CAAC;IACrD,IAAIK,YAAY,GAAGC,wBAAwB,CAACH,QAAQ,EAAER,eAAe,CAAC;IACtE,IAAIY,UAAU,GAAGC,6BAA6B,CAACH,YAAY,EAAEL,OAAO,CAAC;IAErE,IAAIS,gBAAgB,GAAGN,QAAQ,CAACO,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE;IACjD,IAAIC,gBAAgB,GAAGR,QAAQ,CAACO,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE;IACjD,IAAIE,wBAAwB,GAAGX,IAAI,KAAK,OAAO,GAAG,IAAIY,GAAG,CAACJ,gBAAgB,CAACV,MAAM,CAACY,gBAAgB,CAAC,CAAC,GAAG,IAAIE,GAAG,CAAC,CAAC;IAEhH,OAAOD,wBAAwB,CAACE,GAAG,CAACT,YAAY,CAAC,CAAC,CAAC,CAAC,GAAGE,UAAU,CAACQ,OAAO,CAAC,2BAA2B,EAAE,EAAE,CAAC,GAAGR,UAAU;EACzH,CAAC,CAAC,CAAC,CAACrB,IAAI,CAAC,MAAM,CAAC;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASW,gBAAgBA,CAAC9B,GAAG,EAAEkC,IAAI,EAAEe,SAAS,EAAE;EAC9C,OAAOjD,GAAG,CAACgD,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC,CAACjC,KAAK,CAAC,QAAQ,CAAC,CAACmC,KAAK,CAAC,CAAC,CAAC,CAACzB,GAAG,CAAC,UAAU0B,YAAY,EAAE;IAC3F,OAAO,IAAI,GAAGA,YAAY;EAC5B,CAAC,CAAC,CAACnC,MAAM,CAAC,UAAUmC,YAAY,EAAE;IAChC,IAAIC,WAAW,GAAG,IAAI7C,MAAM,CAAC,IAAI,IAAI2B,IAAI,IAAI,IAAI,CAAC,EAAE,IAAI,CAAC;IACzD,IAAImB,gBAAgB,GAAG,IAAI9C,MAAM,CAAC,IAAI,IAAI0C,SAAS,IAAI,IAAI,CAAC,EAAE,IAAI,CAAC;IACnE,OAAOG,WAAW,CAAC1B,IAAI,CAACyB,YAAY,CAAC,IAAIE,gBAAgB,CAAC3B,IAAI,CAACyB,YAAY,CAAC;EAC9E,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASd,6BAA6BA,CAACJ,OAAO,EAAE;EAC9C,OAAO5C,KAAK,CAACiE,IAAI,CAACC,mBAAmB,CAACtB,OAAO,CAAC,CAAC,CAACuB,MAAM,CAAC,UAAUpB,QAAQ,EAAEqB,IAAI,EAAE;IAC/E,IAAIC,EAAE,GAAGD,IAAI,CAAC,CAAC,CAAC;IAChB,IAAIpD,SAAS,GAAGoD,IAAI,CAAC,CAAC,CAAC;IACvB,IAAIE,GAAG,GAAGvB,QAAQ,CAACO,GAAG,CAACtC,SAAS,CAAC,IAAI,EAAE;IACvC,OAAO+B,QAAQ,CAACwB,GAAG,CAACvD,SAAS,EAAEsD,GAAG,CAAC3B,MAAM,CAAC0B,EAAE,CAAC,CAAC;EAChD,CAAC,EAAE,IAAIG,GAAG,CAAC,CAAC,CAAC;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAStB,wBAAwBA,CAACH,QAAQ,EAAER,eAAe,EAAE;EAC3DA,eAAe,GAAGA,eAAe,CAACH,GAAG,CAAC,UAAUpB,SAAS,EAAE;IACzD,OAAOA,SAAS,CAACyD,WAAW,CAAC,CAAC;EAChC,CAAC,CAAC;EAEF,IAAIC,qBAAqB,GAAGtE,IAAI,CAACuE,OAAO,CAACpC,eAAe,EAAE,UAAUvB,SAAS,EAAE;IAC7E,OAAO+B,QAAQ,CAACO,GAAG,CAACtC,SAAS,CAAC,IAAI,EAAE;EACtC,CAAC,CAAC;EAEF,IAAI4D,eAAe,GAAGxE,IAAI,CAACyE,UAAU,CAAC7E,KAAK,CAACiE,IAAI,CAAClB,QAAQ,CAAC+B,IAAI,CAAC,CAAC,CAAC,EAAEvC,eAAe,CAAC;EACnF,IAAIwC,qBAAqB,GAAG3E,IAAI,CAACuE,OAAO,CAACC,eAAe,EAAE,UAAU5D,SAAS,EAAE;IAC7E,OAAO+B,QAAQ,CAACO,GAAG,CAACtC,SAAS,CAAC;EAChC,CAAC,CAAC;EAEF,OAAO0D,qBAAqB,CAAC/B,MAAM,CAACoC,qBAAqB,CAAC;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS3B,6BAA6BA,CAACH,YAAY,EAAEL,OAAO,EAAE;EAC5D,IAAIT,KAAK,GAAGS,OAAO,CAAClB,KAAK,CAAC,MAAM,CAAC;EACjC,IAAIsD,KAAK,GAAG7C,KAAK,CAAC,CAAC,CAAC;EACpB,IAAI8C,UAAU,GAAG9C,KAAK,CAAC0B,KAAK,CAAC,CAAC,CAAC;EAC/BmB,KAAK,GAAGA,KAAK,CAACrB,OAAO,CAAC,eAAe,EAAEV,YAAY,CAACnB,IAAI,CAAC,GAAG,CAAC,CAAC;EAC9D,OAAO,CAACkD,KAAK,CAAC,CAACrC,MAAM,CAACsC,UAAU,CAAC,CAACnD,IAAI,CAAC,MAAM,CAAC;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASoC,mBAAmBA,CAACJ,YAAY,EAAE;EACzC,OAAOoB,6BAA6B,CAACpB,YAAY,CAAC,CAACK,MAAM,CAAC,UAAUgB,aAAa,EAAEd,EAAE,EAAE;IACrF,IAAIe,aAAa,GAAG,IAAIlE,MAAM,CAAC,WAAW,GAAGmD,EAAE,GAAG,UAAU,CAAC;IAC7D,IAAIpC,OAAO,GAAG6B,YAAY,CAAChB,KAAK,CAACsC,aAAa,CAAC;IAC/C,IAAIpE,SAAS,GAAGiB,OAAO,GAAGA,OAAO,CAAC,CAAC,CAAC,CAACwC,WAAW,CAAC,CAAC,GAAGnE,8BAA8B,CAAC+D,EAAE,CAAC,GAAG/D,8BAA8B,CAAC+D,EAAE,CAAC,CAACI,WAAW,CAAC,CAAC,GAAG,EAAE;IAC/I,OAAOU,aAAa,CAACZ,GAAG,CAACF,EAAE,EAAErD,SAAS,CAAC;EACzC,CAAC,EAAE,IAAIwD,GAAG,CAAC,CAAC,CAAC;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASU,6BAA6BA,CAACtC,OAAO,EAAE;EAC9C,IAAIoC,KAAK,GAAGpC,OAAO,CAAClB,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;;EAEpC;EACA;EACA,IAAIO,OAAO,GAAG+C,KAAK,CAAClC,KAAK,CAAC,WAAW,CAAC;;EAEtC;EACA;EACA,IAAI,CAACb,OAAO,EAAE;IACZ,OAAO,EAAE;EACX;;EAEA;EACA,OAAOA,OAAO,CAAC4B,KAAK,CAAC,CAAC,CAAC,CAACzB,GAAG,CAAC,UAAUU,KAAK,EAAE;IAC3C,OAAOuC,QAAQ,CAACvC,KAAK,EAAE,EAAE,CAAC;EAC5B,CAAC,CAAC;AACJ;AAEAwC,MAAM,CAACC,OAAO,GAAG;EACf7E,qBAAqB,EAAEA,qBAAqB;EAC5C4B,mBAAmB,EAAEA,mBAAmB;EACxChB,0BAA0B,EAAEA,0BAA0B;EACtDS,oBAAoB,EAAEA;AACxB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}