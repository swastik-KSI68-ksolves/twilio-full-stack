{"ast":null,"code":"\"use strict\";\n\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n  return r;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar events_1 = require(\"events\");\nvar errors_1 = require(\"./errors\");\nvar mos_1 = require(\"./rtc/mos\");\nvar stats_1 = require(\"./rtc/stats\");\nvar util_1 = require(\"./util\");\n// How many samples we use when testing metric thresholds\nvar SAMPLE_COUNT_METRICS = 5;\n// How many samples that need to cross the threshold to\n// raise or clear a warning.\nvar SAMPLE_COUNT_CLEAR = 0;\nvar SAMPLE_COUNT_RAISE = 3;\nvar SAMPLE_INTERVAL = 1000;\nvar WARNING_TIMEOUT = 5 * 1000;\nvar DEFAULT_THRESHOLDS = {\n  audioInputLevel: {\n    minStandardDeviation: 327.67,\n    sampleCount: 10\n  },\n  audioOutputLevel: {\n    minStandardDeviation: 327.67,\n    sampleCount: 10\n  },\n  bytesReceived: {\n    clearCount: 2,\n    min: 1,\n    raiseCount: 3,\n    sampleCount: 3\n  },\n  bytesSent: {\n    clearCount: 2,\n    min: 1,\n    raiseCount: 3,\n    sampleCount: 3\n  },\n  jitter: {\n    max: 30\n  },\n  mos: {\n    min: 3\n  },\n  packetsLostFraction: [{\n    max: 1\n  }, {\n    clearValue: 1,\n    maxAverage: 3,\n    sampleCount: 7\n  }],\n  rtt: {\n    max: 400\n  }\n};\n/**\n * Count the number of values that cross the max threshold.\n * @private\n * @param max - The max allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\nfunction countHigh(max, values) {\n  return values.reduce(function (highCount, value) {\n    return highCount += value > max ? 1 : 0;\n  }, 0);\n}\n/**\n * Count the number of values that cross the min threshold.\n * @private\n * @param min - The minimum allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\nfunction countLow(min, values) {\n  return values.reduce(function (lowCount, value) {\n    return lowCount += value < min ? 1 : 0;\n  }, 0);\n}\n/**\n * Calculate the standard deviation from a list of numbers.\n * @private\n * @param values The list of numbers to calculate the standard deviation from.\n * @returns The standard deviation of a list of numbers.\n */\nfunction calculateStandardDeviation(values) {\n  if (values.length <= 0) {\n    return null;\n  }\n  var valueAverage = values.reduce(function (partialSum, value) {\n    return partialSum + value;\n  }, 0) / values.length;\n  var diffSquared = values.map(function (value) {\n    return Math.pow(value - valueAverage, 2);\n  });\n  var stdDev = Math.sqrt(diffSquared.reduce(function (partialSum, value) {\n    return partialSum + value;\n  }, 0) / diffSquared.length);\n  return stdDev;\n}\n/**\n * Flatten a set of numerical sample sets into a single array of samples.\n * @param sampleSets\n */\nfunction flattenSamples(sampleSets) {\n  return sampleSets.reduce(function (flat, current) {\n    return __spreadArrays(flat, current);\n  }, []);\n}\n/**\n * {@link StatsMonitor} polls a peerConnection via PeerConnection.getStats\n * and emits warnings when stats cross the specified threshold values.\n */\nvar StatsMonitor = /** @class */function (_super) {\n  __extends(StatsMonitor, _super);\n  /**\n   * @constructor\n   * @param [options] - Optional settings\n   */\n  function StatsMonitor(options) {\n    var _this = _super.call(this) || this;\n    /**\n     * A map of warnings with their raised time\n     */\n    _this._activeWarnings = new Map();\n    /**\n     * A map of stats with the number of exceeded thresholds\n     */\n    _this._currentStreaks = new Map();\n    /**\n     * Keeps track of input volumes in the last second\n     */\n    _this._inputVolumes = [];\n    /**\n     * Keeps track of output volumes in the last second\n     */\n    _this._outputVolumes = [];\n    /**\n     * Sample buffer. Saves most recent samples\n     */\n    _this._sampleBuffer = [];\n    /**\n     * Keeps track of supplemental sample values.\n     *\n     * Currently used for constant audio detection. Contains an array of volume\n     * samples for each sample interval.\n     */\n    _this._supplementalSampleBuffers = {\n      audioInputLevel: [],\n      audioOutputLevel: []\n    };\n    /**\n     * Whether warnings should be enabled\n     */\n    _this._warningsEnabled = true;\n    options = options || {};\n    _this._getRTCStats = options.getRTCStats || stats_1.getRTCStats;\n    _this._mos = options.Mos || mos_1.default;\n    _this._peerConnection = options.peerConnection;\n    _this._thresholds = __assign(__assign({}, DEFAULT_THRESHOLDS), options.thresholds);\n    var thresholdSampleCounts = Object.values(_this._thresholds).map(function (threshold) {\n      return threshold.sampleCount;\n    }).filter(function (sampleCount) {\n      return !!sampleCount;\n    });\n    _this._maxSampleCount = Math.max.apply(Math, __spreadArrays([SAMPLE_COUNT_METRICS], thresholdSampleCounts));\n    if (_this._peerConnection) {\n      _this.enable(_this._peerConnection);\n    }\n    return _this;\n  }\n  /**\n   * Called when a volume sample is available\n   * @param inputVolume - Input volume level from 0 to 32767\n   * @param outputVolume - Output volume level from 0 to 32767\n   */\n  StatsMonitor.prototype.addVolumes = function (inputVolume, outputVolume) {\n    this._inputVolumes.push(inputVolume);\n    this._outputVolumes.push(outputVolume);\n  };\n  /**\n   * Stop sampling RTC statistics for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n  StatsMonitor.prototype.disable = function () {\n    if (this._sampleInterval) {\n      clearInterval(this._sampleInterval);\n      delete this._sampleInterval;\n    }\n    return this;\n  };\n  /**\n   * Disable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n  StatsMonitor.prototype.disableWarnings = function () {\n    if (this._warningsEnabled) {\n      this._activeWarnings.clear();\n    }\n    this._warningsEnabled = false;\n    return this;\n  };\n  /**\n   * Start sampling RTC statistics for this {@link StatsMonitor}.\n   * @param peerConnection - A PeerConnection to monitor.\n   * @returns The current {@link StatsMonitor}.\n   */\n  StatsMonitor.prototype.enable = function (peerConnection) {\n    if (peerConnection) {\n      if (this._peerConnection && peerConnection !== this._peerConnection) {\n        throw new errors_1.InvalidArgumentError('Attempted to replace an existing PeerConnection in StatsMonitor.enable');\n      }\n      this._peerConnection = peerConnection;\n    }\n    if (!this._peerConnection) {\n      throw new errors_1.InvalidArgumentError('Can not enable StatsMonitor without a PeerConnection');\n    }\n    this._sampleInterval = this._sampleInterval || setInterval(this._fetchSample.bind(this), SAMPLE_INTERVAL);\n    return this;\n  };\n  /**\n   * Enable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n  StatsMonitor.prototype.enableWarnings = function () {\n    this._warningsEnabled = true;\n    return this;\n  };\n  /**\n   * Check if there is an active warning for a specific stat and threshold\n   * @param statName - The name of the stat to check\n   * @param thresholdName - The name of the threshold to check\n   * @returns Whether there is an active warning for a specific stat and threshold\n   */\n  StatsMonitor.prototype.hasActiveWarning = function (statName, thresholdName) {\n    var warningId = statName + \":\" + thresholdName;\n    return !!this._activeWarnings.get(warningId);\n  };\n  /**\n   * Add a sample to our sample buffer and remove the oldest if we are over the limit.\n   * @param sample - Sample to add\n   */\n  StatsMonitor.prototype._addSample = function (sample) {\n    var samples = this._sampleBuffer;\n    samples.push(sample);\n    // We store 1 extra sample so that we always have (current, previous)\n    // available for all {sampleBufferSize} threshold validations.\n    if (samples.length > this._maxSampleCount) {\n      samples.splice(0, samples.length - this._maxSampleCount);\n    }\n  };\n  /**\n   * Clear an active warning.\n   * @param statName - The name of the stat to clear.\n   * @param thresholdName - The name of the threshold to clear\n   * @param [data] - Any relevant sample data.\n   */\n  StatsMonitor.prototype._clearWarning = function (statName, thresholdName, data) {\n    var warningId = statName + \":\" + thresholdName;\n    var activeWarning = this._activeWarnings.get(warningId);\n    if (!activeWarning || Date.now() - activeWarning.timeRaised < WARNING_TIMEOUT) {\n      return;\n    }\n    this._activeWarnings.delete(warningId);\n    this.emit('warning-cleared', __assign(__assign({}, data), {\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: this._thresholds[statName][thresholdName]\n      }\n    }));\n  };\n  /**\n   * Create a sample object from a stats object using the previous sample, if available.\n   * @param stats - Stats retrieved from getStatistics\n   * @param [previousSample=null] - The previous sample to use to calculate deltas.\n   * @returns A universally-formatted version of RTC stats.\n   */\n  StatsMonitor.prototype._createSample = function (stats, previousSample) {\n    var previousBytesSent = previousSample && previousSample.totals.bytesSent || 0;\n    var previousBytesReceived = previousSample && previousSample.totals.bytesReceived || 0;\n    var previousPacketsSent = previousSample && previousSample.totals.packetsSent || 0;\n    var previousPacketsReceived = previousSample && previousSample.totals.packetsReceived || 0;\n    var previousPacketsLost = previousSample && previousSample.totals.packetsLost || 0;\n    var currentBytesSent = stats.bytesSent - previousBytesSent;\n    var currentBytesReceived = stats.bytesReceived - previousBytesReceived;\n    var currentPacketsSent = stats.packetsSent - previousPacketsSent;\n    var currentPacketsReceived = stats.packetsReceived - previousPacketsReceived;\n    var currentPacketsLost = stats.packetsLost - previousPacketsLost;\n    var currentInboundPackets = currentPacketsReceived + currentPacketsLost;\n    var currentPacketsLostFraction = currentInboundPackets > 0 ? currentPacketsLost / currentInboundPackets * 100 : 0;\n    var totalInboundPackets = stats.packetsReceived + stats.packetsLost;\n    var totalPacketsLostFraction = totalInboundPackets > 0 ? stats.packetsLost / totalInboundPackets * 100 : 100;\n    var rttValue = typeof stats.rtt === 'number' || !previousSample ? stats.rtt : previousSample.rtt;\n    var audioInputLevelValues = this._inputVolumes.splice(0);\n    this._supplementalSampleBuffers.audioInputLevel.push(audioInputLevelValues);\n    var audioOutputLevelValues = this._outputVolumes.splice(0);\n    this._supplementalSampleBuffers.audioOutputLevel.push(audioOutputLevelValues);\n    return {\n      audioInputLevel: Math.round(util_1.average(audioInputLevelValues)),\n      audioOutputLevel: Math.round(util_1.average(audioOutputLevelValues)),\n      bytesReceived: currentBytesReceived,\n      bytesSent: currentBytesSent,\n      codecName: stats.codecName,\n      jitter: stats.jitter,\n      mos: this._mos.calculate(rttValue, stats.jitter, previousSample && currentPacketsLostFraction),\n      packetsLost: currentPacketsLost,\n      packetsLostFraction: currentPacketsLostFraction,\n      packetsReceived: currentPacketsReceived,\n      packetsSent: currentPacketsSent,\n      rtt: rttValue,\n      timestamp: stats.timestamp,\n      totals: {\n        bytesReceived: stats.bytesReceived,\n        bytesSent: stats.bytesSent,\n        packetsLost: stats.packetsLost,\n        packetsLostFraction: totalPacketsLostFraction,\n        packetsReceived: stats.packetsReceived,\n        packetsSent: stats.packetsSent\n      }\n    };\n  };\n  /**\n   * Get stats from the PeerConnection and add it to our list of samples.\n   */\n  StatsMonitor.prototype._fetchSample = function () {\n    var _this = this;\n    this._getSample().then(function (sample) {\n      _this._addSample(sample);\n      _this._raiseWarnings();\n      _this.emit('sample', sample);\n    }).catch(function (error) {\n      _this.disable();\n      // We only bubble up any errors coming from pc.getStats()\n      // No need to attach a twilioError\n      _this.emit('error', error);\n    });\n  };\n  /**\n   * Get stats from the PeerConnection.\n   * @returns A universally-formatted version of RTC stats.\n   */\n  StatsMonitor.prototype._getSample = function () {\n    var _this = this;\n    return this._getRTCStats(this._peerConnection).then(function (stats) {\n      var previousSample = null;\n      if (_this._sampleBuffer.length) {\n        previousSample = _this._sampleBuffer[_this._sampleBuffer.length - 1];\n      }\n      return _this._createSample(stats, previousSample);\n    });\n  };\n  /**\n   * Raise a warning and log its raised time.\n   * @param statName - The name of the stat to raise.\n   * @param thresholdName - The name of the threshold to raise\n   * @param [data] - Any relevant sample data.\n   */\n  StatsMonitor.prototype._raiseWarning = function (statName, thresholdName, data) {\n    var warningId = statName + \":\" + thresholdName;\n    if (this._activeWarnings.has(warningId)) {\n      return;\n    }\n    this._activeWarnings.set(warningId, {\n      timeRaised: Date.now()\n    });\n    var thresholds = this._thresholds[statName];\n    var thresholdValue;\n    if (Array.isArray(thresholds)) {\n      var foundThreshold = thresholds.find(function (threshold) {\n        return thresholdName in threshold;\n      });\n      if (foundThreshold) {\n        thresholdValue = foundThreshold[thresholdName];\n      }\n    } else {\n      thresholdValue = this._thresholds[statName][thresholdName];\n    }\n    this.emit('warning', __assign(__assign({}, data), {\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: thresholdValue\n      }\n    }));\n  };\n  /**\n   * Apply our thresholds to our array of RTCStat samples.\n   */\n  StatsMonitor.prototype._raiseWarnings = function () {\n    var _this = this;\n    if (!this._warningsEnabled) {\n      return;\n    }\n    Object.keys(this._thresholds).forEach(function (name) {\n      return _this._raiseWarningsForStat(name);\n    });\n  };\n  /**\n   * Apply thresholds for a given stat name to our array of\n   * RTCStat samples and raise or clear any associated warnings.\n   * @param statName - Name of the stat to compare.\n   */\n  StatsMonitor.prototype._raiseWarningsForStat = function (statName) {\n    var _this = this;\n    var limits = Array.isArray(this._thresholds[statName]) ? this._thresholds[statName] : [this._thresholds[statName]];\n    limits.forEach(function (limit) {\n      var samples = _this._sampleBuffer;\n      var clearCount = limit.clearCount || SAMPLE_COUNT_CLEAR;\n      var raiseCount = limit.raiseCount || SAMPLE_COUNT_RAISE;\n      var sampleCount = limit.sampleCount || _this._maxSampleCount;\n      var relevantSamples = samples.slice(-sampleCount);\n      var values = relevantSamples.map(function (sample) {\n        return sample[statName];\n      });\n      // (rrowland) If we have a bad or missing value in the set, we don't\n      // have enough information to throw or clear a warning. Bail out.\n      var containsNull = values.some(function (value) {\n        return typeof value === 'undefined' || value === null;\n      });\n      if (containsNull) {\n        return;\n      }\n      var count;\n      if (typeof limit.max === 'number') {\n        count = countHigh(limit.max, values);\n        if (count >= raiseCount) {\n          _this._raiseWarning(statName, 'max', {\n            values: values,\n            samples: relevantSamples\n          });\n        } else if (count <= clearCount) {\n          _this._clearWarning(statName, 'max', {\n            values: values,\n            samples: relevantSamples\n          });\n        }\n      }\n      if (typeof limit.min === 'number') {\n        count = countLow(limit.min, values);\n        if (count >= raiseCount) {\n          _this._raiseWarning(statName, 'min', {\n            values: values,\n            samples: relevantSamples\n          });\n        } else if (count <= clearCount) {\n          _this._clearWarning(statName, 'min', {\n            values: values,\n            samples: relevantSamples\n          });\n        }\n      }\n      if (typeof limit.maxDuration === 'number' && samples.length > 1) {\n        relevantSamples = samples.slice(-2);\n        var prevValue = relevantSamples[0][statName];\n        var curValue = relevantSamples[1][statName];\n        var prevStreak = _this._currentStreaks.get(statName) || 0;\n        var streak = prevValue === curValue ? prevStreak + 1 : 0;\n        _this._currentStreaks.set(statName, streak);\n        if (streak >= limit.maxDuration) {\n          _this._raiseWarning(statName, 'maxDuration', {\n            value: streak\n          });\n        } else if (streak === 0) {\n          _this._clearWarning(statName, 'maxDuration', {\n            value: prevStreak\n          });\n        }\n      }\n      if (typeof limit.minStandardDeviation === 'number') {\n        var sampleSets = _this._supplementalSampleBuffers[statName];\n        if (!sampleSets || sampleSets.length < limit.sampleCount) {\n          return;\n        }\n        if (sampleSets.length > limit.sampleCount) {\n          sampleSets.splice(0, sampleSets.length - limit.sampleCount);\n        }\n        var flatSamples = flattenSamples(sampleSets.slice(-sampleCount));\n        var stdDev = calculateStandardDeviation(flatSamples);\n        if (typeof stdDev !== 'number') {\n          return;\n        }\n        if (stdDev < limit.minStandardDeviation) {\n          _this._raiseWarning(statName, 'minStandardDeviation', {\n            value: stdDev\n          });\n        } else {\n          _this._clearWarning(statName, 'minStandardDeviation', {\n            value: stdDev\n          });\n        }\n      }\n      [['maxAverage', function (x, y) {\n        return x > y;\n      }], ['minAverage', function (x, y) {\n        return x < y;\n      }]].forEach(function (_a) {\n        var thresholdName = _a[0],\n          comparator = _a[1];\n        if (typeof limit[thresholdName] === 'number' && values.length >= sampleCount) {\n          var avg = util_1.average(values);\n          if (comparator(avg, limit[thresholdName])) {\n            _this._raiseWarning(statName, thresholdName, {\n              values: values,\n              samples: relevantSamples\n            });\n          } else if (!comparator(avg, limit.clearValue || limit[thresholdName])) {\n            _this._clearWarning(statName, thresholdName, {\n              values: values,\n              samples: relevantSamples\n            });\n          }\n        }\n      });\n    });\n  };\n  return StatsMonitor;\n}(events_1.EventEmitter);\nexports.default = StatsMonitor;","map":{"version":3,"names":["events_1","require","errors_1","mos_1","stats_1","util_1","SAMPLE_COUNT_METRICS","SAMPLE_COUNT_CLEAR","SAMPLE_COUNT_RAISE","SAMPLE_INTERVAL","WARNING_TIMEOUT","DEFAULT_THRESHOLDS","audioInputLevel","minStandardDeviation","sampleCount","audioOutputLevel","bytesReceived","clearCount","min","raiseCount","bytesSent","jitter","max","mos","packetsLostFraction","clearValue","maxAverage","rtt","countHigh","values","reduce","highCount","value","countLow","lowCount","calculateStandardDeviation","length","valueAverage","partialSum","diffSquared","map","Math","pow","stdDev","sqrt","flattenSamples","sampleSets","flat","current","__spreadArrays","StatsMonitor","_super","__extends","options","_this","call","_activeWarnings","Map","_currentStreaks","_inputVolumes","_outputVolumes","_sampleBuffer","_supplementalSampleBuffers","_warningsEnabled","_getRTCStats","getRTCStats","_mos","Mos","default","_peerConnection","peerConnection","_thresholds","__assign","thresholds","thresholdSampleCounts","Object","threshold","filter","_maxSampleCount","apply","enable","prototype","addVolumes","inputVolume","outputVolume","push","disable","_sampleInterval","clearInterval","disableWarnings","clear","InvalidArgumentError","setInterval","_fetchSample","bind","enableWarnings","hasActiveWarning","statName","thresholdName","warningId","get","_addSample","sample","samples","splice","_clearWarning","data","activeWarning","Date","now","timeRaised","delete","emit","name","_createSample","stats","previousSample","previousBytesSent","totals","previousBytesReceived","previousPacketsSent","packetsSent","previousPacketsReceived","packetsReceived","previousPacketsLost","packetsLost","currentBytesSent","currentBytesReceived","currentPacketsSent","currentPacketsReceived","currentPacketsLost","currentInboundPackets","currentPacketsLostFraction","totalInboundPackets","totalPacketsLostFraction","rttValue","audioInputLevelValues","audioOutputLevelValues","round","average","codecName","calculate","timestamp","_getSample","then","_raiseWarnings","catch","error","_raiseWarning","has","set","thresholdValue","Array","isArray","foundThreshold","find","keys","forEach","_raiseWarningsForStat","limits","limit","relevantSamples","slice","containsNull","some","count","maxDuration","prevValue","curValue","prevStreak","streak","flatSamples","x","y","_a","comparator","avg","EventEmitter","exports"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/@twilio/voice-sdk/lib/twilio/statsMonitor.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n\nimport { EventEmitter } from 'events';\nimport { InvalidArgumentError } from './errors';\nimport Mos from './rtc/mos';\nimport RTCSample from './rtc/sample';\nimport { getRTCStats } from './rtc/stats';\nimport RTCWarning from './rtc/warning';\nimport { average } from './util';\n\n// How many samples we use when testing metric thresholds\nconst SAMPLE_COUNT_METRICS = 5;\n\n// How many samples that need to cross the threshold to\n// raise or clear a warning.\nconst SAMPLE_COUNT_CLEAR = 0;\nconst SAMPLE_COUNT_RAISE = 3;\n\nconst SAMPLE_INTERVAL = 1000;\nconst WARNING_TIMEOUT = 5 * 1000;\n\nconst DEFAULT_THRESHOLDS: StatsMonitor.ThresholdOptions = {\n  audioInputLevel: { minStandardDeviation: 327.67, sampleCount: 10 },\n  audioOutputLevel: { minStandardDeviation: 327.67, sampleCount: 10 },\n  bytesReceived: { clearCount: 2, min: 1, raiseCount: 3, sampleCount: 3 },\n  bytesSent: { clearCount: 2, min: 1, raiseCount: 3, sampleCount: 3 },\n  jitter: { max: 30 },\n  mos: { min: 3 },\n  packetsLostFraction: [{\n    max: 1,\n  }, {\n    clearValue: 1,\n    maxAverage: 3,\n    sampleCount: 7,\n  }],\n  rtt: { max: 400 },\n};\n\n// Placeholders until we convert the respective files to TypeScript.\n/**\n * @private\n */\nexport type IPeerConnection = any;\n\n/**\n * @private\n */\nexport type IRTCStats = any;\n\n/**\n * @private\n */\nexport type IMos = typeof Mos;\n\n/**\n * Count the number of values that cross the max threshold.\n * @private\n * @param max - The max allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\nfunction countHigh(max: number, values: number[]): number {\n  return values.reduce((highCount, value) => highCount += (value > max) ? 1 : 0, 0);\n}\n\n/**\n * Count the number of values that cross the min threshold.\n * @private\n * @param min - The minimum allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\nfunction countLow(min: number, values: number[]): number {\n  return values.reduce((lowCount, value) => lowCount += (value < min) ? 1 : 0, 0);\n}\n\n/**\n * Calculate the standard deviation from a list of numbers.\n * @private\n * @param values The list of numbers to calculate the standard deviation from.\n * @returns The standard deviation of a list of numbers.\n */\nfunction calculateStandardDeviation(values: number[]): number | null {\n  if (values.length <= 0) {\n    return null;\n  }\n\n  const valueAverage: number = values.reduce(\n    (partialSum: number, value: number) => partialSum + value,\n    0,\n  ) / values.length;\n\n  const diffSquared: number[] = values.map(\n    (value: number) => Math.pow(value - valueAverage, 2),\n  );\n\n  const stdDev: number = Math.sqrt(diffSquared.reduce(\n    (partialSum: number, value: number) => partialSum + value,\n    0,\n  ) / diffSquared.length);\n\n  return stdDev;\n}\n\n/**\n * Flatten a set of numerical sample sets into a single array of samples.\n * @param sampleSets\n */\nfunction flattenSamples(sampleSets: number[][]): number[] {\n  return sampleSets.reduce(\n    (flat: number[], current: number[]) => [...flat, ...current],\n    [],\n  );\n}\n\n/**\n * {@link StatsMonitor} polls a peerConnection via PeerConnection.getStats\n * and emits warnings when stats cross the specified threshold values.\n */\nclass StatsMonitor extends EventEmitter {\n  /**\n   * A map of warnings with their raised time\n   */\n  private _activeWarnings: Map<string, StatsMonitor.WarningTimestamp> = new Map();\n\n  /**\n   * A map of stats with the number of exceeded thresholds\n   */\n  private _currentStreaks: Map<string, number> = new Map();\n\n  /**\n   * Method to get stats from a PeerConnection object. Overrides getRTCStats library\n   */\n  private _getRTCStats: (peerConnection: IPeerConnection, options?: any) => IRTCStats;\n\n  /**\n   * Keeps track of input volumes in the last second\n   */\n  private _inputVolumes: number[] = [];\n\n  /**\n   * How many samples we use when testing metric thresholds.\n   */\n  private _maxSampleCount: number;\n\n  /**\n   * For calculating Mos. Overrides Mos library\n   */\n  private _mos: IMos;\n\n  /**\n   * Keeps track of output volumes in the last second\n   */\n  private _outputVolumes: number[] = [];\n\n  /**\n   * The PeerConnection to monitor.\n   */\n  private _peerConnection: IPeerConnection;\n\n  /**\n   * Sample buffer. Saves most recent samples\n   */\n  private _sampleBuffer: RTCSample[] = [];\n\n  /**\n   * The setInterval id for fetching samples.\n   */\n  private _sampleInterval?: NodeJS.Timer;\n\n  /**\n   * Keeps track of supplemental sample values.\n   *\n   * Currently used for constant audio detection. Contains an array of volume\n   * samples for each sample interval.\n   */\n  private _supplementalSampleBuffers: Record<string, number[][]> = {\n    audioInputLevel: [],\n    audioOutputLevel: [],\n  };\n\n  /**\n   * Threshold values for {@link StatsMonitor}\n   */\n  private _thresholds: StatsMonitor.ThresholdOptions;\n\n  /**\n   * Whether warnings should be enabled\n   */\n  private _warningsEnabled: boolean = true;\n\n  /**\n   * @constructor\n   * @param [options] - Optional settings\n   */\n  constructor(options?: StatsMonitor.Options) {\n    super();\n\n    options = options || {};\n    this._getRTCStats = options.getRTCStats || getRTCStats;\n    this._mos = options.Mos || Mos;\n    this._peerConnection = options.peerConnection;\n    this._thresholds = {...DEFAULT_THRESHOLDS, ...options.thresholds};\n\n    const thresholdSampleCounts = Object.values(this._thresholds)\n      .map((threshold: StatsMonitor.ThresholdOptions) => threshold.sampleCount)\n      .filter((sampleCount: number | undefined) => !!sampleCount);\n\n    this._maxSampleCount = Math.max(SAMPLE_COUNT_METRICS, ...thresholdSampleCounts);\n\n    if (this._peerConnection) {\n      this.enable(this._peerConnection);\n    }\n  }\n\n  /**\n   * Called when a volume sample is available\n   * @param inputVolume - Input volume level from 0 to 32767\n   * @param outputVolume - Output volume level from 0 to 32767\n   */\n  addVolumes(inputVolume: number, outputVolume: number): void {\n    this._inputVolumes.push(inputVolume);\n    this._outputVolumes.push(outputVolume);\n  }\n\n  /**\n   * Stop sampling RTC statistics for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n  disable(): this {\n    if (this._sampleInterval) {\n      clearInterval(this._sampleInterval);\n      delete this._sampleInterval;\n    }\n    return this;\n  }\n\n  /**\n   * Disable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n  disableWarnings(): this {\n    if (this._warningsEnabled) {\n      this._activeWarnings.clear();\n    }\n\n    this._warningsEnabled = false;\n    return this;\n  }\n\n  /**\n   * Start sampling RTC statistics for this {@link StatsMonitor}.\n   * @param peerConnection - A PeerConnection to monitor.\n   * @returns The current {@link StatsMonitor}.\n   */\n  enable(peerConnection: IPeerConnection): this {\n    if (peerConnection) {\n      if (this._peerConnection && peerConnection !== this._peerConnection) {\n        throw new InvalidArgumentError('Attempted to replace an existing PeerConnection in StatsMonitor.enable');\n      }\n      this._peerConnection = peerConnection;\n    }\n\n    if (!this._peerConnection) {\n      throw new InvalidArgumentError('Can not enable StatsMonitor without a PeerConnection');\n    }\n\n    this._sampleInterval = this._sampleInterval ||\n      setInterval(this._fetchSample.bind(this), SAMPLE_INTERVAL);\n\n    return this;\n  }\n\n  /**\n   * Enable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n  enableWarnings(): this {\n    this._warningsEnabled = true;\n    return this;\n  }\n\n  /**\n   * Check if there is an active warning for a specific stat and threshold\n   * @param statName - The name of the stat to check\n   * @param thresholdName - The name of the threshold to check\n   * @returns Whether there is an active warning for a specific stat and threshold\n   */\n  hasActiveWarning(statName: string, thresholdName: string): boolean {\n    const warningId = `${statName}:${thresholdName}`;\n    return !!this._activeWarnings.get(warningId);\n  }\n\n  /**\n   * Add a sample to our sample buffer and remove the oldest if we are over the limit.\n   * @param sample - Sample to add\n   */\n  private _addSample(sample: RTCSample): void {\n    const samples = this._sampleBuffer;\n    samples.push(sample);\n\n    // We store 1 extra sample so that we always have (current, previous)\n    // available for all {sampleBufferSize} threshold validations.\n    if (samples.length > this._maxSampleCount) {\n      samples.splice(0, samples.length - this._maxSampleCount);\n    }\n  }\n\n  /**\n   * Clear an active warning.\n   * @param statName - The name of the stat to clear.\n   * @param thresholdName - The name of the threshold to clear\n   * @param [data] - Any relevant sample data.\n   */\n  private _clearWarning(statName: string, thresholdName: string, data?: RTCWarning): void {\n    const warningId = `${statName}:${thresholdName}`;\n    const activeWarning = this._activeWarnings.get(warningId);\n\n    if (!activeWarning || Date.now() - activeWarning.timeRaised < WARNING_TIMEOUT) { return; }\n    this._activeWarnings.delete(warningId);\n\n    this.emit('warning-cleared', {\n      ...data,\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: this._thresholds[statName][thresholdName],\n      },\n    });\n  }\n\n  /**\n   * Create a sample object from a stats object using the previous sample, if available.\n   * @param stats - Stats retrieved from getStatistics\n   * @param [previousSample=null] - The previous sample to use to calculate deltas.\n   * @returns A universally-formatted version of RTC stats.\n   */\n  private _createSample(stats: IRTCStats, previousSample: RTCSample | null): RTCSample {\n    const previousBytesSent = previousSample && previousSample.totals.bytesSent || 0;\n    const previousBytesReceived = previousSample && previousSample.totals.bytesReceived || 0;\n    const previousPacketsSent = previousSample && previousSample.totals.packetsSent || 0;\n    const previousPacketsReceived = previousSample && previousSample.totals.packetsReceived || 0;\n    const previousPacketsLost = previousSample && previousSample.totals.packetsLost || 0;\n\n    const currentBytesSent = stats.bytesSent - previousBytesSent;\n    const currentBytesReceived = stats.bytesReceived - previousBytesReceived;\n    const currentPacketsSent = stats.packetsSent - previousPacketsSent;\n    const currentPacketsReceived = stats.packetsReceived - previousPacketsReceived;\n    const currentPacketsLost = stats.packetsLost - previousPacketsLost;\n    const currentInboundPackets = currentPacketsReceived + currentPacketsLost;\n    const currentPacketsLostFraction = (currentInboundPackets > 0) ?\n      (currentPacketsLost / currentInboundPackets) * 100 : 0;\n\n    const totalInboundPackets = stats.packetsReceived + stats.packetsLost;\n    const totalPacketsLostFraction = (totalInboundPackets > 0) ?\n      (stats.packetsLost / totalInboundPackets) * 100 : 100;\n\n    const rttValue = (typeof stats.rtt === 'number' || !previousSample) ? stats.rtt : previousSample.rtt;\n\n    const audioInputLevelValues = this._inputVolumes.splice(0);\n    this._supplementalSampleBuffers.audioInputLevel.push(audioInputLevelValues);\n\n    const audioOutputLevelValues = this._outputVolumes.splice(0);\n    this._supplementalSampleBuffers.audioOutputLevel.push(audioOutputLevelValues);\n\n    return {\n      audioInputLevel: Math.round(average(audioInputLevelValues)),\n      audioOutputLevel: Math.round(average(audioOutputLevelValues)),\n      bytesReceived: currentBytesReceived,\n      bytesSent: currentBytesSent,\n      codecName: stats.codecName,\n      jitter: stats.jitter,\n      mos: this._mos.calculate(rttValue, stats.jitter, previousSample && currentPacketsLostFraction),\n      packetsLost: currentPacketsLost,\n      packetsLostFraction: currentPacketsLostFraction,\n      packetsReceived: currentPacketsReceived,\n      packetsSent: currentPacketsSent,\n      rtt: rttValue,\n      timestamp: stats.timestamp,\n      totals: {\n        bytesReceived: stats.bytesReceived,\n        bytesSent: stats.bytesSent,\n        packetsLost: stats.packetsLost,\n        packetsLostFraction: totalPacketsLostFraction,\n        packetsReceived: stats.packetsReceived,\n        packetsSent: stats.packetsSent,\n      },\n    };\n  }\n\n  /**\n   * Get stats from the PeerConnection and add it to our list of samples.\n   */\n  private _fetchSample(): void {\n    this._getSample().then(sample => {\n      this._addSample(sample);\n      this._raiseWarnings();\n      this.emit('sample', sample);\n    }).catch(error => {\n      this.disable();\n      // We only bubble up any errors coming from pc.getStats()\n      // No need to attach a twilioError\n      this.emit('error', error);\n    });\n  }\n\n  /**\n   * Get stats from the PeerConnection.\n   * @returns A universally-formatted version of RTC stats.\n   */\n  private _getSample(): Promise<RTCSample> {\n    return this._getRTCStats(this._peerConnection).then((stats: IRTCStats) => {\n      let previousSample = null;\n      if (this._sampleBuffer.length) {\n        previousSample = this._sampleBuffer[this._sampleBuffer.length - 1];\n      }\n\n      return this._createSample(stats, previousSample);\n    });\n  }\n\n  /**\n   * Raise a warning and log its raised time.\n   * @param statName - The name of the stat to raise.\n   * @param thresholdName - The name of the threshold to raise\n   * @param [data] - Any relevant sample data.\n   */\n  private _raiseWarning(statName: string, thresholdName: string, data?: RTCWarning): void {\n    const warningId = `${statName}:${thresholdName}`;\n\n    if (this._activeWarnings.has(warningId)) { return; }\n    this._activeWarnings.set(warningId, { timeRaised: Date.now() });\n\n    const thresholds: StatsMonitor.ThresholdOption | StatsMonitor.ThresholdOption[] =\n      this._thresholds[statName];\n\n    let thresholdValue;\n\n    if (Array.isArray(thresholds)) {\n      const foundThreshold = thresholds.find(threshold => thresholdName in threshold);\n      if (foundThreshold) {\n        thresholdValue = foundThreshold[thresholdName as keyof StatsMonitor.ThresholdOption];\n      }\n    } else {\n      thresholdValue = this._thresholds[statName][thresholdName];\n    }\n\n    this.emit('warning', {\n      ...data,\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: thresholdValue,\n      },\n    });\n  }\n\n  /**\n   * Apply our thresholds to our array of RTCStat samples.\n   */\n  private _raiseWarnings(): void {\n    if (!this._warningsEnabled) { return; }\n\n    Object.keys(this._thresholds).forEach(name => this._raiseWarningsForStat(name));\n  }\n\n  /**\n   * Apply thresholds for a given stat name to our array of\n   * RTCStat samples and raise or clear any associated warnings.\n   * @param statName - Name of the stat to compare.\n   */\n  private _raiseWarningsForStat(statName: string): void {\n    const limits: StatsMonitor.ThresholdOptions[] =\n      Array.isArray(this._thresholds[statName])\n        ? this._thresholds[statName]\n        : [this._thresholds[statName]];\n\n    limits.forEach((limit: StatsMonitor.ThresholdOptions) => {\n      const samples = this._sampleBuffer;\n\n      const clearCount = limit.clearCount || SAMPLE_COUNT_CLEAR;\n      const raiseCount = limit.raiseCount || SAMPLE_COUNT_RAISE;\n      const sampleCount = limit.sampleCount || this._maxSampleCount;\n\n      let relevantSamples = samples.slice(-sampleCount);\n      const values = relevantSamples.map(sample => sample[statName]);\n\n      // (rrowland) If we have a bad or missing value in the set, we don't\n      // have enough information to throw or clear a warning. Bail out.\n      const containsNull = values.some(value => typeof value === 'undefined' || value === null);\n\n      if (containsNull) {\n        return;\n      }\n\n      let count;\n      if (typeof limit.max === 'number') {\n        count = countHigh(limit.max, values);\n        if (count >= raiseCount) {\n          this._raiseWarning(statName, 'max', { values, samples: relevantSamples });\n        } else if (count <= clearCount) {\n          this._clearWarning(statName, 'max', { values, samples: relevantSamples });\n        }\n      }\n\n      if (typeof limit.min === 'number') {\n        count = countLow(limit.min, values);\n        if (count >= raiseCount) {\n          this._raiseWarning(statName, 'min', { values, samples: relevantSamples });\n        } else if (count <= clearCount) {\n          this._clearWarning(statName, 'min', { values, samples: relevantSamples });\n        }\n      }\n\n      if (typeof limit.maxDuration === 'number' && samples.length > 1) {\n        relevantSamples = samples.slice(-2);\n        const prevValue = relevantSamples[0][statName];\n        const curValue = relevantSamples[1][statName];\n\n        const prevStreak = this._currentStreaks.get(statName) || 0;\n        const streak = (prevValue === curValue) ? prevStreak + 1 : 0;\n\n        this._currentStreaks.set(statName, streak);\n\n        if (streak >= limit.maxDuration) {\n          this._raiseWarning(statName, 'maxDuration', { value: streak });\n        } else if (streak === 0) {\n          this._clearWarning(statName, 'maxDuration', { value: prevStreak });\n        }\n      }\n\n      if (typeof limit.minStandardDeviation === 'number') {\n        const sampleSets: number[][] = this._supplementalSampleBuffers[statName];\n        if (!sampleSets || sampleSets.length < limit.sampleCount) {\n          return;\n        }\n        if (sampleSets.length > limit.sampleCount) {\n          sampleSets.splice(0, sampleSets.length - limit.sampleCount);\n        }\n        const flatSamples: number[] = flattenSamples(sampleSets.slice(-sampleCount));\n        const stdDev: number | null = calculateStandardDeviation(flatSamples);\n\n        if (typeof stdDev !== 'number') {\n          return;\n        }\n\n        if (stdDev < limit.minStandardDeviation) {\n          this._raiseWarning(statName, 'minStandardDeviation', { value: stdDev });\n        } else {\n          this._clearWarning(statName, 'minStandardDeviation', { value: stdDev });\n        }\n      }\n\n      ([\n        ['maxAverage', (x: number, y: number) => x > y],\n        ['minAverage', (x: number, y: number) => x < y],\n      ] as const).forEach(([thresholdName, comparator]) => {\n        if (typeof limit[thresholdName] === 'number' && values.length >= sampleCount) {\n          const avg: number = average(values);\n\n          if (comparator(avg, limit[thresholdName])) {\n            this._raiseWarning(statName, thresholdName, { values, samples: relevantSamples });\n          } else if (!comparator(avg, limit.clearValue || limit[thresholdName])) {\n            this._clearWarning(statName, thresholdName, { values, samples: relevantSamples });\n          }\n        }\n      });\n    });\n  }\n}\n\nnamespace StatsMonitor {\n  /**\n   * Config options to be passed to the {@link StatsMonitor} constructor.\n   * @private\n   */\n  export interface Options {\n    /**\n     * Method to get stats from a PeerConnection object\n     */\n    getRTCStats?: (peerConnection: IPeerConnection) => IRTCStats;\n\n    /**\n     * For calculating Mos. Overrides Mos library\n     */\n    Mos?: IMos;\n\n    /**\n     * The PeerConnection to monitor.\n     */\n    peerConnection?: IPeerConnection;\n\n    /**\n     * Optional custom threshold values.\n     */\n    thresholds?: ThresholdOptions;\n  }\n\n  /**\n   * Speficic threshold value for {@link ThresholdOptions}\n   * @private\n   */\n  export interface ThresholdOption {\n    /**\n     * How many samples that need to cross the threshold to clear a warning.\n     * Overrides SAMPLE_COUNT_CLEAR\n     */\n    clearCount?: number;\n\n    /**\n     * Used with the `minAverage` and `maxAverage` options. If `maxAverage` is\n     * used, then the warning will be cleared when at or below this value. If\n     * `minAverage` is used, then the warning will be cleared at or above this\n     * value.\n     */\n    clearValue?: number;\n\n    /**\n     * Warning will be raised if tracked metric rises above this value.\n     */\n    max?: number;\n\n    /**\n     * Warning will be raised based on the average over `sampleCount` samples.\n     * The warning is raised if the average is above the `raiseValue` amount and\n     * is cleared when below the `clearValue` amount.\n     */\n    maxAverage?: number;\n\n    /**\n     * Warning will be raised if tracked metric stays constant for\n     * the specified number of consequent samples.\n     */\n    maxDuration?: number;\n\n    /**\n     * Warning will be raised if tracked metric falls below this value.\n     */\n    min?: number;\n\n    /**\n     * Warning will be raised based on the average over `sampleCount` samples.\n     * The warning is raised if the average is below the `raiseValue` amount and\n     * is cleared when above the `clearValue` amount.\n     */\n    minAverage?: number;\n\n    /**\n     * Warning will be raised if the standard deviation of the tracked metric\n     * does not exceed this value.\n     */\n    minStandardDeviation?: number;\n\n    /**\n     * How many samples that need to cross the threshold to raise a warning.\n     * Overrides SAMPLE_COUNT_RAISE\n     */\n    raiseCount?: number;\n\n    /**\n     * How many samples we use when testing metric thresholds.\n     * Overrides _maxSampleCount\n     */\n    sampleCount?: number;\n  }\n\n  /**\n   * Threshold values for {@link StatsMonitor}\n   * @private\n   */\n  export interface ThresholdOptions {\n    [key: string]: any;\n\n    /**\n     * Audio input level between 0 and 32767, representing -100 to -30 dB.\n     */\n    audioInputLevel?: ThresholdOption;\n\n    /**\n     * Audio output level between 0 and 32767, representing -100 to -30 dB.\n     */\n    audioOutputLevel?: ThresholdOption;\n\n    /**\n     * Rules to apply to sample.jitter\n     */\n    jitter?: ThresholdOption;\n\n    /**\n     * Rules to apply to sample.mos\n     */\n    mos?: ThresholdOption;\n\n    /**\n     * Rules to apply to sample.packetsLostFraction\n     */\n    packetsLostFraction?: ThresholdOption[];\n\n    /**\n     * Rules to apply to sample.rtt\n     */\n    rtt?: ThresholdOption;\n  }\n\n  /**\n   * Timestamp for raised warnings\n   * @private\n   */\n  export interface WarningTimestamp {\n    /**\n     * Timestamp in milliseconds\n     */\n    timeRaised: number;\n  }\n}\n\nexport default StatsMonitor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}