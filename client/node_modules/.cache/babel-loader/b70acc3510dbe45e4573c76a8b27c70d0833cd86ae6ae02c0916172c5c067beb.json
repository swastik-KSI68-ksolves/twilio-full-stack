{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setMaxAverageBitrate = exports.setIceAggressiveNomination = exports.setCodecPreferences = exports.getPreferredCodecInfo = void 0;\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n// @ts-nocheck\nvar util = require(\"../util\");\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\nvar defaultOpusId = 111;\nvar BITRATE_MAX = 510000;\nvar BITRATE_MIN = 6000;\nfunction getPreferredCodecInfo(sdp) {\n  var _a = /a=rtpmap:(\\d+) (\\S+)/m.exec(sdp) || [null, '', ''],\n    codecId = _a[1],\n    codecName = _a[2];\n  var regex = new RegExp(\"a=fmtp:\" + codecId + \" (\\\\S+)\", 'm');\n  var _b = regex.exec(sdp) || [null, ''],\n    codecParams = _b[1];\n  return {\n    codecName: codecName,\n    codecParams: codecParams\n  };\n}\nexports.getPreferredCodecInfo = getPreferredCodecInfo;\nfunction setIceAggressiveNomination(sdp) {\n  // This only works on Chrome. We don't want any side effects on other browsers\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1024096\n  // https://issues.corp.twilio.com/browse/CLIENT-6911\n  if (!util.isChrome(window, window.navigator)) {\n    return sdp;\n  }\n  return sdp.split('\\n').filter(function (line) {\n    return line.indexOf('a=ice-lite') === -1;\n  }).join('\\n');\n}\nexports.setIceAggressiveNomination = setIceAggressiveNomination;\nfunction setMaxAverageBitrate(sdp, maxAverageBitrate) {\n  if (typeof maxAverageBitrate !== 'number' || maxAverageBitrate < BITRATE_MIN || maxAverageBitrate > BITRATE_MAX) {\n    return sdp;\n  }\n  var matches = /a=rtpmap:(\\d+) opus/m.exec(sdp);\n  var opusId = matches && matches.length ? matches[1] : defaultOpusId;\n  var regex = new RegExp(\"a=fmtp:\" + opusId);\n  var lines = sdp.split('\\n').map(function (line) {\n    return regex.test(line) ? line + (\";maxaveragebitrate=\" + maxAverageBitrate) : line;\n  });\n  return lines.join('\\n');\n}\nexports.setMaxAverageBitrate = setMaxAverageBitrate;\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @returns {string} Updated SDP string\n */\nfunction setCodecPreferences(sdp, preferredCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\nexports.setCodecPreferences = setCodecPreferences;\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return \"m=\" + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp(\"m=\" + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp(\"a=\" + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<Codec>} preferredCodecs - Preferred Codec Names\n * @returns {Array<PT>} Reordered Payload Types\n */\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (codecName) {\n    return codecName.toLowerCase();\n  });\n  var preferredPayloadTypes = util.flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n  var remainingCodecs = util.difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = util.flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp(\"a=rtpmap:\" + pt + \" ([^/]+)\");\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0];\n  // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the PayloadTypes.\n  var matches = mLine.match(/([0-9]+)/g);\n  // This should not happen, but in case there are no PayloadTypes in\n  // the m= line, return an empty array.\n  if (!matches) {\n    return [];\n  }\n  // Since only the PayloadTypes are needed, we discard the <port>.\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}","map":{"version":3,"names":["util","require","ptToFixedBitrateAudioCodecName","defaultOpusId","BITRATE_MAX","BITRATE_MIN","getPreferredCodecInfo","sdp","_a","exec","codecId","codecName","regex","RegExp","_b","codecParams","exports","setIceAggressiveNomination","isChrome","window","navigator","split","filter","line","indexOf","join","setMaxAverageBitrate","maxAverageBitrate","matches","opusId","length","lines","map","test","setCodecPreferences","preferredCodecs","mediaSections","getMediaSections","session","concat","section","kind","match","codecMap","createCodecMapForMediaSection","payloadTypes","getReorderedPayloadTypes","newSection","setPayloadTypesInMediaSection","pcmaPayloadTypes","get","pcmuPayloadTypes","fixedBitratePayloadTypes","Set","has","replace","direction","slice","mediaSection","kindPattern","directionPattern","Array","from","createPtToCodecName","reduce","pair","pt","pts","set","Map","toLowerCase","preferredPayloadTypes","flatMap","remainingCodecs","difference","keys","remainingPayloadTypes","mLine","otherLines","getPayloadTypesInMediaSection","ptToCodecName","rtpmapPattern","parseInt"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/@twilio/voice-sdk/lib/twilio/rtc/sdp.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n// @ts-nocheck\nimport * as util from '../util';\n\nconst ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA',\n};\n\nconst defaultOpusId = 111;\nconst BITRATE_MAX = 510000;\nconst BITRATE_MIN = 6000;\n\nfunction getPreferredCodecInfo(sdp) {\n  const [, codecId, codecName] = /a=rtpmap:(\\d+) (\\S+)/m.exec(sdp) || [null, '', ''];\n  const regex = new RegExp(`a=fmtp:${codecId} (\\\\S+)`, 'm');\n  const [, codecParams] = regex.exec(sdp) || [null, ''];\n  return { codecName, codecParams };\n}\n\nfunction setIceAggressiveNomination(sdp) {\n  // This only works on Chrome. We don't want any side effects on other browsers\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1024096\n  // https://issues.corp.twilio.com/browse/CLIENT-6911\n  if (!util.isChrome(window, window.navigator)) {\n    return sdp;\n  }\n\n  return sdp.split('\\n')\n    .filter(line => line.indexOf('a=ice-lite') === -1)\n    .join('\\n');\n}\n\nfunction setMaxAverageBitrate(sdp, maxAverageBitrate) {\n  if (typeof maxAverageBitrate !== 'number'\n      || maxAverageBitrate < BITRATE_MIN\n      || maxAverageBitrate > BITRATE_MAX) {\n    return sdp;\n  }\n\n  const matches = /a=rtpmap:(\\d+) opus/m.exec(sdp);\n  const opusId = matches && matches.length ? matches[1] : defaultOpusId;\n  const regex = new RegExp(`a=fmtp:${opusId}`);\n  const lines = sdp.split('\\n').map(line => regex.test(line)\n    ? line + `;maxaveragebitrate=${maxAverageBitrate}`\n    : line);\n\n  return lines.join('\\n');\n}\n\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @returns {string} Updated SDP string\n */\nfunction setCodecPreferences(sdp, preferredCodecs) {\n  const mediaSections = getMediaSections(sdp);\n  const session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(section => {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n    const kind = section.match(/^m=(audio|video)/)[1];\n    const codecMap = createCodecMapForMediaSection(section);\n    const payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    const newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n\n    const pcmaPayloadTypes = codecMap.get('pcma') || [];\n    const pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    const fixedBitratePayloadTypes = kind === 'audio'\n      ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes))\n      : new Set();\n\n    return fixedBitratePayloadTypes.has(payloadTypes[0])\n      ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '')\n      : newSection;\n  })).join('\\r\\n');\n}\n\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(mediaSection => `m=${mediaSection}`).filter(mediaSection => {\n    const kindPattern = new RegExp(`m=${kind || '.*'}`, 'gm');\n    const directionPattern = new RegExp(`a=${direction || '.*'}`, 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce((codecMap, pair) => {\n    const pt = pair[0];\n    const codecName = pair[1];\n    const pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<Codec>} preferredCodecs - Preferred Codec Names\n * @returns {Array<PT>} Reordered Payload Types\n */\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(codecName => codecName.toLowerCase());\n\n  const preferredPayloadTypes = util.flatMap(preferredCodecs, codecName => codecMap.get(codecName) || []);\n\n  const remainingCodecs = util.difference(Array.from(codecMap.keys()), preferredCodecs);\n  const remainingPayloadTypes = util.flatMap(remainingCodecs, codecName => codecMap.get(codecName));\n\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  const lines = section.split('\\r\\n');\n  let mLine = lines[0];\n  const otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce((ptToCodecName, pt) => {\n    const rtpmapPattern = new RegExp(`a=rtpmap:${pt} ([^/]+)`);\n    const matches = mediaSection.match(rtpmapPattern);\n    const codecName = matches\n      ? matches[1].toLowerCase()\n      : ptToFixedBitrateAudioCodecName[pt]\n        ? ptToFixedBitrateAudioCodecName[pt].toLowerCase()\n        : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\nfunction getPayloadTypesInMediaSection(section) {\n  const mLine = section.split('\\r\\n')[0];\n\n  // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the PayloadTypes.\n  const matches = mLine.match(/([0-9]+)/g);\n\n  // This should not happen, but in case there are no PayloadTypes in\n  // the m= line, return an empty array.\n  if (!matches) {\n    return [];\n  }\n\n  // Since only the PayloadTypes are needed, we discard the <port>.\n  return matches.slice(1).map(match => parseInt(match, 10));\n}\n\nexport {\n  getPreferredCodecInfo,\n  setCodecPreferences,\n  setIceAggressiveNomination,\n  setMaxAverageBitrate,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}