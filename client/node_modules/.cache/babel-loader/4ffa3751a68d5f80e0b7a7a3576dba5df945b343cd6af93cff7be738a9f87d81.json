{"ast":null,"code":"'use strict';\n\nvar AsyncQueue = require('./asyncQueue').AsyncQueue;\nvar AudioPlayer = require('@twilio/audioplayer');\nvar InvalidArgumentError = require('./errors').InvalidArgumentError;\n\n/**\n * @class\n * @param {string} name - Name of the sound\n * @param {string} url - URL of the sound\n * @param {Sound#ConstructorOptions} options\n * @property {boolean} isPlaying - Whether the Sound is currently playing audio.\n * @property {string} name - Name of the sound\n * @property {string} url - URL of the sound\n * @property {AudioContext} audioContext - The AudioContext to use if available for AudioPlayer.\n */ /**\n    * @typedef {Object} Sound#ConstructorOptions\n    * @property {number} [maxDuration=0] - The maximum length of time to play the sound\n    *   before stopping it.\n    * @property {Boolean} [shouldLoop=false] - Whether the sound should be looped.\n    */\nfunction Sound(name, url, options) {\n  if (!(this instanceof Sound)) {\n    return new Sound(name, url, options);\n  }\n  if (!name || !url) {\n    throw new InvalidArgumentError('name and url are required arguments');\n  }\n  options = Object.assign({\n    AudioFactory: typeof Audio !== 'undefined' ? Audio : null,\n    maxDuration: 0,\n    shouldLoop: false\n  }, options);\n  options.AudioPlayer = options.audioContext ? AudioPlayer.bind(AudioPlayer, options.audioContext) : options.AudioFactory;\n  Object.defineProperties(this, {\n    _activeEls: {\n      value: new Map()\n    },\n    _Audio: {\n      value: options.AudioPlayer\n    },\n    _isSinkSupported: {\n      value: options.AudioFactory !== null && typeof options.AudioFactory.prototype.setSinkId === 'function'\n    },\n    _maxDuration: {\n      value: options.maxDuration\n    },\n    _maxDurationTimeout: {\n      value: null,\n      writable: true\n    },\n    _operations: {\n      value: new AsyncQueue()\n    },\n    _playPromise: {\n      value: null,\n      writable: true\n    },\n    _shouldLoop: {\n      value: options.shouldLoop\n    },\n    _sinkIds: {\n      value: ['default']\n    },\n    isPlaying: {\n      enumerable: true,\n      get: function get() {\n        return !!this._playPromise;\n      }\n    },\n    name: {\n      enumerable: true,\n      value: name\n    },\n    url: {\n      enumerable: true,\n      value: url\n    }\n  });\n  if (this._Audio) {\n    // Play it (muted and should not loop) as soon as possible so that it does not get incorrectly caught by Chrome's\n    // \"gesture requirement for media playback\" feature.\n    // https://plus.google.com/+FrancoisBeaufort/posts/6PiJQqJzGqX\n    this._play(true, false);\n  }\n}\nfunction destroyAudioElement(audioElement) {\n  if (audioElement) {\n    audioElement.pause();\n    audioElement.src = '';\n    audioElement.srcObject = null;\n    audioElement.load();\n  }\n}\n\n/**\n * Plays the audio element that was initialized using the speficied sinkId\n */\nSound.prototype._playAudioElement = function _playAudioElement(sinkId, isMuted, shouldLoop) {\n  var _this = this;\n  var audioElement = this._activeEls.get(sinkId);\n  if (!audioElement) {\n    throw new InvalidArgumentError('sinkId: \"' + sinkId + '\" doesn\\'t have an audio element');\n  }\n  audioElement.muted = !!isMuted;\n  audioElement.loop = !!shouldLoop;\n  return audioElement.play().then(function () {\n    return audioElement;\n  }).catch(function (reason) {\n    destroyAudioElement(audioElement);\n    _this._activeEls.delete(sinkId);\n    throw reason;\n  });\n};\n\n/**\n * Start playing the sound. Will stop the currently playing sound first.\n * If it exists, the audio element that was initialized for the sinkId will be used\n */\nSound.prototype._play = function _play(forceIsMuted, forceShouldLoop) {\n  if (this.isPlaying) {\n    this._stop();\n  }\n  if (this._maxDuration > 0) {\n    this._maxDurationTimeout = setTimeout(this._stop.bind(this), this._maxDuration);\n  }\n  forceShouldLoop = typeof forceShouldLoop === 'boolean' ? forceShouldLoop : this._shouldLoop;\n  var self = this;\n  var playPromise = this._playPromise = Promise.all(this._sinkIds.map(function createAudioElement(sinkId) {\n    if (!self._Audio) {\n      return Promise.resolve();\n    }\n    var audioElement = self._activeEls.get(sinkId);\n    if (audioElement) {\n      return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n    }\n    audioElement = new self._Audio(self.url);\n\n    // Make sure the browser always retrieves the resource using CORS.\n    // By default when using media tags, origin header is not sent to server\n    // which causes the server to not return CORS headers. When this caches\n    // on the CDN or browser, it causes issues to future requests that needs CORS,\n    // which is true when using AudioContext. Please note that we won't have to do this\n    // once we migrate to CloudFront.\n    if (typeof audioElement.setAttribute === 'function') {\n      audioElement.setAttribute('crossorigin', 'anonymous');\n    }\n\n    /**\n     * (rrowland) Bug in Chrome 53 & 54 prevents us from calling Audio.setSinkId without\n     *   crashing the tab. https://bugs.chromium.org/p/chromium/issues/detail?id=655342\n     */\n    return new Promise(function (resolve) {\n      audioElement.addEventListener('canplaythrough', resolve);\n    }).then(function () {\n      return (self._isSinkSupported ? audioElement.setSinkId(sinkId) : Promise.resolve()).then(function setSinkIdSuccess() {\n        self._activeEls.set(sinkId, audioElement);\n\n        // Stop has been called, bail out\n        if (!self._playPromise) {\n          return Promise.resolve();\n        }\n        return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n      });\n    });\n  }));\n  return playPromise;\n};\n\n/**\n * Stop playing the sound.\n */\nSound.prototype._stop = function _stop() {\n  var _this2 = this;\n  this._activeEls.forEach(function (audioEl, sinkId) {\n    if (_this2._sinkIds.includes(sinkId)) {\n      audioEl.pause();\n      audioEl.currentTime = 0;\n    } else {\n      // Destroy the ones that are not used anymore\n      destroyAudioElement(audioEl);\n      _this2._activeEls.delete(sinkId);\n    }\n  });\n  clearTimeout(this._maxDurationTimeout);\n  this._playPromise = null;\n  this._maxDurationTimeout = null;\n};\n\n/**\n * Update the sinkIds of the audio output devices this sound should play through.\n */\nSound.prototype.setSinkIds = function setSinkIds(ids) {\n  if (!this._isSinkSupported) {\n    return;\n  }\n  ids = ids.forEach ? ids : [ids];\n  [].splice.apply(this._sinkIds, [0, this._sinkIds.length].concat(ids));\n};\n\n/**\n * Add a stop operation to the queue\n */\nSound.prototype.stop = function stop() {\n  var _this3 = this;\n  this._operations.enqueue(function () {\n    _this3._stop();\n    return Promise.resolve();\n  });\n};\n\n/**\n * Add a play operation to the queue\n */\nSound.prototype.play = function play() {\n  var _this4 = this;\n  return this._operations.enqueue(function () {\n    return _this4._play();\n  });\n};\nmodule.exports = Sound;","map":{"version":3,"names":["AsyncQueue","require","AudioPlayer","InvalidArgumentError","Sound","name","url","options","Object","assign","AudioFactory","Audio","maxDuration","shouldLoop","audioContext","bind","defineProperties","_activeEls","value","Map","_Audio","_isSinkSupported","prototype","setSinkId","_maxDuration","_maxDurationTimeout","writable","_operations","_playPromise","_shouldLoop","_sinkIds","isPlaying","enumerable","get","_play","destroyAudioElement","audioElement","pause","src","srcObject","load","_playAudioElement","sinkId","isMuted","_this","muted","loop","play","then","catch","reason","delete","forceIsMuted","forceShouldLoop","_stop","setTimeout","self","playPromise","Promise","all","map","createAudioElement","resolve","setAttribute","addEventListener","setSinkIdSuccess","set","_this2","forEach","audioEl","includes","currentTime","clearTimeout","setSinkIds","ids","splice","apply","length","concat","stop","_this3","enqueue","_this4","module","exports"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/twilio-client/es5/twilio/sound.js"],"sourcesContent":["'use strict';\n\nvar AsyncQueue = require('./asyncQueue').AsyncQueue;\nvar AudioPlayer = require('@twilio/audioplayer');\nvar InvalidArgumentError = require('./errors').InvalidArgumentError;\n\n/**\n * @class\n * @param {string} name - Name of the sound\n * @param {string} url - URL of the sound\n * @param {Sound#ConstructorOptions} options\n * @property {boolean} isPlaying - Whether the Sound is currently playing audio.\n * @property {string} name - Name of the sound\n * @property {string} url - URL of the sound\n * @property {AudioContext} audioContext - The AudioContext to use if available for AudioPlayer.\n */ /**\n    * @typedef {Object} Sound#ConstructorOptions\n    * @property {number} [maxDuration=0] - The maximum length of time to play the sound\n    *   before stopping it.\n    * @property {Boolean} [shouldLoop=false] - Whether the sound should be looped.\n    */\nfunction Sound(name, url, options) {\n  if (!(this instanceof Sound)) {\n    return new Sound(name, url, options);\n  }\n\n  if (!name || !url) {\n    throw new InvalidArgumentError('name and url are required arguments');\n  }\n\n  options = Object.assign({\n    AudioFactory: typeof Audio !== 'undefined' ? Audio : null,\n    maxDuration: 0,\n    shouldLoop: false\n  }, options);\n\n  options.AudioPlayer = options.audioContext ? AudioPlayer.bind(AudioPlayer, options.audioContext) : options.AudioFactory;\n\n  Object.defineProperties(this, {\n    _activeEls: {\n      value: new Map()\n    },\n    _Audio: {\n      value: options.AudioPlayer\n    },\n    _isSinkSupported: {\n      value: options.AudioFactory !== null && typeof options.AudioFactory.prototype.setSinkId === 'function'\n    },\n    _maxDuration: {\n      value: options.maxDuration\n    },\n    _maxDurationTimeout: {\n      value: null,\n      writable: true\n    },\n    _operations: {\n      value: new AsyncQueue()\n    },\n    _playPromise: {\n      value: null,\n      writable: true\n    },\n    _shouldLoop: {\n      value: options.shouldLoop\n    },\n    _sinkIds: {\n      value: ['default']\n    },\n    isPlaying: {\n      enumerable: true,\n      get: function get() {\n        return !!this._playPromise;\n      }\n    },\n    name: {\n      enumerable: true,\n      value: name\n    },\n    url: {\n      enumerable: true,\n      value: url\n    }\n  });\n\n  if (this._Audio) {\n    // Play it (muted and should not loop) as soon as possible so that it does not get incorrectly caught by Chrome's\n    // \"gesture requirement for media playback\" feature.\n    // https://plus.google.com/+FrancoisBeaufort/posts/6PiJQqJzGqX\n    this._play(true, false);\n  }\n}\n\nfunction destroyAudioElement(audioElement) {\n  if (audioElement) {\n    audioElement.pause();\n    audioElement.src = '';\n    audioElement.srcObject = null;\n    audioElement.load();\n  }\n}\n\n/**\n * Plays the audio element that was initialized using the speficied sinkId\n */\nSound.prototype._playAudioElement = function _playAudioElement(sinkId, isMuted, shouldLoop) {\n  var _this = this;\n\n  var audioElement = this._activeEls.get(sinkId);\n\n  if (!audioElement) {\n    throw new InvalidArgumentError('sinkId: \"' + sinkId + '\" doesn\\'t have an audio element');\n  }\n\n  audioElement.muted = !!isMuted;\n  audioElement.loop = !!shouldLoop;\n\n  return audioElement.play().then(function () {\n    return audioElement;\n  }).catch(function (reason) {\n    destroyAudioElement(audioElement);\n    _this._activeEls.delete(sinkId);\n    throw reason;\n  });\n};\n\n/**\n * Start playing the sound. Will stop the currently playing sound first.\n * If it exists, the audio element that was initialized for the sinkId will be used\n */\nSound.prototype._play = function _play(forceIsMuted, forceShouldLoop) {\n  if (this.isPlaying) {\n    this._stop();\n  }\n\n  if (this._maxDuration > 0) {\n    this._maxDurationTimeout = setTimeout(this._stop.bind(this), this._maxDuration);\n  }\n\n  forceShouldLoop = typeof forceShouldLoop === 'boolean' ? forceShouldLoop : this._shouldLoop;\n  var self = this;\n  var playPromise = this._playPromise = Promise.all(this._sinkIds.map(function createAudioElement(sinkId) {\n    if (!self._Audio) {\n      return Promise.resolve();\n    }\n\n    var audioElement = self._activeEls.get(sinkId);\n    if (audioElement) {\n      return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n    }\n\n    audioElement = new self._Audio(self.url);\n\n    // Make sure the browser always retrieves the resource using CORS.\n    // By default when using media tags, origin header is not sent to server\n    // which causes the server to not return CORS headers. When this caches\n    // on the CDN or browser, it causes issues to future requests that needs CORS,\n    // which is true when using AudioContext. Please note that we won't have to do this\n    // once we migrate to CloudFront.\n    if (typeof audioElement.setAttribute === 'function') {\n      audioElement.setAttribute('crossorigin', 'anonymous');\n    }\n\n    /**\n     * (rrowland) Bug in Chrome 53 & 54 prevents us from calling Audio.setSinkId without\n     *   crashing the tab. https://bugs.chromium.org/p/chromium/issues/detail?id=655342\n     */\n    return new Promise(function (resolve) {\n      audioElement.addEventListener('canplaythrough', resolve);\n    }).then(function () {\n      return (self._isSinkSupported ? audioElement.setSinkId(sinkId) : Promise.resolve()).then(function setSinkIdSuccess() {\n        self._activeEls.set(sinkId, audioElement);\n\n        // Stop has been called, bail out\n        if (!self._playPromise) {\n          return Promise.resolve();\n        }\n        return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n      });\n    });\n  }));\n\n  return playPromise;\n};\n\n/**\n * Stop playing the sound.\n */\nSound.prototype._stop = function _stop() {\n  var _this2 = this;\n\n  this._activeEls.forEach(function (audioEl, sinkId) {\n    if (_this2._sinkIds.includes(sinkId)) {\n      audioEl.pause();\n      audioEl.currentTime = 0;\n    } else {\n      // Destroy the ones that are not used anymore\n      destroyAudioElement(audioEl);\n      _this2._activeEls.delete(sinkId);\n    }\n  });\n\n  clearTimeout(this._maxDurationTimeout);\n\n  this._playPromise = null;\n  this._maxDurationTimeout = null;\n};\n\n/**\n * Update the sinkIds of the audio output devices this sound should play through.\n */\nSound.prototype.setSinkIds = function setSinkIds(ids) {\n  if (!this._isSinkSupported) {\n    return;\n  }\n\n  ids = ids.forEach ? ids : [ids];\n  [].splice.apply(this._sinkIds, [0, this._sinkIds.length].concat(ids));\n};\n\n/**\n * Add a stop operation to the queue\n */\nSound.prototype.stop = function stop() {\n  var _this3 = this;\n\n  this._operations.enqueue(function () {\n    _this3._stop();\n    return Promise.resolve();\n  });\n};\n\n/**\n * Add a play operation to the queue\n */\nSound.prototype.play = function play() {\n  var _this4 = this;\n\n  return this._operations.enqueue(function () {\n    return _this4._play();\n  });\n};\n\nmodule.exports = Sound;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}