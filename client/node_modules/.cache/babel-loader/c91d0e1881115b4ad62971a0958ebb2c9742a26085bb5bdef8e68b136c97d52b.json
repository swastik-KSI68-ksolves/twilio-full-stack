{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n */\nvar events_1 = require(\"events\");\nvar errors_1 = require(\"./errors\");\nvar log_1 = require(\"./log\");\nvar outputdevicecollection_1 = require(\"./outputdevicecollection\");\nvar defaultMediaDevices = require(\"./shims/mediadevices\");\nvar util_1 = require(\"./util\");\nvar MediaDeviceInfoShim = require('./shims/mediadeviceinfo');\n/**\n * Aliases for audio kinds, used for labelling.\n * @private\n */\nvar kindAliases = {\n  audioinput: 'Audio Input',\n  audiooutput: 'Audio Output'\n};\n/**\n * Provides input and output audio-based functionality in one convenient class.\n * @publicapi\n */\nvar AudioHelper = /** @class */function (_super) {\n  __extends(AudioHelper, _super);\n  /**\n   * @constructor\n   * @private\n   * @param onActiveOutputsChanged - A callback to be called when the user changes the active output devices.\n   * @param onActiveInputChanged - A callback to be called when the user changes the active input device.\n   * @param getUserMedia - The getUserMedia method to use.\n   * @param [options]\n   */\n  function AudioHelper(onActiveOutputsChanged, onActiveInputChanged, getUserMedia, options) {\n    var _this = _super.call(this) || this;\n    /**\n     * A Map of all audio input devices currently available to the browser by their device ID.\n     */\n    _this.availableInputDevices = new Map();\n    /**\n     * A Map of all audio output devices currently available to the browser by their device ID.\n     */\n    _this.availableOutputDevices = new Map();\n    /**\n     * The currently set audio constraints set by setAudioConstraints().\n     */\n    _this._audioConstraints = null;\n    /**\n     * The current input device.\n     */\n    _this._inputDevice = null;\n    /**\n     * The current input stream.\n     */\n    _this._inputStream = null;\n    /**\n     * Whether the {@link AudioHelper} is currently polling the input stream's volume.\n     */\n    _this._isPollingInputVolume = false;\n    /**\n     * An instance of Logger to use.\n     */\n    _this._log = log_1.default.getInstance();\n    /**\n     * A record of unknown devices (Devices without labels)\n     */\n    _this._unknownDeviceIndexes = {\n      audioinput: {},\n      audiooutput: {}\n    };\n    /**\n     * Remove an input device from inputs\n     * @param lostDevice\n     * @returns Whether the device was active\n     */\n    _this._removeLostInput = function (lostDevice) {\n      if (!_this.inputDevice || _this.inputDevice.deviceId !== lostDevice.deviceId) {\n        return false;\n      }\n      _this._replaceStream(null);\n      _this._inputDevice = null;\n      _this._maybeStopPollingVolume();\n      var defaultDevice = _this.availableInputDevices.get('default') || Array.from(_this.availableInputDevices.values())[0];\n      if (defaultDevice) {\n        _this.setInputDevice(defaultDevice.deviceId);\n      }\n      return true;\n    };\n    /**\n     * Remove an input device from outputs\n     * @param lostDevice\n     * @returns Whether the device was active\n     */\n    _this._removeLostOutput = function (lostDevice) {\n      var wasSpeakerLost = _this.speakerDevices.delete(lostDevice);\n      var wasRingtoneLost = _this.ringtoneDevices.delete(lostDevice);\n      return wasSpeakerLost || wasRingtoneLost;\n    };\n    /**\n     * Update the available input and output devices\n     */\n    _this._updateAvailableDevices = function () {\n      if (!_this._mediaDevices || !_this._enumerateDevices) {\n        return Promise.reject('Enumeration not supported');\n      }\n      return _this._enumerateDevices().then(function (devices) {\n        _this._updateDevices(devices.filter(function (d) {\n          return d.kind === 'audiooutput';\n        }), _this.availableOutputDevices, _this._removeLostOutput);\n        _this._updateDevices(devices.filter(function (d) {\n          return d.kind === 'audioinput';\n        }), _this.availableInputDevices, _this._removeLostInput);\n        var defaultDevice = _this.availableOutputDevices.get('default') || Array.from(_this.availableOutputDevices.values())[0];\n        [_this.speakerDevices, _this.ringtoneDevices].forEach(function (outputDevices) {\n          if (!outputDevices.get().size && _this.availableOutputDevices.size && _this.isOutputSelectionSupported) {\n            outputDevices.set(defaultDevice.deviceId).catch(function (reason) {\n              _this._log.warn(\"Unable to set audio output devices. \" + reason);\n            });\n          }\n        });\n      });\n    };\n    options = Object.assign({\n      AudioContext: typeof AudioContext !== 'undefined' && AudioContext,\n      setSinkId: typeof HTMLAudioElement !== 'undefined' && HTMLAudioElement.prototype.setSinkId\n    }, options);\n    _this._getUserMedia = getUserMedia;\n    _this._mediaDevices = options.mediaDevices || defaultMediaDevices;\n    _this._onActiveInputChanged = onActiveInputChanged;\n    _this._enumerateDevices = typeof options.enumerateDevices === 'function' ? options.enumerateDevices : _this._mediaDevices && _this._mediaDevices.enumerateDevices;\n    var isAudioContextSupported = Boolean(options.AudioContext || options.audioContext);\n    var isEnumerationSupported = Boolean(_this._enumerateDevices);\n    var isSetSinkSupported = typeof options.setSinkId === 'function';\n    _this.isOutputSelectionSupported = isEnumerationSupported && isSetSinkSupported;\n    _this.isVolumeSupported = isAudioContextSupported;\n    if (options.enabledSounds) {\n      _this._addEnabledSounds(options.enabledSounds);\n    }\n    if (_this.isVolumeSupported) {\n      _this._audioContext = options.audioContext || options.AudioContext && new options.AudioContext();\n      if (_this._audioContext) {\n        _this._inputVolumeAnalyser = _this._audioContext.createAnalyser();\n        _this._inputVolumeAnalyser.fftSize = 32;\n        _this._inputVolumeAnalyser.smoothingTimeConstant = 0.3;\n      }\n    }\n    _this.ringtoneDevices = new outputdevicecollection_1.default('ringtone', _this.availableOutputDevices, onActiveOutputsChanged, _this.isOutputSelectionSupported);\n    _this.speakerDevices = new outputdevicecollection_1.default('speaker', _this.availableOutputDevices, onActiveOutputsChanged, _this.isOutputSelectionSupported);\n    _this.addListener('newListener', function (eventName) {\n      if (eventName === 'inputVolume') {\n        _this._maybeStartPollingVolume();\n      }\n    });\n    _this.addListener('removeListener', function (eventName) {\n      if (eventName === 'inputVolume') {\n        _this._maybeStopPollingVolume();\n      }\n    });\n    _this.once('newListener', function () {\n      // NOTE (rrowland): Ideally we would only check isEnumerationSupported here, but\n      //   in at least one browser version (Tested in FF48) enumerateDevices actually\n      //   returns bad data for the listed devices. Instead, we check for\n      //   isOutputSelectionSupported to avoid these quirks that may negatively affect customers.\n      if (!_this.isOutputSelectionSupported) {\n        _this._log.warn('Warning: This browser does not support audio output selection.');\n      }\n      if (!_this.isVolumeSupported) {\n        _this._log.warn(\"Warning: This browser does not support Twilio's volume indicator feature.\");\n      }\n    });\n    if (isEnumerationSupported) {\n      _this._initializeEnumeration();\n    }\n    return _this;\n  }\n  Object.defineProperty(AudioHelper.prototype, \"audioConstraints\", {\n    /**\n     * The currently set audio constraints set by setAudioConstraints(). Starts as null.\n     */\n    get: function () {\n      return this._audioConstraints;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AudioHelper.prototype, \"inputDevice\", {\n    /**\n     * The active input device. Having no inputDevice specified by `setInputDevice()`\n     * will disable input selection related functionality.\n     */\n    get: function () {\n      return this._inputDevice;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AudioHelper.prototype, \"inputStream\", {\n    /**\n     * The current input stream.\n     */\n    get: function () {\n      return this._inputStream;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Start polling volume if it's supported and there's an input stream to poll.\n   * @private\n   */\n  AudioHelper.prototype._maybeStartPollingVolume = function () {\n    var _this = this;\n    if (!this.isVolumeSupported || !this._inputStream) {\n      return;\n    }\n    this._updateVolumeSource();\n    if (this._isPollingInputVolume || !this._inputVolumeAnalyser) {\n      return;\n    }\n    var bufferLength = this._inputVolumeAnalyser.frequencyBinCount;\n    var buffer = new Uint8Array(bufferLength);\n    this._isPollingInputVolume = true;\n    var emitVolume = function () {\n      if (!_this._isPollingInputVolume) {\n        return;\n      }\n      if (_this._inputVolumeAnalyser) {\n        _this._inputVolumeAnalyser.getByteFrequencyData(buffer);\n        var inputVolume = util_1.average(buffer);\n        _this.emit('inputVolume', inputVolume / 255);\n      }\n      requestAnimationFrame(emitVolume);\n    };\n    requestAnimationFrame(emitVolume);\n  };\n  /**\n   * Stop polling volume if it's currently polling and there are no listeners.\n   * @private\n   */\n  AudioHelper.prototype._maybeStopPollingVolume = function () {\n    if (!this.isVolumeSupported) {\n      return;\n    }\n    if (!this._isPollingInputVolume || this._inputStream && this.listenerCount('inputVolume')) {\n      return;\n    }\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n      delete this._inputVolumeSource;\n    }\n    this._isPollingInputVolume = false;\n  };\n  /**\n   * Unbind the listeners from mediaDevices.\n   * @private\n   */\n  AudioHelper.prototype._unbind = function () {\n    if (!this._mediaDevices || !this._enumerateDevices) {\n      throw new errors_1.NotSupportedError('Enumeration is not supported');\n    }\n    if (this._mediaDevices.removeEventListener) {\n      this._mediaDevices.removeEventListener('devicechange', this._updateAvailableDevices);\n      this._mediaDevices.removeEventListener('deviceinfochange', this._updateAvailableDevices);\n    }\n  };\n  /**\n   * Set the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. Any deviceId specified here will be ignored. Instead, device IDs should\n   * be specified using {@link AudioHelper#setInputDevice}. The returned Promise resolves\n   * when the media is successfully reacquired, or immediately if no input device is set.\n   * @param audioConstraints - The MediaTrackConstraints to apply.\n   */\n  AudioHelper.prototype.setAudioConstraints = function (audioConstraints) {\n    this._audioConstraints = Object.assign({}, audioConstraints);\n    delete this._audioConstraints.deviceId;\n    return this.inputDevice ? this._setInputDevice(this.inputDevice.deviceId, true) : Promise.resolve();\n  };\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   */\n  AudioHelper.prototype.setInputDevice = function (deviceId) {\n    return !util_1.isFirefox() ? this._setInputDevice(deviceId, false) : Promise.reject(new errors_1.NotSupportedError('Firefox does not currently support opening multiple ' + 'audio input tracks simultaneously, even across different tabs. As a result, ' + 'Device.audio.setInputDevice is disabled on Firefox until support is added.\\n' + 'Related BugZilla thread: https://bugzilla.mozilla.org/show_bug.cgi?id=1299324'));\n  };\n  /**\n   * Unset the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. The returned Promise resolves when the media is successfully reacquired,\n   * or immediately if no input device is set.\n   */\n  AudioHelper.prototype.unsetAudioConstraints = function () {\n    this._audioConstraints = null;\n    return this.inputDevice ? this._setInputDevice(this.inputDevice.deviceId, true) : Promise.resolve();\n  };\n  /**\n   * Unset the input device, stopping the tracks. This should only be called when not in a connection, and\n   *   will not allow removal of the input device during a live call.\n   */\n  AudioHelper.prototype.unsetInputDevice = function () {\n    var _this = this;\n    if (!this.inputDevice) {\n      return Promise.resolve();\n    }\n    return this._onActiveInputChanged(null).then(function () {\n      _this._replaceStream(null);\n      _this._inputDevice = null;\n      _this._maybeStopPollingVolume();\n    });\n  };\n  /**\n   * Merge the passed enabledSounds into {@link AudioHelper}. Currently used to merge the deprecated\n   *   Device.sounds object onto the new {@link AudioHelper} interface. Mutates\n   *   by reference, sharing state between {@link Device} and {@link AudioHelper}.\n   * @param enabledSounds - The initial sound settings to merge.\n   * @private\n   */\n  AudioHelper.prototype._addEnabledSounds = function (enabledSounds) {\n    var _this = this;\n    function setValue(key, value) {\n      if (typeof value !== 'undefined') {\n        enabledSounds[key] = value;\n      }\n      return enabledSounds[key];\n    }\n    Object.keys(enabledSounds).forEach(function (key) {\n      _this[key] = setValue.bind(null, key);\n    });\n  };\n  /**\n   * Get the index of an un-labeled Device.\n   * @param mediaDeviceInfo\n   * @returns The index of the passed MediaDeviceInfo\n   */\n  AudioHelper.prototype._getUnknownDeviceIndex = function (mediaDeviceInfo) {\n    var id = mediaDeviceInfo.deviceId;\n    var kind = mediaDeviceInfo.kind;\n    var index = this._unknownDeviceIndexes[kind][id];\n    if (!index) {\n      index = Object.keys(this._unknownDeviceIndexes[kind]).length + 1;\n      this._unknownDeviceIndexes[kind][id] = index;\n    }\n    return index;\n  };\n  /**\n   * Initialize output device enumeration.\n   */\n  AudioHelper.prototype._initializeEnumeration = function () {\n    var _this = this;\n    if (!this._mediaDevices || !this._enumerateDevices) {\n      throw new errors_1.NotSupportedError('Enumeration is not supported');\n    }\n    if (this._mediaDevices.addEventListener) {\n      this._mediaDevices.addEventListener('devicechange', this._updateAvailableDevices);\n      this._mediaDevices.addEventListener('deviceinfochange', this._updateAvailableDevices);\n    }\n    this._updateAvailableDevices().then(function () {\n      if (!_this.isOutputSelectionSupported) {\n        return;\n      }\n      Promise.all([_this.speakerDevices.set('default'), _this.ringtoneDevices.set('default')]).catch(function (reason) {\n        _this._log.warn(\"Warning: Unable to set audio output devices. \" + reason);\n      });\n    });\n  };\n  /**\n   * Stop the tracks on the current input stream before replacing it with the passed stream.\n   * @param stream - The new stream\n   */\n  AudioHelper.prototype._replaceStream = function (stream) {\n    if (this._inputStream) {\n      this._inputStream.getTracks().forEach(function (track) {\n        track.stop();\n      });\n    }\n    this._inputStream = stream;\n  };\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   * @param forceGetUserMedia - If true, getUserMedia will be called even if\n   *   the specified device is already active.\n   */\n  AudioHelper.prototype._setInputDevice = function (deviceId, forceGetUserMedia) {\n    var _this = this;\n    if (typeof deviceId !== 'string') {\n      return Promise.reject(new errors_1.InvalidArgumentError('Must specify the device to set'));\n    }\n    var device = this.availableInputDevices.get(deviceId);\n    if (!device) {\n      return Promise.reject(new errors_1.InvalidArgumentError(\"Device not found: \" + deviceId));\n    }\n    if (this._inputDevice && this._inputDevice.deviceId === deviceId && this._inputStream) {\n      if (!forceGetUserMedia) {\n        return Promise.resolve();\n      }\n      // If the currently active track is still in readyState `live`, gUM may return the same track\n      // rather than returning a fresh track.\n      this._inputStream.getTracks().forEach(function (track) {\n        track.stop();\n      });\n    }\n    var constraints = {\n      audio: Object.assign({\n        deviceId: {\n          exact: deviceId\n        }\n      }, this.audioConstraints)\n    };\n    return this._getUserMedia(constraints).then(function (stream) {\n      return _this._onActiveInputChanged(stream).then(function () {\n        _this._replaceStream(stream);\n        _this._inputDevice = device;\n        _this._maybeStartPollingVolume();\n      });\n    });\n  };\n  /**\n   * Update a set of devices.\n   * @param updatedDevices - An updated list of available Devices\n   * @param availableDevices - The previous list of available Devices\n   * @param removeLostDevice - The method to call if a previously available Device is\n   *   no longer available.\n   */\n  AudioHelper.prototype._updateDevices = function (updatedDevices, availableDevices, removeLostDevice) {\n    var _this = this;\n    var updatedDeviceIds = updatedDevices.map(function (d) {\n      return d.deviceId;\n    });\n    var knownDeviceIds = Array.from(availableDevices.values()).map(function (d) {\n      return d.deviceId;\n    });\n    var lostActiveDevices = [];\n    // Remove lost devices\n    var lostDeviceIds = util_1.difference(knownDeviceIds, updatedDeviceIds);\n    lostDeviceIds.forEach(function (lostDeviceId) {\n      var lostDevice = availableDevices.get(lostDeviceId);\n      if (lostDevice) {\n        availableDevices.delete(lostDeviceId);\n        if (removeLostDevice(lostDevice)) {\n          lostActiveDevices.push(lostDevice);\n        }\n      }\n    });\n    // Add any new devices, or devices with updated labels\n    var deviceChanged = false;\n    updatedDevices.forEach(function (newDevice) {\n      var existingDevice = availableDevices.get(newDevice.deviceId);\n      var newMediaDeviceInfo = _this._wrapMediaDeviceInfo(newDevice);\n      if (!existingDevice || existingDevice.label !== newMediaDeviceInfo.label) {\n        availableDevices.set(newDevice.deviceId, newMediaDeviceInfo);\n        deviceChanged = true;\n      }\n    });\n    if (deviceChanged || lostDeviceIds.length) {\n      // Force a new gUM in case the underlying tracks of the active stream have changed. One\n      //   reason this might happen is when `default` is selected and set to a USB device,\n      //   then that device is unplugged or plugged back in. We can't check for the 'ended'\n      //   event or readyState because it is asynchronous and may take upwards of 5 seconds,\n      //   in my testing. (rrowland)\n      if (this.inputDevice !== null && this.inputDevice.deviceId === 'default') {\n        this._log.warn(\"Calling getUserMedia after device change to ensure that the           tracks of the active device (default) have not gone stale.\");\n        this._setInputDevice(this.inputDevice.deviceId, true);\n      }\n      this.emit('deviceChange', lostActiveDevices);\n    }\n  };\n  /**\n   * Disconnect the old input volume source, and create and connect a new one with the current\n   * input stream.\n   */\n  AudioHelper.prototype._updateVolumeSource = function () {\n    if (!this._inputStream || !this._audioContext || !this._inputVolumeAnalyser) {\n      return;\n    }\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n    }\n    try {\n      this._inputVolumeSource = this._audioContext.createMediaStreamSource(this._inputStream);\n      this._inputVolumeSource.connect(this._inputVolumeAnalyser);\n    } catch (ex) {\n      this._log.warn('Unable to update volume source', ex);\n      delete this._inputVolumeSource;\n    }\n  };\n  /**\n   * Convert a MediaDeviceInfo to a IMediaDeviceInfoShim.\n   * @param mediaDeviceInfo - The info to convert\n   * @returns The converted shim\n   */\n  AudioHelper.prototype._wrapMediaDeviceInfo = function (mediaDeviceInfo) {\n    var options = {\n      deviceId: mediaDeviceInfo.deviceId,\n      groupId: mediaDeviceInfo.groupId,\n      kind: mediaDeviceInfo.kind,\n      label: mediaDeviceInfo.label\n    };\n    if (!options.label) {\n      if (options.deviceId === 'default') {\n        options.label = 'Default';\n      } else {\n        var index = this._getUnknownDeviceIndex(mediaDeviceInfo);\n        options.label = \"Unknown \" + kindAliases[options.kind] + \" Device \" + index;\n      }\n    }\n    return new MediaDeviceInfoShim(options);\n  };\n  return AudioHelper;\n}(events_1.EventEmitter);\n(function (AudioHelper) {})(AudioHelper || (AudioHelper = {}));\nexports.default = AudioHelper;","map":{"version":3,"names":["events_1","require","errors_1","log_1","outputdevicecollection_1","defaultMediaDevices","util_1","MediaDeviceInfoShim","kindAliases","audioinput","audiooutput","AudioHelper","_super","__extends","onActiveOutputsChanged","onActiveInputChanged","getUserMedia","options","_this","call","availableInputDevices","Map","availableOutputDevices","_audioConstraints","_inputDevice","_inputStream","_isPollingInputVolume","_log","default","getInstance","_unknownDeviceIndexes","_removeLostInput","lostDevice","inputDevice","deviceId","_replaceStream","_maybeStopPollingVolume","defaultDevice","get","Array","from","values","setInputDevice","_removeLostOutput","wasSpeakerLost","speakerDevices","delete","wasRingtoneLost","ringtoneDevices","_updateAvailableDevices","_mediaDevices","_enumerateDevices","Promise","reject","then","devices","_updateDevices","filter","d","kind","forEach","outputDevices","size","isOutputSelectionSupported","set","catch","reason","warn","Object","assign","AudioContext","setSinkId","HTMLAudioElement","prototype","_getUserMedia","mediaDevices","_onActiveInputChanged","enumerateDevices","isAudioContextSupported","Boolean","audioContext","isEnumerationSupported","isSetSinkSupported","isVolumeSupported","enabledSounds","_addEnabledSounds","_audioContext","_inputVolumeAnalyser","createAnalyser","fftSize","smoothingTimeConstant","addListener","eventName","_maybeStartPollingVolume","once","_initializeEnumeration","defineProperty","_updateVolumeSource","bufferLength","frequencyBinCount","buffer","Uint8Array","emitVolume","getByteFrequencyData","inputVolume","average","emit","requestAnimationFrame","listenerCount","_inputVolumeSource","disconnect","_unbind","NotSupportedError","removeEventListener","setAudioConstraints","audioConstraints","_setInputDevice","resolve","isFirefox","unsetAudioConstraints","unsetInputDevice","setValue","key","value","keys","bind","_getUnknownDeviceIndex","mediaDeviceInfo","id","index","length","addEventListener","all","stream","getTracks","track","stop","forceGetUserMedia","InvalidArgumentError","device","constraints","audio","exact","updatedDevices","availableDevices","removeLostDevice","updatedDeviceIds","map","knownDeviceIds","lostActiveDevices","lostDeviceIds","difference","lostDeviceId","push","deviceChanged","newDevice","existingDevice","newMediaDeviceInfo","_wrapMediaDeviceInfo","label","createMediaStreamSource","connect","ex","groupId","EventEmitter","exports"],"sources":["/home/swastikksi/Documents/react/twilio-Ksolves/node_modules/twilio-client/lib/twilio/audiohelper.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n */\nimport { EventEmitter } from 'events';\nimport Device from './device';\nimport { InvalidArgumentError, NotSupportedError } from './errors';\nimport Log from './log';\nimport OutputDeviceCollection from './outputdevicecollection';\nimport * as defaultMediaDevices from './shims/mediadevices';\nimport { average, difference, isFirefox } from './util';\n\nconst MediaDeviceInfoShim = require('./shims/mediadeviceinfo');\n\n/**\n * Aliases for audio kinds, used for labelling.\n * @private\n */\nconst kindAliases: Record<string, string> = {\n  audioinput: 'Audio Input',\n  audiooutput: 'Audio Output',\n};\n\n/**\n * Provides input and output audio-based functionality in one convenient class.\n * @publicapi\n */\nclass AudioHelper extends EventEmitter {\n  /**\n   * The currently set audio constraints set by setAudioConstraints(). Starts as null.\n   */\n  get audioConstraints(): MediaTrackConstraints | null { return this._audioConstraints; }\n\n  /**\n   * A Map of all audio input devices currently available to the browser by their device ID.\n   */\n  availableInputDevices: Map<string, MediaDeviceInfo> = new Map();\n\n  /**\n   * A Map of all audio output devices currently available to the browser by their device ID.\n   */\n  availableOutputDevices: Map<string, MediaDeviceInfo> = new Map();\n\n  /**\n   * The active input device. Having no inputDevice specified by `setInputDevice()`\n   * will disable input selection related functionality.\n   */\n  get inputDevice(): MediaDeviceInfo | null { return this._inputDevice; }\n\n  /**\n   * The current input stream.\n   */\n  get inputStream(): MediaStream | null { return this._inputStream; }\n\n  /**\n   * False if the browser does not support `HTMLAudioElement.setSinkId()` or\n   * `MediaDevices.enumerateDevices()` and Twilio cannot facilitate output selection functionality.\n   */\n  isOutputSelectionSupported: boolean;\n\n  /**\n   * False if the browser does not support AudioContext and Twilio can not analyse the volume\n   * in real-time.\n   */\n  isVolumeSupported: boolean;\n\n  /**\n   * The current set of output devices that incoming ringtone audio is routed through.\n   * These are the sounds that may play while the user is away from the machine or not wearing\n   * their headset. It is important that this audio is heard. If all specified\n   * devices lost, this Set will revert to contain only the \"default\" device.\n   */\n  ringtoneDevices: OutputDeviceCollection;\n\n  /**\n   * The current set of output devices that call audio (`[voice, outgoing, disconnect, dtmf]`)\n   * is routed through. These are the sounds that are initiated by the user, or played while\n   * the user is otherwise present at the endpoint. If all specified devices are lost,\n   * this Set will revert to contain only the \"default\" device.\n   */\n  speakerDevices: OutputDeviceCollection;\n\n  /**\n   * The currently set audio constraints set by setAudioConstraints().\n   */\n  private _audioConstraints: MediaTrackConstraints | null = null;\n\n  /**\n   * An AudioContext to use.\n   */\n  private _audioContext?: AudioContext;\n\n  private _enumerateDevices: any;\n\n  /**\n   * The `getUserMedia()` function to use.\n   */\n  private _getUserMedia: (constraints: MediaStreamConstraints) => Promise<MediaStream>;\n\n  /**\n   * The current input device.\n   */\n  private _inputDevice: MediaDeviceInfo | null = null;\n\n  /**\n   * The current input stream.\n   */\n  private _inputStream: MediaStream | null = null;\n\n  /**\n   * An AnalyserNode to use for input volume.\n   */\n  private _inputVolumeAnalyser?: AnalyserNode;\n\n  /**\n   * An MediaStreamSource to use for input volume.\n   */\n  private _inputVolumeSource?: MediaStreamAudioSourceNode;\n\n  /**\n   * Whether the {@link AudioHelper} is currently polling the input stream's volume.\n   */\n  private _isPollingInputVolume: boolean = false;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = Log.getInstance();\n\n  /**\n   * The MediaDevices instance to use.\n   */\n  private _mediaDevices: AudioHelper.MediaDevicesLike | null;\n\n  /**\n   * Called with the new input stream when the active input is changed.\n   */\n  private _onActiveInputChanged: (stream: MediaStream | null) => Promise<void>;\n\n  /**\n   * A record of unknown devices (Devices without labels)\n   */\n  private _unknownDeviceIndexes: Record<string, Record<string, number>> = {\n    audioinput: { },\n    audiooutput: { },\n  };\n\n  /**\n   * @constructor\n   * @private\n   * @param onActiveOutputsChanged - A callback to be called when the user changes the active output devices.\n   * @param onActiveInputChanged - A callback to be called when the user changes the active input device.\n   * @param getUserMedia - The getUserMedia method to use.\n   * @param [options]\n   */\n  constructor(onActiveOutputsChanged: (type: 'ringtone' | 'speaker', outputIds: string[]) => Promise<void>,\n              onActiveInputChanged: (stream: MediaStream | null) => Promise<void>,\n              getUserMedia: (constraints: MediaStreamConstraints) => Promise<MediaStream>,\n              options?: AudioHelper.Options) {\n    super();\n\n    options = Object.assign({\n      AudioContext: typeof AudioContext !== 'undefined' && AudioContext,\n      setSinkId: typeof HTMLAudioElement !== 'undefined' && (HTMLAudioElement.prototype as any).setSinkId,\n    }, options);\n\n    this._getUserMedia = getUserMedia;\n    this._mediaDevices = options.mediaDevices || defaultMediaDevices;\n    this._onActiveInputChanged = onActiveInputChanged;\n    this._enumerateDevices = typeof options.enumerateDevices === 'function'\n      ? options.enumerateDevices\n      : this._mediaDevices && this._mediaDevices.enumerateDevices;\n\n    const isAudioContextSupported: boolean = Boolean(options.AudioContext || options.audioContext);\n    const isEnumerationSupported: boolean = Boolean(this._enumerateDevices);\n    const isSetSinkSupported: boolean = typeof options.setSinkId === 'function';\n    this.isOutputSelectionSupported = isEnumerationSupported && isSetSinkSupported;\n    this.isVolumeSupported = isAudioContextSupported;\n\n    if (options.enabledSounds) {\n      this._addEnabledSounds(options.enabledSounds);\n    }\n\n    if (this.isVolumeSupported) {\n      this._audioContext = options.audioContext || options.AudioContext && new options.AudioContext();\n      if (this._audioContext) {\n        this._inputVolumeAnalyser = this._audioContext.createAnalyser();\n        this._inputVolumeAnalyser.fftSize = 32;\n        this._inputVolumeAnalyser.smoothingTimeConstant = 0.3;\n      }\n    }\n\n    this.ringtoneDevices = new OutputDeviceCollection('ringtone',\n      this.availableOutputDevices, onActiveOutputsChanged, this.isOutputSelectionSupported);\n    this.speakerDevices = new OutputDeviceCollection('speaker',\n      this.availableOutputDevices, onActiveOutputsChanged, this.isOutputSelectionSupported);\n\n    this.addListener('newListener', (eventName: string) => {\n      if (eventName === 'inputVolume') {\n        this._maybeStartPollingVolume();\n      }\n    });\n\n    this.addListener('removeListener', (eventName: string) => {\n      if (eventName === 'inputVolume') {\n        this._maybeStopPollingVolume();\n      }\n    });\n\n    this.once('newListener', () => {\n      // NOTE (rrowland): Ideally we would only check isEnumerationSupported here, but\n      //   in at least one browser version (Tested in FF48) enumerateDevices actually\n      //   returns bad data for the listed devices. Instead, we check for\n      //   isOutputSelectionSupported to avoid these quirks that may negatively affect customers.\n      if (!this.isOutputSelectionSupported) {\n        this._log.warn('Warning: This browser does not support audio output selection.');\n      }\n\n      if (!this.isVolumeSupported) {\n        this._log.warn(`Warning: This browser does not support Twilio's volume indicator feature.`);\n      }\n    });\n\n    if (isEnumerationSupported) {\n      this._initializeEnumeration();\n    }\n  }\n\n  /**\n   * Start polling volume if it's supported and there's an input stream to poll.\n   * @private\n   */\n  _maybeStartPollingVolume(): void {\n    if (!this.isVolumeSupported || !this._inputStream) { return; }\n\n    this._updateVolumeSource();\n\n    if (this._isPollingInputVolume || !this._inputVolumeAnalyser) { return; }\n\n    const bufferLength: number = this._inputVolumeAnalyser.frequencyBinCount;\n    const buffer: Uint8Array = new Uint8Array(bufferLength);\n\n    this._isPollingInputVolume = true;\n\n    const emitVolume = (): void => {\n      if (!this._isPollingInputVolume) { return; }\n\n      if (this._inputVolumeAnalyser) {\n        this._inputVolumeAnalyser.getByteFrequencyData(buffer);\n        const inputVolume: number = average(buffer);\n\n        this.emit('inputVolume', inputVolume / 255);\n      }\n\n      requestAnimationFrame(emitVolume);\n    };\n\n    requestAnimationFrame(emitVolume);\n  }\n\n  /**\n   * Stop polling volume if it's currently polling and there are no listeners.\n   * @private\n   */\n  _maybeStopPollingVolume(): void {\n    if (!this.isVolumeSupported) { return; }\n\n    if (!this._isPollingInputVolume || (this._inputStream && this.listenerCount('inputVolume'))) {\n      return;\n    }\n\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n      delete this._inputVolumeSource;\n    }\n\n    this._isPollingInputVolume = false;\n  }\n\n  /**\n   * Unbind the listeners from mediaDevices.\n   * @private\n   */\n  _unbind(): void {\n    if (!this._mediaDevices || !this._enumerateDevices) {\n      throw new NotSupportedError('Enumeration is not supported');\n    }\n\n    if (this._mediaDevices.removeEventListener) {\n      this._mediaDevices.removeEventListener('devicechange', this._updateAvailableDevices);\n      this._mediaDevices.removeEventListener('deviceinfochange', this._updateAvailableDevices);\n    }\n  }\n\n  /**\n   * Set the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. Any deviceId specified here will be ignored. Instead, device IDs should\n   * be specified using {@link AudioHelper#setInputDevice}. The returned Promise resolves\n   * when the media is successfully reacquired, or immediately if no input device is set.\n   * @param audioConstraints - The MediaTrackConstraints to apply.\n   */\n  setAudioConstraints(audioConstraints: MediaTrackConstraints): Promise<void> {\n    this._audioConstraints = Object.assign({ }, audioConstraints);\n    delete this._audioConstraints.deviceId;\n\n    return this.inputDevice\n      ? this._setInputDevice(this.inputDevice.deviceId, true)\n      : Promise.resolve();\n  }\n\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   */\n  setInputDevice(deviceId: string): Promise<void> {\n    return !isFirefox()\n      ? this._setInputDevice(deviceId, false)\n      : Promise.reject(new NotSupportedError('Firefox does not currently support opening multiple ' +\n        'audio input tracks simultaneously, even across different tabs. As a result, ' +\n        'Device.audio.setInputDevice is disabled on Firefox until support is added.\\n' +\n        'Related BugZilla thread: https://bugzilla.mozilla.org/show_bug.cgi?id=1299324'));\n  }\n\n  /**\n   * Unset the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. The returned Promise resolves when the media is successfully reacquired,\n   * or immediately if no input device is set.\n   */\n  unsetAudioConstraints(): Promise<void> {\n    this._audioConstraints = null;\n    return this.inputDevice\n      ? this._setInputDevice(this.inputDevice.deviceId, true)\n      : Promise.resolve();\n  }\n\n  /**\n   * Unset the input device, stopping the tracks. This should only be called when not in a connection, and\n   *   will not allow removal of the input device during a live call.\n   */\n  unsetInputDevice(): Promise<void> {\n    if (!this.inputDevice) { return Promise.resolve(); }\n\n    return this._onActiveInputChanged(null).then(() => {\n      this._replaceStream(null);\n      this._inputDevice = null;\n      this._maybeStopPollingVolume();\n    });\n  }\n\n  /**\n   * Merge the passed enabledSounds into {@link AudioHelper}. Currently used to merge the deprecated\n   *   Device.sounds object onto the new {@link AudioHelper} interface. Mutates\n   *   by reference, sharing state between {@link Device} and {@link AudioHelper}.\n   * @param enabledSounds - The initial sound settings to merge.\n   * @private\n   */\n  private _addEnabledSounds(enabledSounds: { [name: string]: boolean }) {\n    function setValue(key: Device.ToggleableSound, value: boolean) {\n      if (typeof value !== 'undefined') {\n        enabledSounds[key] = value;\n      }\n\n      return enabledSounds[key];\n    }\n\n    Object.keys(enabledSounds).forEach(key => {\n      (this as any)[key] = setValue.bind(null, key);\n    });\n  }\n\n  /**\n   * Get the index of an un-labeled Device.\n   * @param mediaDeviceInfo\n   * @returns The index of the passed MediaDeviceInfo\n   */\n  private _getUnknownDeviceIndex(mediaDeviceInfo: MediaDeviceInfo): number {\n    const id: string = mediaDeviceInfo.deviceId;\n    const kind: string = mediaDeviceInfo.kind;\n\n    let index: number = this._unknownDeviceIndexes[kind][id];\n    if (!index) {\n      index = Object.keys(this._unknownDeviceIndexes[kind]).length + 1;\n      this._unknownDeviceIndexes[kind][id] = index;\n    }\n\n    return index;\n  }\n\n  /**\n   * Initialize output device enumeration.\n   */\n  private _initializeEnumeration(): void {\n    if (!this._mediaDevices || !this._enumerateDevices) {\n      throw new NotSupportedError('Enumeration is not supported');\n    }\n\n    if (this._mediaDevices.addEventListener) {\n      this._mediaDevices.addEventListener('devicechange', this._updateAvailableDevices);\n      this._mediaDevices.addEventListener('deviceinfochange', this._updateAvailableDevices);\n    }\n\n    this._updateAvailableDevices().then(() => {\n      if (!this.isOutputSelectionSupported) { return; }\n\n      Promise.all([\n        this.speakerDevices.set('default'),\n        this.ringtoneDevices.set('default'),\n      ]).catch(reason => {\n        this._log.warn(`Warning: Unable to set audio output devices. ${reason}`);\n      });\n    });\n  }\n\n  /**\n   * Remove an input device from inputs\n   * @param lostDevice\n   * @returns Whether the device was active\n   */\n  private _removeLostInput = (lostDevice: MediaDeviceInfo): boolean => {\n    if (!this.inputDevice || this.inputDevice.deviceId !== lostDevice.deviceId) {\n      return false;\n    }\n\n    this._replaceStream(null);\n    this._inputDevice = null;\n    this._maybeStopPollingVolume();\n\n    const defaultDevice: MediaDeviceInfo = this.availableInputDevices.get('default')\n      || Array.from(this.availableInputDevices.values())[0];\n\n    if (defaultDevice) {\n      this.setInputDevice(defaultDevice.deviceId);\n    }\n\n    return true;\n  }\n\n  /**\n   * Remove an input device from outputs\n   * @param lostDevice\n   * @returns Whether the device was active\n   */\n  private _removeLostOutput = (lostDevice: MediaDeviceInfo): boolean => {\n    const wasSpeakerLost: boolean = this.speakerDevices.delete(lostDevice);\n    const wasRingtoneLost: boolean = this.ringtoneDevices.delete(lostDevice);\n    return wasSpeakerLost || wasRingtoneLost;\n  }\n\n  /**\n   * Stop the tracks on the current input stream before replacing it with the passed stream.\n   * @param stream - The new stream\n   */\n  private _replaceStream(stream: MediaStream | null): void {\n    if (this._inputStream) {\n      this._inputStream.getTracks().forEach(track => {\n        track.stop();\n      });\n    }\n\n    this._inputStream = stream;\n  }\n\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   * @param forceGetUserMedia - If true, getUserMedia will be called even if\n   *   the specified device is already active.\n   */\n  private _setInputDevice(deviceId: string, forceGetUserMedia: boolean): Promise<void> {\n    if (typeof deviceId !== 'string') {\n      return Promise.reject(new InvalidArgumentError('Must specify the device to set'));\n    }\n\n    const device: MediaDeviceInfo | undefined = this.availableInputDevices.get(deviceId);\n    if (!device) {\n      return Promise.reject(new InvalidArgumentError(`Device not found: ${deviceId}`));\n    }\n\n    if (this._inputDevice && this._inputDevice.deviceId === deviceId && this._inputStream) {\n      if (!forceGetUserMedia) {\n        return Promise.resolve();\n      }\n\n      // If the currently active track is still in readyState `live`, gUM may return the same track\n      // rather than returning a fresh track.\n      this._inputStream.getTracks().forEach(track => {\n        track.stop();\n      });\n    }\n\n    const constraints = { audio: Object.assign({ deviceId: { exact: deviceId } }, this.audioConstraints) };\n    return this._getUserMedia(constraints).then((stream: MediaStream) => {\n      return this._onActiveInputChanged(stream).then(() => {\n        this._replaceStream(stream);\n        this._inputDevice = device;\n        this._maybeStartPollingVolume();\n      });\n    });\n  }\n\n  /**\n   * Update the available input and output devices\n   */\n  private _updateAvailableDevices = (): Promise<void> => {\n    if (!this._mediaDevices || !this._enumerateDevices) {\n      return Promise.reject('Enumeration not supported');\n    }\n\n    return this._enumerateDevices().then((devices: MediaDeviceInfo[]) => {\n      this._updateDevices(devices.filter((d: MediaDeviceInfo) => d.kind === 'audiooutput'),\n        this.availableOutputDevices,\n        this._removeLostOutput);\n\n      this._updateDevices(devices.filter((d: MediaDeviceInfo) => d.kind === 'audioinput'),\n        this.availableInputDevices,\n        this._removeLostInput);\n\n      const defaultDevice = this.availableOutputDevices.get('default')\n        || Array.from(this.availableOutputDevices.values())[0];\n\n      [this.speakerDevices, this.ringtoneDevices].forEach(outputDevices => {\n        if (!outputDevices.get().size && this.availableOutputDevices.size && this.isOutputSelectionSupported) {\n          outputDevices.set(defaultDevice.deviceId)\n            .catch((reason) => {\n              this._log.warn(`Unable to set audio output devices. ${reason}`);\n            });\n        }\n      });\n    });\n  }\n\n  /**\n   * Update a set of devices.\n   * @param updatedDevices - An updated list of available Devices\n   * @param availableDevices - The previous list of available Devices\n   * @param removeLostDevice - The method to call if a previously available Device is\n   *   no longer available.\n   */\n  private _updateDevices(updatedDevices: MediaDeviceInfo[],\n                         availableDevices: Map<string, MediaDeviceInfo>,\n                         removeLostDevice: (lostDevice: MediaDeviceInfo) => boolean): void {\n    const updatedDeviceIds: string[] = updatedDevices.map(d => d.deviceId);\n    const knownDeviceIds: string[] = Array.from(availableDevices.values()).map(d => d.deviceId);\n    const lostActiveDevices: MediaDeviceInfo[] = [];\n\n    // Remove lost devices\n    const lostDeviceIds: string[] = difference(knownDeviceIds, updatedDeviceIds);\n    lostDeviceIds.forEach((lostDeviceId: string) => {\n      const lostDevice: MediaDeviceInfo | undefined = availableDevices.get(lostDeviceId);\n      if (lostDevice) {\n        availableDevices.delete(lostDeviceId);\n        if (removeLostDevice(lostDevice)) { lostActiveDevices.push(lostDevice); }\n      }\n    });\n\n    // Add any new devices, or devices with updated labels\n    let deviceChanged: boolean = false;\n    updatedDevices.forEach(newDevice => {\n      const existingDevice: MediaDeviceInfo | undefined = availableDevices.get(newDevice.deviceId);\n      const newMediaDeviceInfo: MediaDeviceInfo = this._wrapMediaDeviceInfo(newDevice);\n\n      if (!existingDevice || existingDevice.label !== newMediaDeviceInfo.label) {\n        availableDevices.set(newDevice.deviceId, newMediaDeviceInfo);\n        deviceChanged = true;\n      }\n    });\n\n    if (deviceChanged || lostDeviceIds.length) {\n      // Force a new gUM in case the underlying tracks of the active stream have changed. One\n      //   reason this might happen is when `default` is selected and set to a USB device,\n      //   then that device is unplugged or plugged back in. We can't check for the 'ended'\n      //   event or readyState because it is asynchronous and may take upwards of 5 seconds,\n      //   in my testing. (rrowland)\n      if (this.inputDevice !== null && this.inputDevice.deviceId === 'default') {\n        this._log.warn(`Calling getUserMedia after device change to ensure that the \\\n          tracks of the active device (default) have not gone stale.`);\n        this._setInputDevice(this.inputDevice.deviceId, true);\n      }\n\n      this.emit('deviceChange', lostActiveDevices);\n    }\n  }\n\n  /**\n   * Disconnect the old input volume source, and create and connect a new one with the current\n   * input stream.\n   */\n  private _updateVolumeSource(): void {\n    if (!this._inputStream || !this._audioContext || !this._inputVolumeAnalyser) {\n      return;\n    }\n\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n    }\n\n    try {\n      this._inputVolumeSource = this._audioContext.createMediaStreamSource(this._inputStream);\n      this._inputVolumeSource.connect(this._inputVolumeAnalyser);\n    } catch (ex) {\n      this._log.warn('Unable to update volume source', ex);\n      delete this._inputVolumeSource;\n    }\n  }\n\n  /**\n   * Convert a MediaDeviceInfo to a IMediaDeviceInfoShim.\n   * @param mediaDeviceInfo - The info to convert\n   * @returns The converted shim\n   */\n  private _wrapMediaDeviceInfo(mediaDeviceInfo: MediaDeviceInfo): MediaDeviceInfo {\n    const options: Record<string, string> = {\n      deviceId: mediaDeviceInfo.deviceId,\n      groupId: mediaDeviceInfo.groupId,\n      kind: mediaDeviceInfo.kind,\n      label: mediaDeviceInfo.label,\n    };\n\n    if (!options.label) {\n      if (options.deviceId === 'default') {\n        options.label = 'Default';\n      } else {\n        const index: number = this._getUnknownDeviceIndex(mediaDeviceInfo);\n        options.label = `Unknown ${kindAliases[options.kind]} Device ${index}`;\n      }\n    }\n\n    return new MediaDeviceInfoShim(options) as MediaDeviceInfo;\n  }\n}\n\nnamespace AudioHelper {\n  /**\n   * Emitted when the available set of Devices changes.\n   * @param lostActiveDevices - An array containing any Devices that were previously active\n   * that were lost as a result of this deviceChange event.\n   * @example `device.audio.on('deviceChange', lostActiveDevices => { })`\n   * @event\n   * @private\n   */\n  declare function deviceChangeEvent(lostActiveDevices: MediaDeviceInfo[]): void;\n\n  /**\n   * Emitted on `requestAnimationFrame` (up to 60fps, depending on browser) with\n   *   the current input and output volumes, as a percentage of maximum\n   *   volume, between -100dB and -30dB. Represented by a floating point\n   *   number.\n   * @param inputVolume - A floating point number between 0.0 and 1.0 inclusive.\n   * @example `device.audio.on('inputVolume', volume => { })`\n   * @event\n   */\n  declare function inputVolumeEvent(inputVolume: number): void;\n\n  /**\n   * An object like MediaDevices.\n   * @private\n   */\n  export interface MediaDevicesLike {\n    addEventListener?: (eventName: string, handler: (...args: any[]) => void) => void;\n    enumerateDevices: (...args: any[]) => any;\n    getUserMedia: (...args: any[]) => any;\n    removeEventListener?: (eventName: string, handler: (...args: any[]) => void) => void;\n  }\n\n  /**\n   * Options that can be passed to the AudioHelper constructor\n   * @private\n   */\n  export interface Options {\n    /**\n     * A custom replacement for the AudioContext constructor.\n     */\n    AudioContext?: typeof AudioContext;\n\n    /**\n     * An existing AudioContext instance to use.\n     */\n    audioContext?: AudioContext;\n\n    /**\n     * A Record of sounds. This is modified by reference, and is used to\n     * maintain backward-compatibility. This should be removed or refactored in 2.0.\n     * TODO: Remove / refactor in 2.0. (CLIENT-5302)\n     */\n    enabledSounds?: Record<Device.ToggleableSound, boolean>;\n\n    /**\n     * Overrides the native MediaDevices.enumerateDevices API.\n     */\n    enumerateDevices?: any;\n\n    /**\n     * A custom MediaDevices instance to use.\n     */\n    mediaDevices?: AudioHelper.MediaDevicesLike;\n\n    /**\n     * A custom setSinkId function to use.\n     */\n    setSinkId?: (sinkId: string) => Promise<void>;\n  }\n}\n\nexport default AudioHelper;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}